msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2007-10-25 07:47+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: basic_mapping.xml:5
#, no-c-format
msgid "Basic O/R Mapping"
msgstr "基本的なO/Rマッピング"

#. Tag: title
#: basic_mapping.xml:8
#, no-c-format
msgid "Mapping declaration"
msgstr "マッピング定義"

#. Tag: para
#: basic_mapping.xml:10
#, no-c-format
msgid ""
"Object/relational mappings are usually defined in an XML document. The "
"mapping document is designed to be readable and hand-editable. The mapping "
"language is Java-centric, meaning that mappings are constructed around "
"persistent class declarations, not table declarations."
msgstr ""
"オブジェクト/リレーショナルマッピングは通常XMLドキュメントで定義します。 マッ"
"ピングドキュメントは、読みやすく手作業で編集しやすいようにデザインされていま"
"す。 マッピング言語はJava中心、つまりテーブル定義ではなく永続クラスの定義に基"
"づいて構築されています。"

#. Tag: para
#: basic_mapping.xml:17
#, no-c-format
msgid ""
"Note that, even though many Hibernate users choose to write the XML by hand, "
"a number of tools exist to generate the mapping document, including XDoclet, "
"Middlegen and AndroMDA."
msgstr ""
"多くのHibernateユーザはXMLマッピングの記述を手作業で行いますが、 XDoclet, "
"Middlegen, AndroMDAというようなマッピングドキュメントを生成するツールが いく"
"つか存在します。"

#. Tag: para
#: basic_mapping.xml:23
#, no-c-format
msgid "Lets kick off with an example mapping:"
msgstr "サンプルのマッピングから始めましょう："

#. Tag: programlisting
#: basic_mapping.xml:27
#, no-c-format
msgid ""
"<![CDATA[<?xml version=\"1.0\"?>\n"
"<!DOCTYPE hibernate-mapping PUBLIC\n"
"      \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
"          \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\n"
"\n"
"<hibernate-mapping package=\"eg\">\n"
"\n"
"        <class name=\"Cat\"\n"
"            table=\"cats\"\n"
"            discriminator-value=\"C\">\n"
"\n"
"                <id name=\"id\">\n"
"                        <generator class=\"native\"/>\n"
"                </id>\n"
"\n"
"                <discriminator column=\"subclass\"\n"
"                     type=\"character\"/>\n"
"\n"
"                <property name=\"weight\"/>\n"
"\n"
"                <property name=\"birthdate\"\n"
"                    type=\"date\"\n"
"                    not-null=\"true\"\n"
"                    update=\"false\"/>\n"
"\n"
"                <property name=\"color\"\n"
"                    type=\"eg.types.ColorUserType\"\n"
"                    not-null=\"true\"\n"
"                    update=\"false\"/>\n"
"\n"
"                <property name=\"sex\"\n"
"                    not-null=\"true\"\n"
"                    update=\"false\"/>\n"
"\n"
"                <property name=\"litterId\"\n"
"                    column=\"litterId\"\n"
"                    update=\"false\"/>\n"
"\n"
"                <many-to-one name=\"mother\"\n"
"                    column=\"mother_id\"\n"
"                    update=\"false\"/>\n"
"\n"
"                <set name=\"kittens\"\n"
"                    inverse=\"true\"\n"
"                    order-by=\"litter_id\">\n"
"                        <key column=\"mother_id\"/>\n"
"                        <one-to-many class=\"Cat\"/>\n"
"                </set>\n"
"\n"
"                <subclass name=\"DomesticCat\"\n"
"                    discriminator-value=\"D\">\n"
"\n"
"                        <property name=\"name\"\n"
"                            type=\"string\"/>\n"
"\n"
"                </subclass>\n"
"\n"
"        </class>\n"
"\n"
"        <class name=\"Dog\">\n"
"                <!-- mapping for Dog could go here -->\n"
"        </class>\n"
"\n"
"</hibernate-mapping>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:29
#, no-c-format
msgid ""
"We will now discuss the content of the mapping document. We will only "
"describe the document elements and attributes that are used by Hibernate at "
"runtime. The mapping document also contains some extra optional attributes "
"and elements that affect the database schemas exported by the schema export "
"tool. (For example the <literal> not-null</literal> attribute.)"
msgstr ""
"マッピングドキュメントの内容を説明します。。 ただし、ここではHibernateが実行"
"時に使うドキュメント要素と属性についてのみ説明します。 マッピングドキュメント"
"は、いくつかのオプション属性と要素を含んでいます（例えば <literal>not-null</"
"literal> 属性）。 それらはスキーマエクスポートツールが出力するデータベースス"
"キーマに影響を与えるものです。"

#. Tag: title
#: basic_mapping.xml:40
#, no-c-format
msgid "Doctype"
msgstr "Doctype"

#. Tag: para
#: basic_mapping.xml:42
#, no-c-format
msgid ""
"All XML mappings should declare the doctype shown. The actual DTD may be "
"found at the URL above, in the directory <literal>hibernate-x.x.x/src/org/"
"hibernate </literal> or in <literal>hibernate3.jar</literal>. Hibernate will "
"always look for the DTD in its classpath first. If you experience lookups of "
"the DTD using an Internet connection, check your DTD declaration against the "
"contents of your claspath."
msgstr ""
"XMLマッピングでは、お見せしたようなドキュメント型を必ず定義すべきです。 実際"
"のDTDは、上記のURLの <literal>hibernate-x.x.x/src/org/hibernate</literal> "
"ディレクトリ、 または <literal>hibernate.jar</literal> 内にあります。 "
"Hibernateは常に、そのクラスパス内でDTDを探し始めます。 インターネットにある"
"DTDファイルを探そうとしたなら、 クラスパスの内容を見て、DTD宣言を確認してくだ"
"さい。"

#. Tag: title
#: basic_mapping.xml:52
#, no-c-format
msgid "EntityResolver"
msgstr "エンティティ・リゾルバ"

#. Tag: para
#: basic_mapping.xml:53
#, no-c-format
msgid ""
"As mentioned previously, Hibernate will first attempt to resolve DTDs in its "
"classpath. The manner in which it does this is by registering a custom "
"<literal>org.xml.sax.EntityResolver</literal> implementation with the "
"SAXReader it uses to read in the xml files. This custom "
"<literal>EntityResolver</literal> recognizes two different systemId "
"namespaces."
msgstr ""
"前述したように、Hibernateはまずクラスパス内でDTDを解決しようとします。 "
"<literal>org.xml.sax.EntityResolver</literal> のカスタム実装を XMLファイルを"
"読み込むためのSAXReaderに登録することによって、DTDを解決します。 このカスタム"
"の <literal>EntityResolver</literal> は2つの異なるシステムID名前空間を認識し"
"ます。"

#. Tag: para
#: basic_mapping.xml:61
#, no-c-format
msgid ""
"a <literal>hibernate namespace</literal> is recognized whenever the resolver "
"encounteres a systemId starting with <literal>http://hibernate.sourceforge."
"net/</literal>; the resolver attempts to resolve these entities via the "
"classlaoder which loaded the Hibernate classes."
msgstr ""
"<literal>Hibernate名前空間</literal> は、リゾルバが <literal>http://"
"hibernate.sourceforge.net/</literal> で始まるシステムIDに到達したときに、 認"
"識されます。 そしてリゾルバは、Hibernateのクラスをロードしたクラスローダを用"
"いて、 これらのエンティティを解決しようとします。"

#. Tag: para
#: basic_mapping.xml:70
#, no-c-format
msgid ""
"a <literal>user namespace</literal> is recognized whenever the resolver "
"encounteres a systemId using a <literal>classpath://</literal> URL protocol; "
"the resolver will attempt to resolve these entities via (1) the current "
"thread context classloader and (2) the classloader which loaded the "
"Hibernate classes."
msgstr ""
"<literal>ユーザ名前空間</literal> は、リゾルバが URLプロトコルの "
"<literal>classpath://</literal> を使ったシステムIDに到達したときに、 認識され"
"ます。そしてリゾルバは、(1)カレントスレッドのコンテキストクラスローダー、 ま"
"たは(2)Hibernateのクラスをロードしたクラスローダを使って、 これらのエンティ"
"ティを解決しようとします。"

#. Tag: para
#: basic_mapping.xml:79
#, no-c-format
msgid "An example of utilizing user namespacing:"
msgstr "下記は、ユーザ名前空間を使った例です："

#. Tag: programlisting
#: basic_mapping.xml:82
#, no-c-format
msgid ""
"<![CDATA[<?xml version=\"1.0\"?>\n"
"<!DOCTYPE hibernate-mapping PUBLIC\n"
"        \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
"        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\" [\n"
"    <!ENTITY types SYSTEM \"classpath://your/domain/types.xml\">\n"
"]>\n"
"\n"
"<hibernate-mapping package=\"your.domain\">\n"
"    <class name=\"MyEntity\">\n"
"        <id name=\"id\" type=\"my-custom-id-type\">\n"
"            ...\n"
"        </id>\n"
"    <class>\n"
"    &types;\n"
"</hibernate-mapping>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:83
#, no-c-format
msgid ""
"Where <literal>types.xml</literal> is a resource in the <literal>your."
"domain</literal> package and contains a custom <link linkend=\"mapping-types-"
"custom\">typedef</link>."
msgstr ""
"ここで <literal>types.xml</literal> は <literal>your.domain</literal> パッ"
"ケージ内のリソースであり、 カスタム <xref linkend=\"mapping-types-custom"
"\">typedef</xref> を含むます。"

#. Tag: title
#: basic_mapping.xml:91
#, no-c-format
msgid "hibernate-mapping"
msgstr "hibernate-mapping"

#. Tag: para
#: basic_mapping.xml:93
#, no-c-format
msgid ""
"This element has several optional attributes. The <literal>schema</literal> "
"and <literal>catalog</literal> attributes specify that tables referred to in "
"this mapping belong to the named schema and/or catalog. If specified, "
"tablenames will be qualified by the given schema and catalog names. If "
"missing, tablenames will be unqualified. The <literal>default-cascade</"
"literal> attribute specifies what cascade style should be assumed for "
"properties and collections which do not specify a <literal>cascade</literal> "
"attribute. The <literal>auto-import</literal> attribute lets us use "
"unqualified class names in the query language, by default."
msgstr ""
"この要素にはいくつかオプション属性があります。<literal>schema</literal> 属性"
"と <literal>catalog</literal> 属性は、 このマッピングが参照するテーブルが、こ"
"の属性によって指定されたスキーマと(または)カタログに属することを指定します。 "
"この属性が指定されると、テーブル名は与えられたスキーマ名とカタログ名で修飾さ"
"れます。これらの属性が指定されていなければ、 テーブル名は修飾されません。"
"<literal>default-cascade</literal> 属性は、 <literal>cascade</literal> 属性を"
"指定していないプロパティやコレクションに、 どのカスケードスタイルを割り当てる"
"かを指定します。 <literal>auto-import</literal> 属性は、 クエリ言語内で修飾さ"
"れていないクラス名を、デフォルトで使えるようにします。"

#. Tag: programlisting
#: basic_mapping.xml:114
#, no-c-format
msgid ""
"<![CDATA[<hibernate-mapping\n"
"         schema=\"schemaName\"\n"
"         catalog=\"catalogName\"\n"
"         default-cascade=\"cascade_style\"\n"
"         default-access=\"field|property|ClassName\"\n"
"         default-lazy=\"true|false\"\n"
"         auto-import=\"true|false\"\n"
"         package=\"package.name\"\n"
" />]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:117
#, no-c-format
msgid "<literal>schema</literal> (optional): The name of a database schema."
msgstr "<literal>schema</literal>（オプション）：データベーススキーマの名前。"

#. Tag: para
#: basic_mapping.xml:122
#, no-c-format
msgid "<literal>catalog</literal> (optional): The name of a database catalog."
msgstr ""
"<literal>catalog</literal> （オプション）：データベースカタログの名前。"

#. Tag: para
#: basic_mapping.xml:127
#, no-c-format
msgid ""
"<literal>default-cascade</literal> (optional - defaults to <literal>none</"
"literal>): A default cascade style."
msgstr ""
"<literal>default-cascade</literal> （オプション - デフォルトは "
"<literal>none</literal>）： デフォルトのカスケードスタイル。"

#. Tag: para
#: basic_mapping.xml:133
#, no-c-format
msgid ""
"<literal>default-access</literal> (optional - defaults to <literal>property</"
"literal>): The strategy Hibernate should use for accessing all properties. "
"Can be a custom implementation of <literal>PropertyAccessor</literal>."
msgstr ""
"<literal>default-access</literal> (オプション - デフォルトは "
"<literal>property</literal> ）： Hibernateがプロパティにアクセスする際に採る"
"べき戦略。 <literal>PropertyAccessor</literal> を実装することでカスタマイズ可"
"能。"

#. Tag: para
#: basic_mapping.xml:140
#, no-c-format
msgid ""
"<literal>default-lazy</literal> (optional - defaults to <literal>true</"
"literal>): The default value for unspecifed <literal>lazy</literal> "
"attributes of class and collection mappings."
msgstr ""
"<literal>default-lazy</literal> (オプション - デフォルトは <literal>true</"
"literal> )： <literal>lazy</literal> 属性が指定されていないクラスやコレクショ"
"ンマッピングに対するデフォルト値。"

#. Tag: para
#: basic_mapping.xml:147
#, no-c-format
msgid ""
"<literal>auto-import</literal> (optional - defaults to <literal>true</"
"literal>): Specifies whether we can use unqualified class names (of classes "
"in this mapping) in the query language."
msgstr ""
"<literal>auto-import</literal> （オプション - デフォルトは <literal>true</"
"literal>）： クエリ言語内で、（このマッピング内のクラスの）修飾されていないク"
"ラス名を使えるかどうかを指定します。"

#. Tag: para
#: basic_mapping.xml:154
#, no-c-format
msgid ""
"<literal>package</literal> (optional): Specifies a package prefix to assume "
"for unqualified class names in the mapping document."
msgstr ""
"<literal>package</literal> (オプション): マッピングドキュメント内で修飾されて"
"いないクラス名に対して割り当てる、 パッケージの接頭辞(prefix)を指定します。"

#. Tag: para
#: basic_mapping.xml:162
#, no-c-format
msgid ""
"If you have two persistent classes with the same (unqualified) name, you "
"should set <literal>auto-import=\"false\"</literal>. Hibernate will throw an "
"exception if you attempt to assign two classes to the same \"imported\" name."
msgstr ""
"（修飾されていない）同じ名前の永続クラスが2つあるなら、 <literal>auto-import="
"\"false\"</literal> を設定すべきです。 2つのクラスに”インポートされた”同じ名"
"前を割り当てようとすると、Hibernateは例外を投げます。"

#. Tag: para
#: basic_mapping.xml:168
#, no-c-format
msgid ""
"Note that the <literal>hibernate-mapping</literal> element allows you to "
"nest several persistent <literal>&lt;class&gt;</literal> mappings, as shown "
"above. It is however good practice (and expected by some tools) to map only "
"a single persistent class (or a single class hierarchy) in one mapping file "
"and name it after the persistent superclass, e.g. <literal>Cat.hbm.xml</"
"literal>, <literal>Dog.hbm.xml</literal>, or if using inheritance, "
"<literal>Animal.hbm.xml</literal>."
msgstr ""
"<literal>hibernate-mapping</literal> 要素は、最初の例で示したようにいくつかの"
"永続 <literal>&lt;class&gt;</literal> マッピングをネストできます。 しかし、１"
"つのマッピングファイルではただひとつの永続クラス(またはひとつのクラス階層)に"
"マッピングするようにし、 さらに永続スーパークラスの後で指定するべきでしょう"
"(いくつかのツールはこのようなマッピングファイルを想定しています)。 例えば次の"
"ようになります。： <literal>Cat.hbm.xml</literal> , <literal>Dog.hbm.xml</"
"literal> , または継承を使うなら <literal>Animal.hbm.xml</literal> 。"

#. Tag: title
#: basic_mapping.xml:181
#, no-c-format
msgid "<title>class</title>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:183
#, no-c-format
msgid ""
"You may declare a persistent class using the <literal>class</literal> "
"element:"
msgstr "<literal>class</literal> 要素を使って、永続クラスを宣言できます。"

#. Tag: programlisting
#: basic_mapping.xml:211
#, no-c-format
msgid ""
"<![CDATA[<class\n"
"        name=\"ClassName\"\n"
"        table=\"tableName\"\n"
"        discriminator-value=\"discriminator_value\"\n"
"        mutable=\"true|false\"\n"
"        schema=\"owner\"\n"
"        catalog=\"catalog\"\n"
"        proxy=\"ProxyInterface\"\n"
"        dynamic-update=\"true|false\"\n"
"        dynamic-insert=\"true|false\"\n"
"        select-before-update=\"true|false\"\n"
"        polymorphism=\"implicit|explicit\"\n"
"        where=\"arbitrary sql where condition\"\n"
"        persister=\"PersisterClass\"\n"
"        batch-size=\"N\"\n"
"        optimistic-lock=\"none|version|dirty|all\"\n"
"        lazy=\"true|false\"\n"
"        entity-name=\"EntityName\"\n"
"        check=\"arbitrary sql check condition\"\n"
"        rowid=\"rowid\"\n"
"        subselect=\"SQL expression\"\n"
"        abstract=\"true|false\"\n"
"        node=\"element-name\"\n"
"/>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:214
#, no-c-format
msgid ""
"<literal>name</literal> (optional): The fully qualified Java class name of "
"the persistent class (or interface). If this attribute is missing, it is "
"assumed that the mapping is for a non-POJO entity."
msgstr ""
"<literal>name</literal> (オプション)：永続クラス（またはインターフェイス）の"
"完全修飾Javaクラス名。 もしこの属性を指定しなければ、POJOではないエンティティ"
"に対するマッピングとして扱われます。"

#. Tag: para
#: basic_mapping.xml:221
#, no-c-format
msgid ""
"<literal>table</literal> (optional - defaults to the unqualified class "
"name): The name of its database table."
msgstr ""
"<literal>table</literal> (オプション - デフォルトは修飾されていないクラス"
"名)：データベーステーブルの名前"

#. Tag: para
#: basic_mapping.xml:227
#, no-c-format
msgid ""
"<literal>discriminator-value</literal> (optional - defaults to the class "
"name): A value that distiguishes individual subclasses, used for polymorphic "
"behaviour. Acceptable values include <literal>null</literal> and "
"<literal>not null</literal>."
msgstr ""
"<literal>discriminator-value</literal> (オプション - デフォルトはクラス名)： "
"ポリモーフィックな振る舞いに使われる個々のサブクラスを識別するための値。 値"
"は <literal>null</literal> か <literal>not null</literal> のいずれかを取りま"
"す。"

#. Tag: para
#: basic_mapping.xml:234
#, no-c-format
msgid ""
"<literal>mutable</literal> (optional, defaults to <literal>true</literal>): "
"Specifies that instances of the class are (not) mutable."
msgstr ""
"<literal>mutable</literal> (オプション、 デフォルトは <literal>true</"
"literal> )： そのクラスのインスタンスが更新可能（または不可能）であることを指"
"定します。"

#. Tag: para
#: basic_mapping.xml:240 basic_mapping.xml:2204
#, fuzzy, no-c-format
msgid ""
"<literal>schema</literal> (optional): Override the schema name specified by "
"the root <literal>&lt;hibernate-mapping&gt;</literal> element."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>schema</literal> （オプション）： ルートの <literal>&lt;hibernate-"
"mapping&gt;</literal> 要素で指定されたスキーマ名をオーバーライドします。\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>schema</literal> (オプション): ルートの <literal>&lt;hibernate-"
"mapping&gt;</literal> 要素で指定したスキーマ名を オーバーライドします。"

#. Tag: para
#: basic_mapping.xml:246 basic_mapping.xml:2210
#, fuzzy, no-c-format
msgid ""
"<literal>catalog</literal> (optional): Override the catalog name specified "
"by the root <literal>&lt;hibernate-mapping&gt;</literal> element."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>catalog</literal> （オプション）：ルートの <literal>&lt;hibernate-"
"mapping&gt;</literal> 要素で指定されたカタログ名をオーバーライドします。\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>catalog</literal> (オプション): ルートの <literal>&lt;hibernate-"
"mapping&gt;</literal> 要素で指定したカタログ名を オーバーライドします。"

#. Tag: para
#: basic_mapping.xml:252
#, no-c-format
msgid ""
"<literal>proxy</literal> (optional): Specifies an interface to use for lazy "
"initializing proxies. You may specify the name of the class itself."
msgstr ""
"<literal>proxy</literal> （オプション）：遅延初期化プロキシに使うインターフェ"
"イスを指定します。 永続化するクラス名そのものを指定することも可能です。"

#. Tag: para
#: basic_mapping.xml:258
#, no-c-format
msgid ""
"<literal>dynamic-update</literal> (optional, defaults to <literal>false</"
"literal>): Specifies that <literal>UPDATE</literal> SQL should be generated "
"at runtime and contain only those columns whose values have changed."
msgstr ""
"<literal>dynamic-update</literal> （オプション、 デフォルトは "
"<literal>false</literal> ）： 値が変更されたカラムだけを含むSQLの "
"<literal>UPDATE</literal> 文を、実行時に生成することを指定します。"

#. Tag: para
#: basic_mapping.xml:265
#, no-c-format
msgid ""
"<literal>dynamic-insert</literal> (optional, defaults to <literal>false</"
"literal>): Specifies that <literal>INSERT</literal> SQL should be generated "
"at runtime and contain only the columns whose values are not null."
msgstr ""
"<literal>dynamic-insert</literal> （オプション, デフォルトは <literal>false</"
"literal> ）： 値がnullではないカラムだけを含むSQLの <literal>INSERT</"
"literal> 文を、実行時に生成することを指定します。"

#. Tag: para
#: basic_mapping.xml:272
#, no-c-format
msgid ""
"<literal>select-before-update</literal> (optional, defaults to "
"<literal>false</literal>): Specifies that Hibernate should <emphasis>never</"
"emphasis> perform an SQL <literal>UPDATE</literal> unless it is certain that "
"an object is actually modified. In certain cases (actually, only when a "
"transient object has been associated with a new session using <literal>update"
"()</literal>), this means that Hibernate will perform an extra SQL "
"<literal>SELECT</literal> to determine if an <literal>UPDATE</literal> is "
"actually required."
msgstr ""
"<literal>select-before-update</literal> (オプション, デフォルトは "
"<literal>false</literal>): オブジェクトが変更されたのが確実でないならば、"
"HibernateがSQLの <literal>UPDATE</literal> を <emphasis>決して実行しない</"
"emphasis> ことを指定します。 ある特定の場合(実際的には、一時オブジェクトが "
"<literal>update()</literal> を使い、 新しいセッションと関連付けられた時だ"
"け)、<literal>UPDATE</literal> が実際に必要かどうかを決定するために、 "
"Hibernateが余分なSQLの <literal>SELECT</literal> 文を実行することを意味しま"
"す。"

#. Tag: para
#: basic_mapping.xml:282
#, no-c-format
msgid ""
"<literal>polymorphism</literal> (optional, defaults to <literal>implicit</"
"literal>): Determines whether implicit or explicit query polymorphism is "
"used."
msgstr ""
"(optional, デフォルトでは <literal>implicit</literal> ): implicit（暗黙）か"
"explicit（明示）の、 どちらのクエリポリモーフィズムを使うか決定します。"

#. Tag: para
#: basic_mapping.xml:288
#, no-c-format
msgid ""
"<literal>where</literal> (optional) specify an arbitrary SQL <literal>WHERE</"
"literal> condition to be used when retrieving objects of this class"
msgstr ""
"<literal>where</literal> （オプション）： このクラスのオブジェクトを検索する"
"ときに使用する、任意のSQLの <literal>WHERE</literal> 条件を指定します。"

#. Tag: para
#: basic_mapping.xml:294
#, no-c-format
msgid ""
"<literal>persister</literal> (optional): Specifies a custom "
"<literal>ClassPersister</literal>."
msgstr ""
"<literal>persister</literal> （オプション）：カスタム "
"<literal>ClassPersister</literal> を指定します。"

#. Tag: para
#: basic_mapping.xml:299
#, no-c-format
msgid ""
"<literal>batch-size</literal> (optional, defaults to <literal>1</literal>) "
"specify a \"batch size\" for fetching instances of this class by identifier."
msgstr ""
"<literal>batch-size</literal> （オプション, デフォルトは <literal>1</"
"literal> ）： 識別子でこのクラスのインスタンスを復元するときの「バッチサイ"
"ズ」を指定します。"

#. Tag: para
#: basic_mapping.xml:305
#, no-c-format
msgid ""
"<literal>optimistic-lock</literal> (optional, defaults to <literal>version</"
"literal>): Determines the optimistic locking strategy."
msgstr ""
"<literal>optimistic-lock</literal> （オプション,デフォルトは "
"<literal>version</literal> ）： 楽観ロック戦略を決定します。"

#. Tag: para
#: basic_mapping.xml:311
#, no-c-format
msgid ""
"<literal>lazy</literal> (optional): Lazy fetching may be completely disabled "
"by setting <literal>lazy=\"false\"</literal>."
msgstr ""
"<literal>lazy</literal> （オプション）： <literal>lazy=\"false\"</literal> と"
"設定することで、 遅延フェッチができなくなります。"

#. Tag: para
#: basic_mapping.xml:317
#, no-c-format
msgid ""
"<literal>entity-name</literal> (optional, defaults to the class name): "
"Hibernate3 allows a class to be mapped multiple times (to different tables, "
"potentially), and allows entity mappings that are represented by Maps or XML "
"at the Java level. In these cases, you should provide an explicit arbitrary "
"name for the entity. See <xref linkend=\"persistent-classes-dynamicmodels\"/"
"> and <xref linkend=\"xml\"/> for more information."
msgstr ""
"<literal>entity-name</literal> （オプション、デフォルトはクラス名）： "
"Hibernate3ではクラスが複数回マッピングでき（場合によっては違うテーブルに対し"
"ても）、 JavaレベルでMapやXMLで表現されるエンティティマッピングが可能です。 "
"これらの場合、エンティティに対して任意の名前を、明示的に付けなくてはなりませ"
"ん。 詳しくは <xref linkend=\"persistent-classes-dynamicmodels\"/> と <xref "
"linkend=\"xml\"/> を参照してください。"

#. Tag: para
#: basic_mapping.xml:327
#, no-c-format
msgid ""
"<literal>check</literal> (optional): A SQL expression used to generate a "
"multi-row <emphasis>check</emphasis> constraint for automatic schema "
"generation."
msgstr ""
"<literal>check</literal> （オプション）：自動的にスキーマを生成するために、 "
"複数行の <emphasis>check</emphasis> 制約を生成するSQL式。"

#. Tag: para
#: basic_mapping.xml:333
#, no-c-format
msgid ""
"<literal>rowid</literal> (optional): Hibernate can use so called ROWIDs on "
"databases which support. E.g. on Oracle, Hibernate can use the "
"<literal>rowid</literal> extra column for fast updates if you set this "
"option to <literal>rowid</literal>. A ROWID is an implementation detail and "
"represents the physical location of a stored tuple."
msgstr ""
"<literal>rowid</literal> （オプション）：Hibernateは、それをサポートしている"
"データベースでROWIDと 呼ばれるものを使うことができます。 例えばOracleを使って"
"いるとき、このオプションに <literal>rowid</literal> を設定すれば、 Hiberante"
"はupdateを高速化するために <literal>rowid</literal> という特別なカラムを使う"
"ことができます。 ROWIDは詳細な実装であり、保存されたタプルの物理的な位置を表"
"しています。"

#. Tag: para
#: basic_mapping.xml:341
#, no-c-format
msgid ""
"<literal>subselect</literal> (optional): Maps an immutable and read-only "
"entity to a database subselect. Useful if you want to have a view instead of "
"a base table, but don't. See below for more information."
msgstr ""
"<literal>subselect</literal> （オプション）：不変かつ読み取り専用であるエン"
"ティティを データベースの副問合せ（subselect）にマッピングします。 もし元の"
"テーブルの代わりにビューを持ちたければ有用ですが、 そうでないのなら有用ではあ"
"りません。より詳しい情報は下記を参照してください。"

#. Tag: para
#: basic_mapping.xml:348
#, no-c-format
msgid ""
"<literal>abstract</literal> (optional): Used to mark abstract superclasses "
"in <literal>&lt;union-subclass&gt;</literal> hierarchies."
msgstr ""
"<literal>abstract</literal> （オプション）： <literal>&lt;union-subclass&gt;"
"</literal> 階層内の抽象スーパークラスにマークするために使います。"

#. Tag: para
#: basic_mapping.xml:356
#, no-c-format
msgid ""
"It is perfectly acceptable for the named persistent class to be an "
"interface. You would then declare implementing classes of that interface "
"using the <literal>&lt;subclass&gt;</literal> element. You may persist any "
"<emphasis>static</emphasis> inner class. You should specify the class name "
"using the standard form ie. <literal>eg.Foo$Bar</literal>."
msgstr ""
"永続クラスの名前にインターフェイスを指定してもまったく問題ありません。 そのと"
"きは <literal>&lt;subclass&gt;</literal> 要素を使って、 そのインターフェイス"
"を実装するクラスを定義してください。 <emphasis>static</emphasis> な内部クラス"
"でも永続化できます。 そのときは標準形式、例えば <literal>eg.Foo$Bar</"
"literal> を使ってクラス名を指定してください。"

#. Tag: para
#: basic_mapping.xml:363
#, no-c-format
msgid ""
"Immutable classes, <literal>mutable=\"false\"</literal>, may not be updated "
"or deleted by the application. This allows Hibernate to make some minor "
"performance optimizations."
msgstr ""
"<literal>mutable=\"false\"</literal> 指定をした不変クラスは、 アプリケーショ"
"ンによる更新や削除が出来ないことがあります。 これにより、Hibernateがパフォー"
"マンスを少し改善します。"

#. Tag: para
#: basic_mapping.xml:368
#, no-c-format
msgid ""
"The optional <literal>proxy</literal> attribute enables lazy initialization "
"of persistent instances of the class. Hibernate will initially return CGLIB "
"proxies which implement the named interface. The actual persistent object "
"will be loaded when a method of the proxy is invoked. See \"Initializing "
"collections and proxies\" below."
msgstr ""
"オプションの <literal>proxy</literal> 属性により、クラスの永続インスタンスの"
"遅延初期化が可能になります。 Hibernateは最初に、指定したインターフェイスを実"
"装したCGLIBプロキシを返します。 実際の永続オブジェクトはプロキシのメソッドを"
"呼び出すときにロードします。 以下の「遅延初期化のためのプロキシ」を参照してく"
"ださい。"

#. Tag: para
#: basic_mapping.xml:375
#, no-c-format
msgid ""
"<emphasis>Implicit</emphasis> polymorphism means that instances of the class "
"will be returned by a query that names any superclass or implemented "
"interface or the class and that instances of any subclass of the class will "
"be returned by a query that names the class itself. <emphasis>Explicit</"
"emphasis> polymorphism means that class instances will be returned only by "
"queries that explicitly name that class and that queries that name the class "
"will return only instances of subclasses mapped inside this <literal>&lt;"
"class&gt;</literal> declaration as a <literal>&lt;subclass&gt;</literal> or "
"<literal>&lt;joined-subclass&gt;</literal>. For most purposes the default, "
"<literal>polymorphism=\"implicit\"</literal>, is appropriate. Explicit "
"polymorphism is useful when two different classes are mapped to the same "
"table (this allows a \"lightweight\" class that contains a subset of the "
"table columns)."
msgstr ""
"<emphasis>暗黙的</emphasis> ポリモーフィズムとは、次の二つを意味しています。 "
"一つはクラスのインスタンスが、スーパークラスや実装したインターフェイス、また"
"そのクラスを指定するクエリによって返されることで、 もう一つはそのクラスのサブ"
"クラスのインスタンスが、そのクラス自身を指定したクエリによって返されることで"
"す。 また、<emphasis>明示的</emphasis> ポリモーフィズムとは、次の二つを意味し"
"ています。 一つはクラスのインスタンスが、そのクラスを明示的に指定したクエリに"
"よってのみ返されることで、 もう一つはクラスを指定したクエリが、<literal>&lt;"
"class&gt;</literal> 要素の中で <literal>&lt;subclass&gt;</literal> や "
"<literal>&lt;joined-subclass&gt;</literal> とマッピングされているサブクラスの"
"インスタンスだけを返すことです。 ほとんどの用途ではデフォルトの "
"<literal>polymorphism=\"implicit\"</literal> が適切です。 明示的なポリモー"
"フィズムは、2つの違ったクラスが同じテーブルにマッピングされているときに有用で"
"す （これによってテーブルカラムのサブセットを含む、「軽量な」クラスが可能にな"
"ります）。"

#. Tag: para
#: basic_mapping.xml:387
#, no-c-format
msgid ""
"The <literal>persister</literal> attribute lets you customize the "
"persistence strategy used for the class. You may, for example, specify your "
"own subclass of <literal>org.hibernate.persister.EntityPersister</literal> "
"or you might even provide a completely new implementation of the interface "
"<literal>org.hibernate.persister.ClassPersister</literal> that implements "
"persistence via, for example, stored procedure calls, serialization to flat "
"files or LDAP. See <literal>org.hibernate.test.CustomPersister</literal> for "
"a simple example (of \"persistence\" to a <literal>Hashtable</literal>)."
msgstr ""
"<literal>persister</literal> 属性を指定することで、クラスの永続化戦略をカスタ"
"マイズできます。 例えば <literal>org.hibernate.persister.EntityPersister</"
"literal> 自身のサブクラスを指定したり、 また例えばストアドプロシージャコー"
"ル、フラットファイルへシリアライズ、 LDAPなどを通した永続性を実装する "
"<literal>org.hibernate.persister.ClassPersister</literal> インターフェイスの"
"完全に新しい実装を提供できます。簡単な例として <literal>org.hibernate.test."
"CustomPersister</literal> を見てください（これは <literal>Hashtable</"
"literal> の「永続化」です）。"

#. Tag: para
#: basic_mapping.xml:398
#, no-c-format
msgid ""
"Note that the <literal>dynamic-update</literal> and <literal>dynamic-insert</"
"literal> settings are not inherited by subclasses and so may also be "
"specified on the <literal>&lt;subclass&gt;</literal> or <literal>&lt;joined-"
"subclass&gt;</literal> elements. These settings may increase performance in "
"some cases, but might actually decrease performance in others. Use "
"judiciously."
msgstr ""
"<literal>dynamic-update</literal> と <literal>dynamic-insert</literal> の設定"
"はサブクラスに継承されません。 そのため <literal>&lt;subclass&gt;</literal> "
"や <literal>&lt;joined-subclass&gt;</literal> 要素を指定することも出来ます。 "
"これらの設定はパフォーマンスを向上させる事もありますが、落とすこともあります"
"ので、慎重に使用してください。"

#. Tag: para
#: basic_mapping.xml:406
#, no-c-format
msgid ""
"Use of <literal>select-before-update</literal> will usually decrease "
"performance. It is very useful to prevent a database update trigger being "
"called unnecessarily if you reattach a graph of detached instances to a "
"<literal>Session</literal>."
msgstr ""
"<literal>select-before-update</literal> の使用は通常パフォーマンスを落としま"
"す。 もし <literal>Session</literal> へ分離インスタンスのグラフを再追加するな"
"ら、 データベース更新のトリガを不必要に呼び出すのを避けるという点で、非常に有"
"用です。"

#. Tag: para
#: basic_mapping.xml:412
#, no-c-format
msgid ""
"If you enable <literal>dynamic-update</literal>, you will have a choice of "
"optimistic locking strategies:"
msgstr ""
"<literal>dynamic-update</literal> を有効にすれば、楽観ロック戦略を選ぶことに"
"なります。"

#. Tag: para
#: basic_mapping.xml:418
#, no-c-format
msgid "<literal>version</literal> check the version/timestamp columns"
msgstr ""
"<literal>version</literal> バージョン/タイムスタンプカラムをチェックします"

#. Tag: para
#: basic_mapping.xml:423
#, no-c-format
msgid "<literal>all</literal> check all columns"
msgstr "<literal>all</literal> すべてのカラムをチェックします。"

#. Tag: para
#: basic_mapping.xml:428
#, no-c-format
msgid ""
"<literal>dirty</literal> check the changed columns, allowing some concurrent "
"updates"
msgstr ""
"<literal>dirty</literal> 変更したカラムをチェックし、同時更新できるようにしま"
"す。"

#. Tag: para
#: basic_mapping.xml:433
#, no-c-format
msgid "<literal>none</literal> do not use optimistic locking"
msgstr "<literal>none</literal> 楽観ロックを使用しません"

#. Tag: para
#: basic_mapping.xml:438
#, no-c-format
msgid ""
"We <emphasis>very</emphasis> strongly recommend that you use version/"
"timestamp columns for optimistic locking with Hibernate. This is the optimal "
"strategy with respect to performance and is the only strategy that correctly "
"handles modifications made to detached instances (ie. when <literal>Session."
"merge()</literal> is used)."
msgstr ""
"Hibernateで楽観的ロック戦略を使うなら、バージョン/タイムスタンプカラムを使う"
"ことを <emphasis> 非常に</emphasis> 強くお勧めします。 楽観的ロックはパフォー"
"マンスの観点からも最適であり、さらに分離インスタンスへの修正 （つまり "
"<literal>Session.marge()</literal> が使われるとき） を正確に扱うことのできる"
"唯一の戦略でもあります。"

#. Tag: para
#: basic_mapping.xml:445
#, no-c-format
msgid ""
"There is no difference between a view and a base table for a Hibernate "
"mapping, as expected this is transparent at the database level (note that "
"some DBMS don't support views properly, especially with updates). Sometimes "
"you want to use a view, but can't create one in the database (ie. with a "
"legacy schema). In this case, you can map an immutable and read-only entity "
"to a given SQL subselect expression:"
msgstr ""
"Hibernateのマッピングにとってビューと普通のテーブルの間に違いはなく、 データ"
"ベースレベルでは透過的です （ただしビューを完全にはサポートしていないDBMSもあ"
"ります。 特に、更新のあるビューに対してはそうです）。 ビューを使いたくても、"
"データベースで作成できないことがあります （例えば、レガシースキーマの場"
"合）。 この場合には、不変かつ読み取り専用のエンティティに与えられたSQLの副問"
"合せ文をマップできます。"

#. Tag: programlisting
#: basic_mapping.xml:453
#, no-c-format
msgid ""
"<![CDATA[<class name=\"Summary\">\n"
"    <subselect>\n"
"        select item.name, max(bid.amount), count(*)\n"
"        from item\n"
"        join bid on bid.item_id = item.id\n"
"        group by item.name\n"
"    </subselect>\n"
"    <synchronize table=\"item\"/>\n"
"    <synchronize table=\"bid\"/>\n"
"    <id name=\"name\"/>\n"
"    ...\n"
"</class>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:455
#, no-c-format
msgid ""
"Declare the tables to synchronize this entity with, ensuring that auto-flush "
"happens correctly, and that queries against the derived entity do not return "
"stale data. The <literal>&lt;subselect&gt;</literal> is available as both as "
"an attribute and a nested mapping element."
msgstr ""
"テーブルをこのエンティティと同期するように定義してください。 オートフラッシュ"
"が確実に起こるように、また導出エンティティに対するクエリが古いデータを 返さな"
"いようにするためです。 <literal>&lt;subselect&gt;</literal> は属性とネストし"
"たマッピング属性のどちらでも利用できます。"

#. Tag: title
#: basic_mapping.xml:465
#, no-c-format
msgid "<title>id</title>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:467
#, no-c-format
msgid ""
"Mapped classes <emphasis>must</emphasis> declare the primary key column of "
"the database table. Most classes will also have a JavaBeans-style property "
"holding the unique identifier of an instance. The <literal>&lt;id&gt;</"
"literal> element defines the mapping from that property to the primary key "
"column."
msgstr ""
"マップされたクラスはデータベーステーブルの主キーカラムを定義 <emphasis>しなけ"
"ればなりません</emphasis> 。 ほとんどのクラスにはインスタンスのユニークな識別"
"子を保持するJavaBeansスタイルのプロパティもあります。 <literal>&lt;id&gt;</"
"literal> 要素は、そのプロパティから主キーカラムへのマッピングを定義します。"

#. Tag: programlisting
#: basic_mapping.xml:482
#, no-c-format
msgid ""
"<![CDATA[<id\n"
"        name=\"propertyName\"\n"
"        type=\"typename\"\n"
"        column=\"column_name\"\n"
"        unsaved-value=\"null|any|none|undefined|id_value\"\n"
"        access=\"field|property|ClassName\">\n"
"        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
"\n"
"        <generator class=\"generatorClass\"/>\n"
"</id>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:485
#, no-c-format
msgid ""
"<literal>name</literal> (optional): The name of the identifier property."
msgstr "<literal>name</literal>（オプション）：識別子プロパティの名前。"

#. Tag: para
#: basic_mapping.xml:490
#, no-c-format
msgid ""
"<literal>type</literal> (optional): A name that indicates the Hibernate type."
msgstr "<literal>type</literal>（オプション）：Hibernateの型を示す名前。"

#. Tag: para
#: basic_mapping.xml:495
#, no-c-format
msgid ""
"<literal>column</literal> (optional - defaults to the property name): The "
"name of the primary key column."
msgstr ""
"<literal>column</literal>（オプション - デフォルトはプロパティ名）： 主キーカ"
"ラムの名前。"

#. Tag: para
#: basic_mapping.xml:501
#, no-c-format
msgid ""
"<literal>unsaved-value</literal> (optional - defaults to a \"sensible\" "
"value): An identifier property value that indicates that an instance is "
"newly instantiated (unsaved), distinguishing it from detached instances that "
"were saved or loaded in a previous session."
msgstr ""
"<literal>unsaved-value</literal>（オプション - デフォルトの値はsensible）： "
"インスタンスが新しくインスタンス化された （セーブされていない）ことを示す、識"
"別子プロパティの値。 以前のSessionでセーブまたはロードされた一時的インスタン"
"スと区別するために 使います。"

#. Tag: para
#: basic_mapping.xml:509 basic_mapping.xml:1017 basic_mapping.xml:1156
#: basic_mapping.xml:1238 basic_mapping.xml:1345 basic_mapping.xml:1534
#: basic_mapping.xml:1708 basic_mapping.xml:1878 basic_mapping.xml:2457
#, fuzzy, no-c-format
msgid ""
"<literal>access</literal> (optional - defaults to <literal>property</"
"literal>): The strategy Hibernate should use for accessing the property "
"value."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal>（オプション - デフォルトは <literal>property</"
"literal> ）： プロパティの値へアクセスするためにHibernateが使う戦略です。\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> (オプション - デフォルトは <literal>property</"
"literal> ): Hibernateがプロパティの値にアクセスするために使用すべき戦略。\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> （オプション - デフォルトは <literal>property</"
"literal> ）： プロパティの値へのアクセスにHibernateが使う戦略。\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> （オプション - デフォルトは <literal>property</"
"literal> ）： プロパティの値へのアクセスにHibernateが使う戦略。\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal>（オプション - デフォルトは <literal>property</"
"literal> ）： プロパティの値へのアクセスにHibernateが使う戦略。\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal>（オプション - デフォルトは <literal>property</"
"literal> ）： プロパティの値へのアクセスにHibernateが使う戦略。\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal>（オプション - デフォルトは <literal>property</"
"literal> ）： プロパティの値へのアクセスにHibernateが使う戦略。\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal> （オプション - デフォルトは <literal>property</"
"literal> ）： プロパティの値へのアクセスにHibernateが使う戦略。\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>access</literal>（オプション - デフォルトは <literal>property</"
"literal> ）： プロパティの値へのアクセスにHibernateが使う戦略。"

#. Tag: para
#: basic_mapping.xml:517
#, no-c-format
msgid ""
"If the <literal>name</literal> attribute is missing, it is assumed that the "
"class has no identifier property."
msgstr ""
"<literal>name</literal> 属性がなければ、クラスには識別子プロパティがないもの"
"とみなされます。"

#. Tag: para
#: basic_mapping.xml:522
#, no-c-format
msgid ""
"The <literal>unsaved-value</literal> attribute is almost never needed in "
"Hibernate3."
msgstr ""
"<literal>unsaved-value</literal> 属性はHibernate3ではほとんどの場合、必要では"
"ありません。"

#. Tag: para
#: basic_mapping.xml:526
#, no-c-format
msgid ""
"There is an alternative <literal>&lt;composite-id&gt;</literal> declaration "
"to allow access to legacy data with composite keys. We strongly discourage "
"its use for anything else."
msgstr ""
"複合キーを持つレガシーデータにアクセスできるように、 <literal>&lt;composite-"
"id&gt;</literal> という代替のマッピング定義があります。 しかし他の用途への使"
"用は全くおすすめできません。"

#. Tag: title
#: basic_mapping.xml:532
#, no-c-format
msgid "Generator"
msgstr "ジェネレータ"

#. Tag: para
#: basic_mapping.xml:534
#, no-c-format
msgid ""
"The optional <literal>&lt;generator&gt;</literal> child element names a Java "
"class used to generate unique identifiers for instances of the persistent "
"class. If any parameters are required to configure or initialize the "
"generator instance, they are passed using the <literal>&lt;param&gt;</"
"literal> element."
msgstr ""
"オプションの <literal>&lt;generator&gt;</literal> 子要素は、 永続クラスのイン"
"スタンスのユニークな識別子を生成するために使う、Javaクラスを指定します。 ジェ"
"ネレータインスタンスの設定、もしくは初期化にパラメータが必要であれば、"
"<literal>&lt;param&gt;</literal> 要素を使って渡すことができます。"

#. Tag: programlisting
#: basic_mapping.xml:541
#, no-c-format
msgid ""
"<![CDATA[<id name=\"id\" type=\"long\" column=\"cat_id\">\n"
"        <generator class=\"org.hibernate.id.TableHiLoGenerator\">\n"
"                <param name=\"table\">uid_table</param>\n"
"                <param name=\"column\">next_hi_value_column</param>\n"
"        </generator>\n"
"</id>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:543
#, fuzzy, no-c-format
msgid ""
"All generators implement the interface <literal>org.hibernate.id."
"IdentifierGenerator</literal>. This is a very simple interface; some "
"applications may choose to provide their own specialized implementations. "
"However, Hibernate provides a range of built-in implementations. There are "
"shortcut names for the built-in generators:"
msgstr ""
"すべてのジェネレータは、インターフェイス <literal>org.hibernate.id."
"IdentifierGenerator</literal> を実装します。 これはとても単純なインターフェイ"
"スなので、特別な実装を独自に用意するアプリケーションもあるかもしれません。 し"
"かしHibernateは組み込みの実装をいくつも用意しています。 組み込みのジェネレー"
"タには以下のショートカット名があります： <placeholder-1/>"

#. Tag: literal
#: basic_mapping.xml:551
#, no-c-format
msgid "increment"
msgstr "increment"

#. Tag: para
#: basic_mapping.xml:553
#, no-c-format
msgid ""
"generates identifiers of type <literal>long</literal>, <literal>short</"
"literal> or <literal>int</literal> that are unique only when no other "
"process is inserting data into the same table. <emphasis>Do not use in a "
"cluster.</emphasis>"
msgstr ""
"<literal>long</literal> , <literal>short</literal> , <literal>int</literal> "
"型の識別子を生成します。 これらは他のプロセスが同じテーブルにデータを挿入しな"
"いときだけユニークです。 <emphasis>クラスタ内では使わないでください</"
"emphasis> 。"

#. Tag: literal
#: basic_mapping.xml:562
#, no-c-format
msgid "identity"
msgstr "identity"

#. Tag: para
#: basic_mapping.xml:564
#, no-c-format
msgid ""
"supports identity columns in DB2, MySQL, MS SQL Server, Sybase and "
"HypersonicSQL. The returned identifier is of type <literal>long</literal>, "
"<literal>short</literal> or <literal>int</literal>."
msgstr ""
"DB2, MySQL, MS SQL Server, Sybase, HypersonicSQLの識別子カラムを サポートしま"
"す。 返される識別子の型は <literal>long</literal> , <literal>short</"
"literal> , <literal>int</literal> のいずれかです。"

#. Tag: literal
#: basic_mapping.xml:572
#, no-c-format
msgid "sequence"
msgstr "sequence"

#. Tag: para
#: basic_mapping.xml:574
#, no-c-format
msgid ""
"uses a sequence in DB2, PostgreSQL, Oracle, SAP DB, McKoi or a generator in "
"Interbase. The returned identifier is of type <literal>long</literal>, "
"<literal>short</literal> or <literal>int</literal>"
msgstr ""
"DB2, PostgreSQL, Oracle, SAP DB, McKoiのシーケンスや、Interbaseのジェネレータ"
"を使用します。 返される識別子の型は <literal>long</literal> , "
"<literal>short</literal> , <literal>int</literal> のいずれかです。"

#. Tag: literal
#: basic_mapping.xml:582
#, no-c-format
msgid "hilo"
msgstr "hilo"

#. Tag: para
#: basic_mapping.xml:584
#, no-c-format
msgid ""
"uses a hi/lo algorithm to efficiently generate identifiers of type "
"<literal>long</literal>, <literal>short</literal> or <literal>int</literal>, "
"given a table and column (by default <literal>hibernate_unique_key</literal> "
"and <literal>next_hi</literal> respectively) as a source of hi values. The "
"hi/lo algorithm generates identifiers that are unique only for a particular "
"database."
msgstr ""
"<literal>long</literal> , <literal>short</literal> , <literal>int</literal> "
"型の識別子を効率的に生成するhi/loアルゴリズムを使います。 hi値のソースとし"
"て、テーブルとカラムを与えます(デフォルトではそれぞれ "
"<literal>hibernate_unique_key</literal> と <literal>next_hi</literal> )。 hi/"
"loアルゴリズムは特定のデータベースに対してのみユニークな識別子を生成します。"

#. Tag: literal
#: basic_mapping.xml:594
#, no-c-format
msgid "seqhilo"
msgstr "seqhilo"

#. Tag: para
#: basic_mapping.xml:596
#, no-c-format
msgid ""
"uses a hi/lo algorithm to efficiently generate identifiers of type "
"<literal>long</literal>, <literal>short</literal> or <literal>int</literal>, "
"given a named database sequence."
msgstr ""
"<literal>long</literal> , <literal>short</literal> , <literal>int</literal> "
"型の識別子を効率的に生成するhi/loアルゴリズムを使います。 指定されたデータ"
"ベースシーケンスを与えます。"

#. Tag: literal
#: basic_mapping.xml:604
#, no-c-format
msgid "uuid"
msgstr "uuid"

#. Tag: para
#: basic_mapping.xml:606
#, no-c-format
msgid ""
"uses a 128-bit UUID algorithm to generate identifiers of type string, unique "
"within a network (the IP address is used). The UUID is encoded as a string "
"of hexadecimal digits of length 32."
msgstr ""
"(IPアドレスが使用される)ネットワーク内でユニークな文字列型の識別子を生成する"
"ために、 128ビットのUUIDアルゴリズムを使用します。UUIDは長さ32の16進数字の文"
"字列としてエンコードされます。"

#. Tag: literal
#: basic_mapping.xml:614
#, no-c-format
msgid "guid"
msgstr "guid"

#. Tag: para
#: basic_mapping.xml:616
#, no-c-format
msgid "uses a database-generated GUID string on MS SQL Server and MySQL."
msgstr "MS SQLサーバとMySQLでデータベースが生成するGUID文字列を使用します。"

#. Tag: literal
#: basic_mapping.xml:622
#, no-c-format
msgid "native"
msgstr "native"

#. Tag: para
#: basic_mapping.xml:624
#, no-c-format
msgid ""
"picks <literal>identity</literal>, <literal>sequence</literal> or "
"<literal>hilo</literal> depending upon the capabilities of the underlying "
"database."
msgstr ""
"使用するデータベースの性能により <literal>identity</literal> , "
"<literal>sequence</literal> , <literal>hilo</literal> のいずれかが選ばれま"
"す。"

#. Tag: literal
#: basic_mapping.xml:632
#, no-c-format
msgid "assigned"
msgstr "assigned"

#. Tag: para
#: basic_mapping.xml:634
#, no-c-format
msgid ""
"lets the application to assign an identifier to the object before "
"<literal>save()</literal> is called. This is the default strategy if no "
"<literal>&lt;generator&gt;</literal> element is specified."
msgstr ""
"<literal>save()</literal> が呼ばれる前に、 アプリケーションがオブジェクトに識"
"別子を代入できるようにします。 <literal>&lt;generator&gt;</literal> が指定さ"
"れていなければ、これがデフォルトの戦略になります。"

#. Tag: literal
#: basic_mapping.xml:642
#, no-c-format
msgid "select"
msgstr "select"

#. Tag: para
#: basic_mapping.xml:644
#, no-c-format
msgid ""
"retrieves a primary key assigned by a database trigger by selecting the row "
"by some unique key and retrieving the primary key value."
msgstr ""
"あるユニークキーによる行の選択と主キーの値の復元により、 データベーストリガが"
"割り当てた主キーを取得します。"

#. Tag: literal
#: basic_mapping.xml:651
#, no-c-format
msgid "foreign"
msgstr "foreign"

#. Tag: para
#: basic_mapping.xml:653
#, no-c-format
msgid ""
"uses the identifier of another associated object. Usually used in "
"conjunction with a <literal>&lt;one-to-one&gt;</literal> primary key "
"association."
msgstr ""
"他の関連オブジェクトの識別子を使います。 普通は、<literal>&lt;one-to-one&gt;"
"</literal> 主キー関連と組み合わせて使います。"

#. Tag: literal
#: basic_mapping.xml:660
#, no-c-format
msgid "sequence-identity"
msgstr "sequence-identity"

#. Tag: para
#: basic_mapping.xml:662
#, no-c-format
msgid ""
"a specialized sequence generation strategy which utilizes a database "
"sequence for the actual value generation, but combines this with JDBC3 "
"getGeneratedKeys to actually return the generated identifier value as part "
"of the insert statement execution. This strategy is only known to be "
"supported on Oracle 10g drivers targetted for JDK 1.4. Note comments on "
"these insert statements are disabled due to a bug in the Oracle drivers."
msgstr ""
"a specialized sequence generation strategy which utilizes a database "
"sequence for the actual value generation, but combines this with JDBC3 "
"getGeneratedKeys to actually return the generated identifier value as part "
"of the insert statement execution. This strategy is only known to be "
"supported on Oracle 10g drivers targetted for JDK 1.4. Note comments on "
"these insert statements are disabled due to a bug in the Oracle drivers."

#. Tag: title
#: basic_mapping.xml:679
#, no-c-format
msgid "Hi/lo algorithm"
msgstr "Hi/lo アルゴリズム"

#. Tag: para
#: basic_mapping.xml:680
#, no-c-format
msgid ""
"The <literal>hilo</literal> and <literal>seqhilo</literal> generators "
"provide two alternate implementations of the hi/lo algorithm, a favorite "
"approach to identifier generation. The first implementation requires a "
"\"special\" database table to hold the next available \"hi\" value. The "
"second uses an Oracle-style sequence (where supported)."
msgstr ""
"<literal>hilo</literal> と <literal>seqhilo</literal> ジェネレータは、 識別子"
"生成の代表的なアプローチであるhi/loアルゴリズムの2つの代替実装を提供します。 "
"1番目の実装は、次回に利用される\"hi\"値を保持する「特別な」データベーステーブ"
"ルを 必要とします。 2番目の実装は、Oracleスタイルのシーケンスを使います（サ"
"ポートされている場合）。"

#. Tag: programlisting
#: basic_mapping.xml:687
#, no-c-format
msgid ""
"<![CDATA[<id name=\"id\" type=\"long\" column=\"cat_id\">\n"
"        <generator class=\"hilo\">\n"
"                <param name=\"table\">hi_value</param>\n"
"                <param name=\"column\">next_value</param>\n"
"                <param name=\"max_lo\">100</param>\n"
"        </generator>\n"
"</id>]]>"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:689
#, no-c-format
msgid ""
"<![CDATA[<id name=\"id\" type=\"long\" column=\"cat_id\">\n"
"        <generator class=\"seqhilo\">\n"
"                <param name=\"sequence\">hi_value</param>\n"
"                <param name=\"max_lo\">100</param>\n"
"        </generator>\n"
"</id>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:691
#, no-c-format
msgid ""
"Unfortunately, you can't use <literal>hilo</literal> when supplying your own "
"<literal>Connection</literal> to Hibernate. When Hibernate is using an "
"application server datasource to obtain connections enlisted with JTA, you "
"must properly configure the <literal>hibernate.transaction."
"manager_lookup_class</literal>."
msgstr ""
"残念ながらHibernateへの独自の <literal>Connection</literal> を提供するときに"
"は、<literal>hilo</literal> を使えません。 HibernateがJTAでリストされている接"
"続を取得するためにアプリケーションサーバーのデータソースを使用しているときに"
"は、 <literal>hibernate.transaction.manager_lookup_class</literal> を適切に設"
"定しなければなりません。"

#. Tag: title
#: basic_mapping.xml:700
#, no-c-format
msgid "UUID algorithm"
msgstr "UUID アルゴリズム"

#. Tag: para
#: basic_mapping.xml:701
#, no-c-format
msgid ""
"The UUID contains: IP address, startup time of the JVM (accurate to a "
"quarter second), system time and a counter value (unique within the JVM). "
"It's not possible to obtain a MAC address or memory address from Java code, "
"so this is the best we can do without using JNI."
msgstr ""
"UUIDには以下のものが含まれます： IPアドレス、JVMのスタートアップタイム（4分の"
"1秒の正確さ）、 システム時間、（JVMに対してユニークな）カウンタ値。 Javaコー"
"ドからMACアドレスやメモリアドレスを取得することはできないので、 JNIが使えない"
"ときの最良の方法です。"

#. Tag: title
#: basic_mapping.xml:710
#, no-c-format
msgid "Identity columns and sequences"
msgstr "識別子カラムとシーケンス"

#. Tag: para
#: basic_mapping.xml:711
#, no-c-format
msgid ""
"For databases which support identity columns (DB2, MySQL, Sybase, MS SQL), "
"you may use <literal>identity</literal> key generation. For databases that "
"support sequences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) you "
"may use <literal>sequence</literal> style key generation. Both these "
"strategies require two SQL queries to insert a new object."
msgstr ""
"識別子カラムをサポートしているデータベース（DB2, MySQL, Sybase, MS SQL）で"
"は、 <literal>identity</literal> キー生成を使えます。 シーケンスをサポートす"
"るデータベース（DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB）では、 "
"<literal>sequence</literal> スタイルのキー生成を使えます。 どちらの戦略も、新"
"しいオブジェクトを挿入するために、SQLクエリを2つ必要とします。"

#. Tag: programlisting
#: basic_mapping.xml:719
#, no-c-format
msgid ""
"<![CDATA[<id name=\"id\" type=\"long\" column=\"person_id\">\n"
"        <generator class=\"sequence\">\n"
"                <param name=\"sequence\">person_id_sequence</param>\n"
"        </generator>\n"
"</id>]]>"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:721
#, no-c-format
msgid ""
"<![CDATA[<id name=\"id\" type=\"long\" column=\"person_id\" unsaved-value=\"0"
"\">\n"
"        <generator class=\"identity\"/>\n"
"</id>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:723
#, no-c-format
msgid ""
"For cross-platform development, the <literal>native</literal> strategy will "
"choose from the <literal>identity</literal>, <literal>sequence</literal> and "
"<literal>hilo</literal> strategies, dependant upon the capabilities of the "
"underlying database."
msgstr ""
"クロスプラットフォームの開発では、<literal>native</literal> 戦略は "
"<literal>identity</literal> , <literal>sequence</literal> , <literal>hilo</"
"literal> 戦略の中から1つを選択しますが、 これは使用しているデータベースの能力"
"に依存します。"

#. Tag: title
#: basic_mapping.xml:732
#, no-c-format
msgid "Assigned identifiers"
msgstr "識別子の割り当て"

#. Tag: para
#: basic_mapping.xml:733
#, no-c-format
msgid ""
"If you want the application to assign identifiers (as opposed to having "
"Hibernate generate them), you may use the <literal>assigned</literal> "
"generator. This special generator will use the identifier value already "
"assigned to the object's identifier property. This generator is used when "
"the primary key is a natural key instead of a surrogate key. This is the "
"default behavior if you do no specify a <literal>&lt;generator&gt;</literal> "
"element."
msgstr ""
"アプリケーションに識別子を割り当てさせたいのであれば(Hibernateが生成するもの"
"ではなく）、 <literal>assigned</literal> ジェネレータを使うことができます。 "
"この特別なジェネレータは、すでにオブジェクトの識別子プロパティに代入された値"
"を 識別子に使います。このジェネレータは主キーが代理キーの代わりに自然キーであ"
"る場合に使用します。 <literal>&lt;generator&gt;</literal> 要素を指定しない場"
"合のデフォルトの動作になります。"

#. Tag: para
#: basic_mapping.xml:742
#, no-c-format
msgid ""
"Choosing the <literal>assigned</literal> generator makes Hibernate use "
"<literal>unsaved-value=\"undefined\"</literal>, forcing Hibernate to go to "
"the database to determine if an instance is transient or detached, unless "
"there is a version or timestamp property, or you define <literal>Interceptor."
"isUnsaved()</literal>."
msgstr ""
"<literal>assigned</literal> ジェネレータを選択すると、 Hibernateは "
"<literal>unsaved-value=\"undefined\"</literal> を使用します。 そして、バー"
"ジョンやタイムスタンプのプロパティがない場合や <literal>Interceptor.isUnsaved"
"()</literal> を定義しなかった場合には、インスタンスが一時的(transient)なもの"
"であるのか、 またはセッションから分離(detached)したものかどうかを決めるため"
"に、データベースを調べます。"

#. Tag: title
#: basic_mapping.xml:752
#, no-c-format
msgid "Primary keys assigned by triggers"
msgstr "トリガにより割り当てられた主キー"

#. Tag: para
#: basic_mapping.xml:753
#, no-c-format
msgid ""
"For legacy schemas only (Hibernate does not generate DDL with triggers)."
msgstr ""
"レガシースキーマのためにのみ指定します(Hibernateはトリガを使ってDDLを生成しま"
"せん)。"

#. Tag: programlisting
#: basic_mapping.xml:757
#, no-c-format
msgid ""
"<![CDATA[<id name=\"id\" type=\"long\" column=\"person_id\">\n"
"        <generator class=\"select\">\n"
"                <param name=\"key\">socialSecurityNumber</param>\n"
"        </generator>\n"
"</id>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:759
#, no-c-format
msgid ""
"In the above example, there is a unique valued property named "
"<literal>socialSecurityNumber</literal> defined by the class, as a natural "
"key, and a surrogate key named <literal>person_id</literal> whose value is "
"generated by a trigger."
msgstr ""
"上の例の中で、クラスで自然キーとして定義された "
"<literal>socialSecurityNumber</literal> という名前のユニークな値のプロパティ"
"と、 値がトリガにより生成される <literal>person_id</literal> という名前の代理"
"キーがあります。"

#. Tag: title
#: basic_mapping.xml:771
#, no-c-format
msgid "Enhanced identifier generators"
msgstr "Enhanced identifier generators"

#. Tag: para
#: basic_mapping.xml:773
#, no-c-format
msgid ""
"Starting with release 3.2.3, there are 2 new generators which represent a re-"
"thinking of 2 different aspects of identifier generation. The first aspect "
"is database portability; the second is optimization (not having to query the "
"database for every request for a new identifier value). These two new "
"generators are intended to take the place of some of the named generators "
"described above (starting in 3.3.x); however, they are included in the "
"current releases and can be referenced by FQN."
msgstr ""
"Starting with release 3.2.3, there are 2 new generators which represent a re-"
"thinking of 2 different aspects of identifier generation. The first aspect "
"is database portability; the second is optimization (not having to query the "
"database for every request for a new identifier value). These two new "
"generators are intended to take the place of some of the named generators "
"described above (starting in 3.3.x); however, they are included in the "
"current releases and can be referenced by FQN."

#. Tag: para
#: basic_mapping.xml:781
#, fuzzy, no-c-format
msgid ""
"The first of these new generators is <literal>org.hibernate.id.enhanced."
"SequenceStyleGenerator</literal> which is intended firstly as a replacement "
"for the <literal>sequence</literal> generator and secondly as a better "
"portability generator than <literal>native</literal> (because "
"<literal>native</literal> (generally) chooses between <literal>identity</"
"literal> and <literal>sequence</literal> which have largely different "
"semantics which can cause subtle isssues in applications eyeing "
"portability). <literal>org.hibernate.id.enhanced.SequenceStyleGenerator</"
"literal> however achieves portability in a different manner. It chooses "
"between using a table or a sequence in the database to store its "
"incrementing values depending on the capabilities of the dialect being used. "
"The difference between this and <literal>native</literal> is that table-"
"based and sequence-based storage have the same exact semantic (in fact "
"sequences are exactly what Hibernate tries to emmulate with its table-based "
"generators). This generator has a number of configuration parameters:"
msgstr ""
"The first of these new generators is <literal>org.hibernate.id.enhanced."
"SequenceStyleGenerator</literal> which is intended firstly as a replacement "
"for the <literal>sequence</literal> generator and secondly as a better "
"portability generator than <literal>native</literal> (because "
"<literal>native</literal> (generally) chooses between <literal>identity</"
"literal> and <literal>sequence</literal> which have largely different "
"semantics which can cause subtle isssues in applications eyeing "
"portability). <literal>org.hibernate.id.enhanced.SequenceStyleGenerator</"
"literal> however achieves portability in a different manner. It chooses "
"between using a table or a sequence in the database to store its "
"incrementing values depending on the capabilities of the dialect being used. "
"The difference between this and <literal>native</literal> is that table-"
"based and sequence-based storage have the same exact semantic (in fact "
"sequences are exactly what Hibernate tries to emmulate with its table-based "
"generators). This generator has a number of configuration parameters: "
"<placeholder-1/>"

#. Tag: para
#: basic_mapping.xml:795
#, no-c-format
msgid ""
"<literal>sequence_name</literal> (optional, defaults to "
"<literal>hibernate_sequence</literal>): The name of the sequence (or table) "
"to be used."
msgstr ""
"<literal>sequence_name</literal> (optional, defaults to "
"<literal>hibernate_sequence</literal>): The name of the sequence (or table) "
"to be used."

#. Tag: para
#: basic_mapping.xml:801
#, no-c-format
msgid ""
"<literal>initial_value</literal> (optional, defaults to <literal>1</"
"literal>): The initial value to be retrieved from the sequence/table. In "
"sequence creation terms, this is analogous to the clause typical named "
"\"STARTS WITH\"."
msgstr ""
"<literal>initial_value</literal> (optional, defaults to <literal>1</"
"literal>): The initial value to be retrieved from the sequence/table. In "
"sequence creation terms, this is analogous to the clause typical named "
"\"STARTS WITH\"."

#. Tag: para
#: basic_mapping.xml:808
#, no-c-format
msgid ""
"<literal>increment_size</literal> (optional, defaults to <literal>1</"
"literal>): The value by which subsequent calls to the sequence/table should "
"differ. In sequence creation terms, this is analogous to the clause typical "
"named \"INCREMENT BY\"."
msgstr ""
"<literal>increment_size</literal> (optional, defaults to <literal>1</"
"literal>): The value by which subsequent calls to the sequence/table should "
"differ. In sequence creation terms, this is analogous to the clause typical "
"named \"INCREMENT BY\"."

#. Tag: para
#: basic_mapping.xml:815
#, no-c-format
msgid ""
"<literal>force_table_use</literal> (optional, defaults to <literal>false</"
"literal>): Should we force the use of a table as the backing structure even "
"though the dialect might support sequence?"
msgstr ""
"<literal>force_table_use</literal> (optional, defaults to <literal>false</"
"literal>): Should we force the use of a table as the backing structure even "
"though the dialect might support sequence?"

#. Tag: para
#: basic_mapping.xml:822
#, no-c-format
msgid ""
"<literal>value_column</literal> (optional, defaults to <literal>next_val</"
"literal>): Only relevant for table structures! The name of the column on the "
"table which is used to hold the value."
msgstr ""
"<literal>value_column</literal> (optional, defaults to <literal>next_val</"
"literal>): Only relevant for table structures! The name of the column on the "
"table which is used to hold the value."

#. Tag: para
#: basic_mapping.xml:829
#, fuzzy, no-c-format
msgid ""
"<literal>optimizer</literal> (optional, defaults to <literal>none</"
"literal>): See"
msgstr ""
"<literal>cascade</literal>（オプション - デフォルトは <literal>none</"
"literal> ）： カスケードのスタイル。"

#. Tag: para
#: basic_mapping.xml:836
#, fuzzy, no-c-format
msgid ""
"The second of these new generators is <literal>org.hibernate.id.enhanced."
"TableGenerator</literal> which is intended firstly as a replacement for the "
"<literal>table</literal> generator (although it actually functions much more "
"like <literal>org.hibernate.id.MultipleHiLoPerTableGenerator</literal>) and "
"secondly as a re-implementation of <literal>org.hibernate.id."
"MultipleHiLoPerTableGenerator</literal> utilizing the notion of pluggable "
"optimiziers. Essentially this generator defines a table capable of holding a "
"number of different increment values simultaneously by using multiple "
"distinctly keyed rows. This generator has a number of configuration "
"parameters:"
msgstr ""
"The second of these new generators is <literal>org.hibernate.id.enhanced."
"TableGenerator</literal> which is intended firstly as a replacement for the "
"<literal>table</literal> generator (although it actually functions much more "
"like <literal>org.hibernate.id.MultipleHiLoPerTableGenerator</literal>) and "
"secondly as a re-implementation of <literal>org.hibernate.id."
"MultipleHiLoPerTableGenerator</literal> utilizing the notion of pluggable "
"optimiziers. Essentially this generator defines a table capable of holding a "
"number of different increment values simultaneously by using multiple "
"distinctly keyed rows. This generator has a number of configuration "
"parameters: <placeholder-1/>"

#. Tag: para
#: basic_mapping.xml:846
#, no-c-format
msgid ""
"<literal>table_name</literal> (optional, defaults to "
"<literal>hibernate_sequences</literal>): The name of the table to be used."
msgstr ""
"<literal>table_name</literal> (optional, defaults to "
"<literal>hibernate_sequences</literal>): The name of the table to be used."

#. Tag: para
#: basic_mapping.xml:852
#, no-c-format
msgid ""
"<literal>value_column_name</literal> (optional, defaults to "
"<literal>next_val</literal>): The name of the column on the table which is "
"used to hold the value."
msgstr ""
"<literal>value_column_name</literal> (optional, defaults to "
"<literal>next_val</literal>): The name of the column on the table which is "
"used to hold the value."

#. Tag: para
#: basic_mapping.xml:858
#, no-c-format
msgid ""
"<literal>segment_column_name</literal> (optional, defaults to "
"<literal>sequence_name</literal>): The name of the column on the table which "
"is used to hold the \"segement key\". This is the value which distinctly "
"identifies which increment value to use."
msgstr ""
"<literal>segment_column_name</literal> (optional, defaults to "
"<literal>sequence_name</literal>): The name of the column on the table which "
"is used to hold the \"segement key\". This is the value which distinctly "
"identifies which increment value to use."

#. Tag: para
#: basic_mapping.xml:865
#, no-c-format
msgid ""
"<literal>segment_value</literal> (optional, defaults to <literal>default</"
"literal>): The \"segment key\" value for the segment from which we want to "
"pull increment values for this generator."
msgstr ""
"<literal>segment_value</literal> (optional, defaults to <literal>default</"
"literal>): The \"segment key\" value for the segment from which we want to "
"pull increment values for this generator."

#. Tag: para
#: basic_mapping.xml:872
#, no-c-format
msgid ""
"<literal>segment_value_length</literal> (optional, defaults to <literal>255</"
"literal>): Used for schema generation; the column size to create this "
"segment key column."
msgstr ""
"<literal>segment_value_length</literal> (optional, defaults to <literal>255</"
"literal>): Used for schema generation; the column size to create this "
"segment key column."

#. Tag: para
#: basic_mapping.xml:878
#, no-c-format
msgid ""
"<literal>initial_value</literal> (optional, defaults to <literal>1</"
"literal>): The initial value to be retrieved from the table."
msgstr ""
"<literal>initial_value</literal> (optional, defaults to <literal>1</"
"literal>): The initial value to be retrieved from the table."

#. Tag: para
#: basic_mapping.xml:884
#, no-c-format
msgid ""
"<literal>increment_size</literal> (optional, defaults to <literal>1</"
"literal>): The value by which subsequent calls to the table should differ."
msgstr ""
"<literal>increment_size</literal> (optional, defaults to <literal>1</"
"literal>): The value by which subsequent calls to the table should differ."

#. Tag: para
#: basic_mapping.xml:890
#, fuzzy, no-c-format
msgid ""
"<literal>optimizer</literal> (optional, defaults to <literal></literal>): See"
msgstr ""
"<literal>cascade</literal>（オプション - デフォルトは <literal>none</"
"literal> ）： カスケードのスタイル。"

#. Tag: title
#: basic_mapping.xml:900
#, no-c-format
msgid "Identifier generator optimization"
msgstr "Identifier generator optimization"

#. Tag: para
#: basic_mapping.xml:901
#, fuzzy, no-c-format
msgid ""
"For identifier generators which store values in the database, it is "
"inefficient for them to hit the database on each and every call to generate "
"a new identifier value. Instead, you'd ideally want to group a bunch of them "
"in memory and only hit the database when you have exhausted your in-memory "
"value group. This is the role of the pluggable optimizers. Currently only "
"the two enhanced generators (<xref linkend=\"mapping-declaration-id-enhanced"
"\"/> support this notion."
msgstr ""
"For identifier generators which store values in the database, it is "
"inefficient for them to hit the database on each and every call to generate "
"a new identifier value. Instead, you'd ideally want to group a bunch of them "
"in memory and only hit the database when you have exhausted your in-memory "
"value group. This is the role of the pluggable optimizers. Currently only "
"the two enhanced generators (<xref linkend=\"mapping-declaration-id-enhanced"
"\"/> support this notion. <placeholder-1/>"

#. Tag: para
#: basic_mapping.xml:909
#, no-c-format
msgid ""
"<literal>none</literal> (generally this is the default if no optimizer was "
"specified): This says to not perform any optimizations, and hit the database "
"each and every request."
msgstr ""
"<literal>none</literal> (generally this is the default if no optimizer was "
"specified): This says to not perform any optimizations, and hit the database "
"each and every request."

#. Tag: para
#: basic_mapping.xml:915
#, no-c-format
msgid ""
"<literal>hilo</literal>: applies a hi/lo algorithm around the database "
"retrieved values. The values from the database for this optimizer are "
"expected to be sequential. The values retrieved from the database structure "
"for this optimizer indicates the \"group number\"; the "
"<literal>increment_size</literal> is multiplied by that value in memory to "
"define a group \"hi value\"."
msgstr ""
"<literal>hilo</literal>: applies a hi/lo algorithm around the database "
"retrieved values. The values from the database for this optimizer are "
"expected to be sequential. The values retrieved from the database structure "
"for this optimizer indicates the \"group number\"; the "
"<literal>increment_size</literal> is multiplied by that value in memory to "
"define a group \"hi value\"."

#. Tag: para
#: basic_mapping.xml:924
#, no-c-format
msgid ""
"<literal>pooled</literal>: like was discussed for <literal>hilo</literal>, "
"this optimizers attempts to minimize the number of hits to the database. "
"Here, however, we simply store the starting value for the \"next group\" "
"into the database structure rather than a sequential value in combination "
"with an in-memory grouping algorithm. <literal>increment_size</literal> here "
"refers to the values coming from the database."
msgstr ""
"<literal>pooled</literal>: like was discussed for <literal>hilo</literal>, "
"this optimizers attempts to minimize the number of hits to the database. "
"Here, however, we simply store the starting value for the \"next group\" "
"into the database structure rather than a sequential value in combination "
"with an in-memory grouping algorithm. <literal>increment_size</literal> here "
"refers to the values coming from the database."

#. Tag: title
#: basic_mapping.xml:937
#, no-c-format
msgid "composite-id"
msgstr "composite-id"

#. Tag: programlisting
#: basic_mapping.xml:939
#, no-c-format
msgid ""
"<![CDATA[<composite-id\n"
"        name=\"propertyName\"\n"
"        class=\"ClassName\"\n"
"        mapped=\"true|false\"\n"
"        access=\"field|property|ClassName\">\n"
"        node=\"element-name|.\"\n"
"\n"
"        <key-property name=\"propertyName\" type=\"typename\" column="
"\"column_name\"/>\n"
"        <key-many-to-one name=\"propertyName class=\"ClassName\" column="
"\"column_name\"/>\n"
"        ......\n"
"</composite-id>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:941
#, no-c-format
msgid ""
"For a table with a composite key, you may map multiple properties of the "
"class as identifier properties. The <literal>&lt;composite-id&gt;</literal> "
"element accepts <literal>&lt;key-property&gt;</literal> property mappings "
"and <literal>&lt;key-many-to-one&gt;</literal> mappings as child elements."
msgstr ""
"複合キーのあるテーブルに対し、 識別子プロパティとしてクラスの複数のプロパティ"
"をマッピングすることができます。 <literal>&lt;composite-id&gt;</literal> 要素"
"は、子要素として <literal>&lt;key-property&gt;</literal> プロパティマッピング"
"と <literal>&lt;key-many-to-one&gt;</literal> マッピングを受け入れます。"

#. Tag: programlisting
#: basic_mapping.xml:948
#, no-c-format
msgid ""
"<![CDATA[<composite-id>\n"
"        <key-property name=\"medicareNumber\"/>\n"
"        <key-property name=\"dependent\"/>\n"
"</composite-id>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:950
#, no-c-format
msgid ""
"Your persistent class <emphasis>must</emphasis> override <literal>equals()</"
"literal> and <literal>hashCode()</literal> to implement composite identifier "
"equality. It must also implements <literal>Serializable</literal>."
msgstr ""
"複合識別子の等価性を実装するためには、永続クラスが <literal>equals()</"
"literal> と <literal>hashCode()</literal> をオーバーライド <emphasis>しなけれ"
"ばなりません</emphasis> 。 また <literal>Serializable</literal> も実装しなけ"
"ればいけません。"

#. Tag: para
#: basic_mapping.xml:956
#, no-c-format
msgid ""
"Unfortunately, this approach to composite identifiers means that a "
"persistent object is its own identifier. There is no convenient \"handle\" "
"other than the object itself. You must instantiate an instance of the "
"persistent class itself and populate its identifier properties before you "
"can <literal>load()</literal> the persistent state associated with a "
"composite key. We call this approach an <emphasis>embedded</emphasis> "
"composite identifier, and discourage it for serious applications."
msgstr ""
"残念ながら複合識別子のためのこの方法は、 永続オブジェクトが自身の識別子である"
"ことを意味しています。 オブジェクト自身を識別子とする以上の便利な「扱い方」は"
"ありません。 複合キーに関連した永続状態を <literal>load()</literal> 出来るよ"
"うになる前に、 永続クラス自身をインスタンス化し、識別子プロパティを設定しなけ"
"ればなりません。 <emphasis> 組み込みの</emphasis> 複合識別子と呼ばれるこのア"
"プローチは、 本格的なアプリケーションには向いていません。"

#. Tag: para
#: basic_mapping.xml:965
#, no-c-format
msgid ""
"A second approach is what we call a <emphasis>mapped</emphasis> composite "
"identifier, where the identifier properties named inside the <literal>&lt;"
"composite-id&gt;</literal> element are duplicated on both the persistent "
"class and a separate identifier class."
msgstr ""
"2つ目の方法は <emphasis> マップされた</emphasis> 複合識別子と呼ばれるもの"
"で、 <literal>&lt;composite-id&gt;</literal>エレメント内で指定した識別プロパ"
"ティが 永続クラスと分離した識別子クラスの両方に重複して存在します。"

#. Tag: programlisting
#: basic_mapping.xml:971
#, no-c-format
msgid ""
"<![CDATA[<composite-id class=\"MedicareId\" mapped=\"true\">\n"
"        <key-property name=\"medicareNumber\"/>\n"
"        <key-property name=\"dependent\"/>\n"
"</composite-id>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:973
#, no-c-format
msgid ""
"In this example, both the composite identifier class, <literal>MedicareId</"
"literal>, and the entity class itself have properties named "
"<literal>medicareNumber</literal> and <literal>dependent</literal>. The "
"identifier class must override <literal>equals()</literal> and "
"<literal>hashCode()</literal> and implement. <literal>Serializable</"
"literal>. The disadvantage of this approach is quite obvious&mdash;code "
"duplication."
msgstr ""
"この例では、複合識別子クラス（ <literal>MedicareId</literal> ）とエンティティ"
"クラス自身の両方が、 <literal>medicareNumber</literal> と "
"<literal>dependent</literal> という名前のプロパティを持ちます。 識別子クラス"
"は、<literal>equals()</literal> と <literal>hashCode()</literal> をオーバライ"
"ドし、 <literal>Serializable</literal> を実装しなくてはなりません。 この方法"
"には、明らかにコードが重複するという不都合があります。"

#. Tag: para
#: basic_mapping.xml:982
#, no-c-format
msgid ""
"The following attributes are used to specify a mapped composite identifier:"
msgstr "次の属性はマッピングした複合識別子を指定するために使用します。"

#. Tag: para
#: basic_mapping.xml:988
#, no-c-format
msgid ""
"<literal>mapped</literal> (optional, defaults to <literal>false</literal>): "
"indicates that a mapped composite identifier is used, and that the contained "
"property mappings refer to both the entity class and the composite "
"identifier class."
msgstr ""
"<literal>mapped</literal> (オプション、デフォルトは <literal>false</"
"literal> ): マッピングした複合識別子が使用されることと、包含されたプロパティ"
"のマッピングが、 エンティティクラスと複合識別子クラスの両方を参照することを示"
"します。"

#. Tag: para
#: basic_mapping.xml:996
#, no-c-format
msgid ""
"<literal>class</literal> (optional, but required for a mapped composite "
"identifier): The class used as a composite identifier."
msgstr ""
"<literal>class</literal> (オプション,ただしマッピングした複合識別子には必"
"須): 複合識別子として使用するクラス。"

#. Tag: para
#: basic_mapping.xml:1003
#, no-c-format
msgid ""
"We will describe a third, even more convenient approach where the composite "
"identifier is implemented as a component class in <xref linkend=\"components-"
"compositeid\"/>. The attributes described below apply only to this "
"alternative approach:"
msgstr ""
"3つ目のさらに便利な方法は、複合識別子を<xref linkend=\"components-compositeid"
"\"/>内の コンポーネントクラスとして実装することです。 下で記述している属性"
"は、この代替方法にのみ適用されます。"

#. Tag: para
#: basic_mapping.xml:1011
#, no-c-format
msgid ""
"<literal>name</literal> (optional, required for this approach): A property "
"of component type that holds the composite identifier (see chapter 9)."
msgstr ""
"<literal>name</literal> (オプション, このアプローチでは必須): 複合識別子を保"
"持するコンポーネントタイプのプロパティ(9章を参照してください)."

#. Tag: para
#: basic_mapping.xml:1023
#, no-c-format
msgid ""
"<literal>class</literal> (optional - defaults to the property type "
"determined by reflection): The component class used as a composite "
"identifier (see next section)."
msgstr ""
"<literal>class</literal> （オプション - デフォルトはリフレクションにより決定"
"されるプロパティの型）： 複合識別子として使われるコンポーネントのクラス（次の"
"節を見てください）。"

#. Tag: para
#: basic_mapping.xml:1030
#, no-c-format
msgid ""
"This third approach, an <emphasis>identifier component</emphasis> is the one "
"we recommend for almost all applications."
msgstr ""
"この3つ目の方法は <emphasis> 識別子コンポーネント</emphasis> と呼び、 ほとん"
"どすべてのアプリケーションに対して推奨する方法です。"

#. Tag: title
#: basic_mapping.xml:1038
#, no-c-format
msgid "discriminator"
msgstr "discriminator"

#. Tag: para
#: basic_mapping.xml:1040
#, no-c-format
msgid ""
"The <literal>&lt;discriminator&gt;</literal> element is required for "
"polymorphic persistence using the table-per-class-hierarchy mapping strategy "
"and declares a discriminator column of the table. The discriminator column "
"contains marker values that tell the persistence layer what subclass to "
"instantiate for a particular row. A restricted set of types may be used: "
"<literal>string</literal>, <literal>character</literal>, <literal>integer</"
"literal>, <literal>byte</literal>, <literal>short</literal>, "
"<literal>boolean</literal>, <literal>yes_no</literal>, <literal>true_false</"
"literal>."
msgstr ""
"<literal>&lt;discriminator&gt;</literal> 要素は、 table-per-class-hierarchy"
"マッピング戦略を使うポリモーフィックな永続化に必要であり、 テーブルの識別カラ"
"ムを定義します。 識別カラムは、ある行に対して永続層がどのサブクラスをインスタ"
"ンス化するかを 伝えるマーカー値を含んでいます。 以下のような型に制限されま"
"す： <literal>string</literal> , <literal>character</literal> , "
"<literal>integer</literal>, <literal>byte</literal> , <literal>short</"
"literal> , <literal>boolean</literal> , <literal>yes_no</literal> , "
"<literal>true_false</literal>."

#. Tag: programlisting
#: basic_mapping.xml:1058
#, no-c-format
msgid ""
"<![CDATA[<discriminator\n"
"        column=\"discriminator_column\"\n"
"        type=\"discriminator_type\"\n"
"        force=\"true|false\"\n"
"        insert=\"true|false\"\n"
"        formula=\"arbitrary sql expression\"\n"
"/>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1061
#, no-c-format
msgid ""
"<literal>column</literal> (optional - defaults to <literal>class</literal>) "
"the name of the discriminator column."
msgstr ""
"<literal>column</literal>（オプション - デフォルトは <literal>class</"
"literal> ）： 識別カラムの名前。"

#. Tag: para
#: basic_mapping.xml:1067
#, no-c-format
msgid ""
"<literal>type</literal> (optional - defaults to <literal>string</literal>) a "
"name that indicates the Hibernate type"
msgstr ""
"<literal>type</literal> （オプション - デフォルトは <literal>string</"
"literal> ）：Hibernateの型を示す名前。"

#. Tag: para
#: basic_mapping.xml:1073
#, no-c-format
msgid ""
"<literal>force</literal> (optional - defaults to <literal>false</literal>) "
"\"force\" Hibernate to specify allowed discriminator values even when "
"retrieving all instances of the root class."
msgstr ""
"<literal>force</literal> （オプション - デフォルトは <literal>false</"
"literal> ）： ルートクラスのすべてのインスタンスを検索する場合であっても、 "
"Hibernateが使用できる識別カラムの指定を「強制」します。"

#. Tag: para
#: basic_mapping.xml:1080
#, no-c-format
msgid ""
"<literal>insert</literal> (optional - defaults to <literal>true</literal>) "
"set this to <literal>false</literal> if your discriminator column is also "
"part of a mapped composite identifier. (Tells Hibernate to not include the "
"column in SQL <literal>INSERT</literal>s.)"
msgstr ""
"<literal>insert</literal> （オプション - デフォルトは <literal>true</"
"literal> ）： もし識別カラムがマッピングする複合識別子の一部ならば、"
"<literal>false</literal> と設定してください。 (HibernateにSQLの "
"<literal>INSERT</literal> には含まれないことを知らせる)"

#. Tag: para
#: basic_mapping.xml:1088
#, no-c-format
msgid ""
"<literal>formula</literal> (optional) an arbitrary SQL expression that is "
"executed when a type has to be evaluated. Allows content-based "
"discrimination."
msgstr ""
"<literal>formula</literal> (オプション)型が評価されるときに実行される任意の"
"SQL式。 コンテンツベースの識別を可能にします。"

#. Tag: para
#: basic_mapping.xml:1096
#, no-c-format
msgid ""
"Actual values of the discriminator column are specified by the "
"<literal>discriminator-value</literal> attribute of the <literal>&lt;"
"class&gt;</literal> and <literal>&lt;subclass&gt;</literal> elements."
msgstr ""
"識別カラムの実際の値は、 <literal>&lt;class&gt;</literal> と <literal>&lt;"
"subclass&gt;</literal> 要素の <literal>discriminator-value</literal> 属性で指"
"定されます。"

#. Tag: para
#: basic_mapping.xml:1102
#, no-c-format
msgid ""
"The <literal>force</literal> attribute is (only) useful if the table "
"contains rows with \"extra\" discriminator values that are not mapped to a "
"persistent class. This will not usually be the case."
msgstr ""
"永続クラスへマッピングされない｢余分な」識別値を持つ行が テーブルにあれば、"
"（そのときに限り）<literal>force</literal> 属性は有効です。 ただし、普通はそ"
"ういうことはありません。"

#. Tag: para
#: basic_mapping.xml:1108
#, no-c-format
msgid ""
"Using the <literal>formula</literal> attribute you can declare an arbitrary "
"SQL expression that will be used to evaluate the type of a row:"
msgstr ""
"<literal>formula</literal> 属性を使うと、行の型を評価するために任意のSQL式を"
"宣言できます。"

#. Tag: programlisting
#: basic_mapping.xml:1113
#, no-c-format
msgid ""
"<![CDATA[<discriminator\n"
"    formula=\"case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end\"\n"
"    type=\"integer\"/>]]>"
msgstr ""

#. Tag: title
#: basic_mapping.xml:1118
#, no-c-format
msgid "version (optional)"
msgstr "version（オプション）"

#. Tag: para
#: basic_mapping.xml:1120
#, no-c-format
msgid ""
"The <literal>&lt;version&gt;</literal> element is optional and indicates "
"that the table contains versioned data. This is particularly useful if you "
"plan to use <emphasis>long transactions</emphasis> (see below)."
msgstr ""
"<literal>&lt;version&gt;</literal> 要素はオプションであり、 テーブルがバー"
"ジョンデータを含むことを示します。 これは <emphasis>ロングトランザクション</"
"emphasis> を使うつもりなら、特に役立ちます（以下を見てください）。"

#. Tag: programlisting
#: basic_mapping.xml:1136
#, no-c-format
msgid ""
"<![CDATA[<version\n"
"        column=\"version_column\"\n"
"        name=\"propertyName\"\n"
"        type=\"typename\"\n"
"        access=\"field|property|ClassName\"\n"
"        unsaved-value=\"null|negative|undefined\"\n"
"        generated=\"never|always\"\n"
"        insert=\"true|false\"\n"
"        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
"/>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1139
#, no-c-format
msgid ""
"<literal>column</literal> (optional - defaults to the property name): The "
"name of the column holding the version number."
msgstr ""
"<literal>column</literal>（オプション - デフォルトはプロパティ名）: バージョ"
"ン番号を保持するカラムの名前。"

#. Tag: para
#: basic_mapping.xml:1145
#, no-c-format
msgid ""
"<literal>name</literal>: The name of a property of the persistent class."
msgstr "<literal>name</literal> ：永続クラスのプロパティの名前。"

#. Tag: para
#: basic_mapping.xml:1150
#, no-c-format
msgid ""
"<literal>type</literal> (optional - defaults to <literal>integer</literal>): "
"The type of the version number."
msgstr ""
"<literal>type</literal> （オプション - デフォルトは <literal>integer</"
"literal> ）：バージョン番号の型。"

#. Tag: para
#: basic_mapping.xml:1162
#, no-c-format
msgid ""
"<literal>unsaved-value</literal> (optional - defaults to <literal>undefined</"
"literal>): A version property value that indicates that an instance is newly "
"instantiated (unsaved), distinguishing it from detached instances that were "
"saved or loaded in a previous session. (<literal>undefined</literal> "
"specifies that the identifier property value should be used.)"
msgstr ""
"<literal>unsaved-value</literal> （オプション - デフォルトは "
"<literal>undefined</literal> ）： インスタンスが新しくインスタンス化されたこ"
"とを示す （セーブされていないことを示す）バージョンプロパティの値。 以前の"
"Sessionでセーブまたはロードされた一時的なインスタンスと区別するために 使いま"
"す。 （ <literal>undefined</literal> は識別子プロパティの値が使われることを指"
"定します。）"

#. Tag: para
#: basic_mapping.xml:1171
#, no-c-format
msgid ""
"<literal>generated</literal> (optional - defaults to <literal>never</"
"literal>): Specifies that this version property value is actually generated "
"by the database. See the discussion of <link linkend=\"mapping-generated"
"\">generated properties</link>."
msgstr ""
"<literal>generated</literal> (オプション - デフォルトは <literal>never</"
"literal> ): このバージョンのプロパティの値が、データベースによって生成された"
"ことを指定します。 <xref linkend=\"mapping-generated\">生成プロパティ</xref> "
"の議論を見てください。"

#. Tag: para
#: basic_mapping.xml:1178
#, no-c-format
msgid ""
"<literal>insert</literal> (optional - defaults to <literal>true</literal>): "
"Specifies whether the version column should be included in SQL insert "
"statements. May be set to <literal>false</literal> if and only if the "
"database column is defined with a default value of <literal>0</literal>."
msgstr ""
"<literal>insert</literal> (オプション - デフォルトは <literal>true</"
"literal> ): SQLのinsert文にバージョン・カラムを含めるべきかどうかを指定しま"
"す。 もしデータベース・カラムのデフォルト値が <literal>0</literal> と定義され"
"るときには、 <literal>false</literal> に設定すると良いでしょう。"

#. Tag: para
#: basic_mapping.xml:1188
#, no-c-format
msgid ""
"Version numbers may be of Hibernate type <literal>long</literal>, "
"<literal>integer</literal>, <literal>short</literal>, <literal>timestamp</"
"literal> or <literal>calendar</literal>."
msgstr ""
"バージョン番号は Hibernateの <literal>long</literal> , <literal>integer</"
"literal> , <literal>short</literal> , <literal>timestamp</literal> , "
"<literal>calendar</literal> 型のいずれかです。"

#. Tag: para
#: basic_mapping.xml:1193
#, no-c-format
msgid ""
"A version or timestamp property should never be null for a detached "
"instance, so Hibernate will detect any instance with a null version or "
"timestamp as transient, no matter what other <literal>unsaved-value</"
"literal> strategies are specified. <emphasis>Declaring a nullable version or "
"timestamp property is an easy way to avoid any problems with transitive "
"reattachment in Hibernate, especially useful for people using assigned "
"identifiers or composite keys!</emphasis>"
msgstr ""
"バージョンやタイムスタンプのプロパティは、分離されたインスタンスに対してnull"
"であってはなりません。 そのためどのような <literal>unsaved-value</literal> 戦"
"略が指定されても、 Hibernateはnullのバージョンやタイムスタンプを持ったすべて"
"のインスタンスを、 一時的なものであると判断します。 <emphasis> nullを許容する"
"バージョンやタイムスタンプのプロパティを定義することは、 過渡的に一時オブジェ"
"クトとすることを防ぐ簡単な方法です。 特に識別子の割り当てや複合キーを使用して"
"いるときには特に有用です。</emphasis>"

#. Tag: title
#: basic_mapping.xml:1204
#, no-c-format
msgid "timestamp (optional)"
msgstr "timestamp（オプション）"

#. Tag: para
#: basic_mapping.xml:1206
#, no-c-format
msgid ""
"The optional <literal>&lt;timestamp&gt;</literal> element indicates that the "
"table contains timestamped data. This is intended as an alternative to "
"versioning. Timestamps are by nature a less safe implementation of "
"optimistic locking. However, sometimes the application might use the "
"timestamps in other ways."
msgstr ""
"オプションの <literal>&lt;timestamp&gt;</literal> 要素は、 テーブルがタイムス"
"タンプデータを含むことを示します。 これはバージョン付けの代わりの方法として用"
"意されています。 タイムスタンプはもともと楽観的ロックにおける安全性の低い実装"
"です。 しかしアプリケーションは異なる用途で使うこともあるかもしれません。"

#. Tag: programlisting
#: basic_mapping.xml:1222
#, no-c-format
msgid ""
"<![CDATA[<timestamp\n"
"        column=\"timestamp_column\"\n"
"        name=\"propertyName\"\n"
"        access=\"field|property|ClassName\"\n"
"        unsaved-value=\"null|undefined\"\n"
"        source=\"vm|db\"\n"
"        generated=\"never|always\"\n"
"        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
"/>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1225
#, no-c-format
msgid ""
"<literal>column</literal> (optional - defaults to the property name): The "
"name of a column holding the timestamp."
msgstr ""
"<literal>column</literal>（オプション - デフォルトはプロパティ名）： タイムス"
"タンプを保持するカラムの名前。"

#. Tag: para
#: basic_mapping.xml:1231
#, no-c-format
msgid ""
"<literal>name</literal>: The name of a JavaBeans style property of Java type "
"<literal>Date</literal> or <literal>Timestamp</literal> of the persistent "
"class."
msgstr ""
"<literal>name</literal> ： 永続クラスであるJava の <literal>Date</literal>型 "
"または <literal>Timestamp</literal> 型 の、JavaBeansスタイルプロパティの名"
"前。"

#. Tag: para
#: basic_mapping.xml:1244
#, no-c-format
msgid ""
"<literal>unsaved-value</literal> (optional - defaults to <literal>null</"
"literal>): A version property value that indicates that an instance is newly "
"instantiated (unsaved), distinguishing it from detached instances that were "
"saved or loaded in a previous session. (<literal>undefined</literal> "
"specifies that the identifier property value should be used.)"
msgstr ""
"<literal>unsaved-value</literal> （オプション - デフォルトは <literal>null</"
"literal> ）： インスタンスが新しくインスタンス化された （セーブされていない）"
"ことを示すバージョンプロパティの値。 以前のSessionでセーブまたはロードされた"
"一時的なインスタンスと 区別するために使われます。 （ <literal>undefined</"
"literal> と指定すると、 識別子プロパティの値が使われます。）"

#. Tag: para
#: basic_mapping.xml:1253
#, no-c-format
msgid ""
"<literal>source</literal> (optional - defaults to <literal>vm</literal>): "
"From where should Hibernate retrieve the timestamp value? From the database, "
"or from the current JVM? Database-based timestamps incur an overhead because "
"Hibernate must hit the database in order to determine the \"next value\", "
"but will be safer for use in clustered environments. Note also, that not all "
"<literal>Dialect</literal>s are known to support retrieving of the "
"database's current timestamp, while others might be unsafe for usage in "
"locking due to lack of precision (Oracle 8 for example)."
msgstr ""
"<literal>source</literal> (オプション - デフォルトは <literal>vm</"
"literal> ): Hibernateはどこからタイムスタンプの値を取得するべきでしょうか？ "
"データベースからでしょうか、現在のJVMからでしょうか？ データベースによるタイ"
"ムスタンプは、Hibernateが\"次の値\"を決定するために データベースをヒットしな"
"ければならないため、オーバヘッドを招きます。 しかしクラスタ環境ではJVMから取"
"得するより安全です。 データベースの現在のタイムスタンプの取得をサポートする "
"すべての <literal>データベース方言</literal> が知られているわけではないこと"
"に 注意してください。また一方で、精密さを欠くために、 ロックで使用するには安"
"全でないものもあります(例えばOracle 8)。"

#. Tag: para
#: basic_mapping.xml:1265
#, no-c-format
msgid ""
"<literal>generated</literal> (optional - defaults to <literal>never</"
"literal>): Specifies that this timestamp property value is actually "
"generated by the database. See the discussion of <link linkend=\"mapping-"
"generated\">generated properties</link>."
msgstr ""
"<literal>generated</literal> (オプション - デフォルトは <literal>never</"
"literal> ): このタイムスタンプ・プロパティの値が、データベースによって生成さ"
"れることを指定します。 <xref linkend=\"mapping-generated\">生成プロパティ</"
"xref> を参照してください。"

#. Tag: para
#: basic_mapping.xml:1274
#, no-c-format
msgid ""
"Note that <literal>&lt;timestamp&gt;</literal> is equivalent to <literal>&lt;"
"version type=\"timestamp\"&gt;</literal>. And <literal>&lt;timestamp source="
"\"db\"&gt;</literal> is equivalent to <literal>&lt;version type=\"dbtimestamp"
"\"&gt;</literal>"
msgstr ""
"<literal>&lt;timestamp&gt;</literal> は <literal>&lt;version type=\"timestamp"
"\"&gt;</literal> と等価であることに注意してください。 <literal>&lt;timestamp "
"source=\"db\"&gt;</literal> は <literal>&lt;version type=\"dbtimestamp\"&gt;"
"</literal> と等価であることに注意してください。"

#. Tag: title
#: basic_mapping.xml:1284
#, no-c-format
msgid "property"
msgstr "property"

#. Tag: para
#: basic_mapping.xml:1286
#, no-c-format
msgid ""
"The <literal>&lt;property&gt;</literal> element declares a persistent, "
"JavaBean style property of the class."
msgstr ""
"<literal>&lt;property&gt;</literal> 要素は、クラスの永続的なJavaBeanスタイル"
"のプロパティを定義します。"

#. Tag: programlisting
#: basic_mapping.xml:1308
#, no-c-format
msgid ""
"<![CDATA[<property\n"
"        name=\"propertyName\"\n"
"        column=\"column_name\"\n"
"        type=\"typename\"\n"
"        update=\"true|false\"\n"
"        insert=\"true|false\"\n"
"        formula=\"arbitrary SQL expression\"\n"
"        access=\"field|property|ClassName\"\n"
"        lazy=\"true|false\"\n"
"        unique=\"true|false\"\n"
"        not-null=\"true|false\"\n"
"        optimistic-lock=\"true|false\"\n"
"        generated=\"never|insert|always\"\n"
"        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
"        index=\"index_name\"\n"
"        unique_key=\"unique_key_id\"\n"
"        length=\"L\"\n"
"        precision=\"P\"\n"
"        scale=\"S\"\n"
"/>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1311
#, no-c-format
msgid ""
"<literal>name</literal>: the name of the property, with an initial lowercase "
"letter."
msgstr "<literal>name</literal>：小文字で始まるプロパティ名。"

#. Tag: para
#: basic_mapping.xml:1317
#, no-c-format
msgid ""
"<literal>column</literal> (optional - defaults to the property name): the "
"name of the mapped database table column. This may also be specified by "
"nested <literal>&lt;column&gt;</literal> element(s)."
msgstr ""
"<literal>column</literal>（オプション - デフォルトはプロパティ名）： マッピン"
"グされたデータベーステーブルのカラムの名前。 ネストした <literal>&lt;"
"column&gt;</literal> 要素でも指定できます。"

#. Tag: para
#: basic_mapping.xml:1324
#, no-c-format
msgid ""
"<literal>type</literal> (optional): a name that indicates the Hibernate type."
msgstr "<literal>type</literal>（オプション）：Hibernateの型を示す名前。"

#. Tag: para
#: basic_mapping.xml:1329
#, no-c-format
msgid ""
"<literal>update, insert</literal> (optional - defaults to <literal>true</"
"literal>) : specifies that the mapped columns should be included in SQL "
"<literal>UPDATE</literal> and/or <literal>INSERT</literal> statements. "
"Setting both to <literal>false</literal> allows a pure \"derived\" property "
"whose value is initialized from some other property that maps to the same "
"colum(s) or by a trigger or other application."
msgstr ""
"<literal>update, insert</literal> （オプション - デフォルトは <literal>true</"
"literal> ）： マッピングされたカラムがSQLの <literal>UPDATE</literal> や "
"<literal>INSERT</literal> に含まれることを指定します。 両方とも "
"<literal>false</literal> に設定すると、 同じカラムにマッピングされた他のプロ"
"パティやトリガや 他のアプリケーションによって初期化された純粋な「導出」プロパ"
"ティが可能になります。"

#. Tag: para
#: basic_mapping.xml:1338
#, no-c-format
msgid ""
"<literal>formula</literal> (optional): an SQL expression that defines the "
"value for a <emphasis>computed</emphasis> property. Computed properties do "
"not have a column mapping of their own."
msgstr ""
"<literal>formula</literal>（オプション）： <emphasis>計算</emphasis> プロパ"
"ティのための値を定義するSQL式。 計算されたプロパティは自身のカラムへのマッピ"
"ングがありません。"

#. Tag: para
#: basic_mapping.xml:1351
#, no-c-format
msgid ""
"<literal>lazy</literal> (optional - defaults to <literal>false</literal>): "
"Specifies that this property should be fetched lazily when the instance "
"variable is first accessed (requires build-time bytecode instrumentation)."
msgstr ""
"<literal>lazy</literal> (optional - デフォルトは <literal>false</literal> ): "
"インスタンス変数に最初にアクセスしたときに、プロパティを遅延して取得するよう"
"指定します。 (バイトコード実装を作成する時間が必要になります)。"

#. Tag: para
#: basic_mapping.xml:1358
#, no-c-format
msgid ""
"<literal>unique</literal> (optional): Enable the DDL generation of a unique "
"constraint for the columns. Also, allow this to be the target of a "
"<literal>property-ref</literal>."
msgstr ""
"<literal>unique</literal> (オプション):カラムにユニーク制約をつけるDDLの生成"
"を可能にします。 また、<literal>property-ref</literal> のターゲットとすること"
"もできます。"

#. Tag: para
#: basic_mapping.xml:1365
#, no-c-format
msgid ""
"<literal>not-null</literal> (optional): Enable the DDL generation of a "
"nullability constraint for the columns."
msgstr ""
"<literal>not-null</literal> (オプション):カラムにnull値を許可するDDLの生成を"
"可能にします。"

#. Tag: para
#: basic_mapping.xml:1371
#, no-c-format
msgid ""
"<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
"literal>): Specifies that updates to this property do or do not require "
"acquisition of the optimistic lock. In other words, determines if a version "
"increment should occur when this property is dirty."
msgstr ""
"<literal>optimistic-lock</literal> (オプション - デフォルトは <literal>true</"
"literal> ): このプロパティの更新に楽観ロックの取得を要求するかどうかを指定し"
"ます。 言い換えれば、このプロパティがダーティであるときにバージョンを増やすべ"
"きかを決定します。"

#. Tag: para
#: basic_mapping.xml:1379
#, no-c-format
msgid ""
"<literal>generated</literal> (optional - defaults to <literal>never</"
"literal>): Specifies that this property value is actually generated by the "
"database. See the discussion of <link linkend=\"mapping-generated"
"\">generated properties</link>."
msgstr ""
"<literal>generated</literal> (オプション - デフォルトは <literal>never</"
"literal> ): プロパティの値が、データベースによって生成されたことを指定しま"
"す。 <xref linkend=\"mapping-generated\">生成プロパティ</xref> を参照してくだ"
"さい。"

#. Tag: para
#: basic_mapping.xml:1388
#, no-c-format
msgid "<emphasis>typename</emphasis> could be:"
msgstr "<emphasis>typename</emphasis> には以下の値が可能です："

#. Tag: para
#: basic_mapping.xml:1394
#, no-c-format
msgid ""
"The name of a Hibernate basic type (eg. <literal>integer, string, character, "
"date, timestamp, float, binary, serializable, object, blob</literal>)."
msgstr ""
"Hibernateの基本型の名前（例 <literal>integer, string, character, date, "
"timestamp, float, binary, serializable, object, blob</literal> ）。"

#. Tag: para
#: basic_mapping.xml:1400
#, no-c-format
msgid ""
"The name of a Java class with a default basic type (eg. <literal>int, float, "
"char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</"
"literal>)."
msgstr ""
"デフォルトの基本型のJavaクラス名 （例 <literal>int, float, char, java.lang."
"String, java.util.Date, java.lang.Integer, java.sql.Clob</literal> ）。"

#. Tag: para
#: basic_mapping.xml:1406
#, no-c-format
msgid "The name of a serializable Java class."
msgstr "シリアライズ可能なJavaクラスの名前。"

#. Tag: para
#: basic_mapping.xml:1411
#, no-c-format
msgid ""
"The class name of a custom type (eg. <literal>com.illflow.type.MyCustomType</"
"literal>)."
msgstr ""
"カスタム型のクラス名（例 <literal>com.illflow.type.MyCustomType</"
"literal> ）。"

#. Tag: para
#: basic_mapping.xml:1417
#, no-c-format
msgid ""
"If you do not specify a type, Hibernate will use reflection upon the named "
"property to take a guess at the correct Hibernate type. Hibernate will try "
"to interpret the name of the return class of the property getter using rules "
"2, 3, 4 in that order. However, this is not always enough. In certain cases "
"you will still need the <literal>type</literal> attribute. (For example, to "
"distinguish between <literal>Hibernate.DATE</literal> and <literal>Hibernate."
"TIMESTAMP</literal>, or to specify a custom type.)"
msgstr ""
"型を指定しなければ、Hibernateは正しいHibernateの型を推測するために、 指定され"
"たプロパティに対してリフレクションを使います。 Hibernateはルール2, 3, 4をその"
"順序に使い、 getterプロパティの返り値のクラスの名前を解釈しようとします。 し"
"かしこれで常に十分であるとは限りません。 場合によっては、<literal>type</"
"literal> 属性が必要な場合があります。 （例えば <literal>Hibernate.DATE</"
"literal> と <literal>Hibernate.TIMESTAMP</literal> を区別するため、 またはカ"
"スタム型を指定するためなどです。）"

#. Tag: para
#: basic_mapping.xml:1427
#, no-c-format
msgid ""
"The <literal>access</literal> attribute lets you control how Hibernate will "
"access the property at runtime. By default, Hibernate will call the property "
"get/set pair. If you specify <literal>access=\"field\"</literal>, Hibernate "
"will bypass the get/set pair and access the field directly, using "
"reflection. You may specify your own strategy for property access by naming "
"a class that implements the interface <literal>org.hibernate.property."
"PropertyAccessor</literal>."
msgstr ""
"<literal>access</literal> 属性で、 実行時にHibernateがどのようにプロパティに"
"アクセスするかを制御できます。 デフォルトではHibernateはプロパティのget/setの"
"ペアをコールします。 <literal>access=\"field\"</literal> と指定すれば、 "
"Hibernateはリフレクションを使いget/setのペアを介さずに、直接フィールドにアク"
"セスします。 インターフェイス <literal>org.hibernate.property."
"PropertyAccessor</literal> を 実装するクラスを指定することで、プロパティへの"
"アクセスに独自の戦略を指定することができます。"

#. Tag: para
#: basic_mapping.xml:1436
#, no-c-format
msgid ""
"An especially powerful feature are derived properties. These properties are "
"by definition read-only, the property value is computed at load time. You "
"declare the computation as a SQL expression, this translates to a "
"<literal>SELECT</literal> clause subquery in the SQL query that loads an "
"instance:"
msgstr ""
"特に強力な特徴は生成プロパティです。 これらのプロパティは当然読み取り専用であ"
"り、プロパティの値はロード時に計算されます。 計算をSQL式として宣言すると、こ"
"のプロパティは インスタンスをロードするSQLクエリの <literal>SELECT</literal> "
"句のサブクエリに変換されます。"

#. Tag: programlisting
#: basic_mapping.xml:1443
#, no-c-format
msgid ""
"<![CDATA[\n"
"<property name=\"totalPrice\"\n"
"    formula=\"( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product "
"p\n"
"                WHERE li.productId = p.productId\n"
"                AND li.customerId = customerId\n"
"                AND li.orderNumber = orderNumber )\"/>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1445
#, no-c-format
msgid ""
"Note that you can reference the entities own table by not declaring an alias "
"on a particular column (<literal>customerId</literal> in the given example). "
"Also note that you can use the nested <literal>&lt;formula&gt;</literal> "
"mapping element if you don't like to use the attribute."
msgstr ""
"特定のカラム(例では <literal>customerId</literal> がそれにあたります)のエイリ"
"アスを宣言することなく、 エンティティ自身のテーブルを参照できることに注意して"
"ください。 もし属性を使用したくなければ、 ネストした <literal>&lt;formula&gt;"
"</literal> マッピング要素を使えることにも注意してください。"

#. Tag: title
#: basic_mapping.xml:1455
#, no-c-format
msgid "many-to-one"
msgstr "many-to-one"

#. Tag: para
#: basic_mapping.xml:1457
#, no-c-format
msgid ""
"An ordinary association to another persistent class is declared using a "
"<literal>many-to-one</literal> element. The relational model is a many-to-"
"one association: a foreign key in one table is referencing the primary key "
"column(s) of the target table."
msgstr ""
"他の永続クラスへの通常の関連は <literal>many-to-one</literal> 要素を使って定"
"義します。 リレーショナルモデルは多対一関連です。 つまりあるテーブルの外部"
"キーは、ターゲットとなるテーブルの主キーカラムを参照しています。"

#. Tag: programlisting
#: basic_mapping.xml:1485
#, no-c-format
msgid ""
"<![CDATA[<many-to-one\n"
"        name=\"propertyName\"\n"
"        column=\"column_name\"\n"
"        class=\"ClassName\"\n"
"        cascade=\"cascade_style\"\n"
"        fetch=\"join|select\"\n"
"        update=\"true|false\"\n"
"        insert=\"true|false\"\n"
"        property-ref=\"propertyNameFromAssociatedClass\"\n"
"        access=\"field|property|ClassName\"\n"
"        unique=\"true|false\"\n"
"        not-null=\"true|false\"\n"
"        optimistic-lock=\"true|false\"\n"
"        lazy=\"proxy|no-proxy|false\"\n"
"        not-found=\"ignore|exception\"\n"
"        entity-name=\"EntityName\"\n"
"        formula=\"arbitrary SQL expression\"\n"
"        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
"        embed-xml=\"true|false\"\n"
"        index=\"index_name\"\n"
"        unique_key=\"unique_key_id\"\n"
"        foreign-key=\"foreign_key_name\"\n"
"/>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1488 basic_mapping.xml:1669 basic_mapping.xml:1855
#, no-c-format
msgid "<literal>name</literal>: The name of the property."
msgstr "<literal>name</literal>：プロパティ名。"

#. Tag: para
#: basic_mapping.xml:1493 basic_mapping.xml:2284
#, fuzzy, no-c-format
msgid ""
"<literal>column</literal> (optional): The name of the foreign key column. "
"This may also be specified by nested <literal>&lt;column&gt;</literal> "
"element(s)."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>column</literal> (オプション):外部キーカラムの名前。 ネストした "
"<literal>&lt;column&gt;</literal> 要素でも指定できます。\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>column</literal> (オプション):外部キーカラムの名前。 ネストした "
"<literal>&lt;column&gt;</literal> カラムによっても指定されます。"

#. Tag: para
#: basic_mapping.xml:1500 basic_mapping.xml:1674
#, fuzzy, no-c-format
msgid ""
"<literal>class</literal> (optional - defaults to the property type "
"determined by reflection): The name of the associated class."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>class</literal>（オプション - デフォルトは、 リフレクションにより決"
"定されるプロパティの型）：関連クラスの名前。\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>class</literal>（オプション - デフォルトはリフレクションにより決定さ"
"れるプロパティの型）： 関連クラスの名前。"

#. Tag: para
#: basic_mapping.xml:1506
#, no-c-format
msgid ""
"<literal>cascade</literal> (optional): Specifies which operations should be "
"cascaded from the parent object to the associated object."
msgstr ""
"<literal>cascade</literal>（オプション）： どの操作を、親オブジェクトから関連"
"オブジェクトへとカスケードさせるかを指定します。"

#. Tag: para
#: basic_mapping.xml:1512 basic_mapping.xml:1695
#, fuzzy, no-c-format
msgid ""
"<literal>fetch</literal> (optional - defaults to <literal>select</literal>): "
"Chooses between outer-join fetching or sequential select fetching."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>fetch</literal> (オプション - デフォルトは <literal>select</"
"literal> ): 外部結合フェッチか順次選択フェッチ（sequential select fetch）を選"
"択します。\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>fetch</literal>（オプション - デフォルトは <literal>select</"
"literal> ）： 外部結合フェッチと順次選択フェッチ（sequential select fetch）の"
"どちらかを選択します。"

#. Tag: para
#: basic_mapping.xml:1518
#, no-c-format
msgid ""
"<literal>update, insert</literal> (optional - defaults to <literal>true</"
"literal>) specifies that the mapped columns should be included in SQL "
"<literal>UPDATE</literal> and/or <literal>INSERT</literal> statements. "
"Setting both to <literal>false</literal> allows a pure \"derived\" "
"association whose value is initialized from some other property that maps to "
"the same colum(s) or by a trigger or other application."
msgstr ""
"<literal>update, insert</literal>（オプション - デフォルトは <literal>true</"
"literal> ）： マッピングされたカラムがSQLの <literal>UPDATE</literal> または "
"<literal>INSERT</literal> 文に含まれることを指定します。 両方とも "
"<literal>false</literal> に設定すると、 その値が同じカラムにマッピングされた"
"他のプロパティやトリガや 他のアプリケーションによって初期化された純粋な「導"
"出」プロパティが可能になります。"

#. Tag: para
#: basic_mapping.xml:1527
#, no-c-format
msgid ""
"<literal>property-ref</literal>: (optional) The name of a property of the "
"associated class that is joined to this foreign key. If not specified, the "
"primary key of the associated class is used."
msgstr ""
"<literal>property-ref</literal>（オプション）： この外部キーに結合された関連"
"クラスのプロパティ名。 何も指定しなければ、関連クラスの主キーが使われます。"

#. Tag: para
#: basic_mapping.xml:1540
#, no-c-format
msgid ""
"<literal>unique</literal> (optional): Enable the DDL generation of a unique "
"constraint for the foreign-key column. Also, allow this to be the target of "
"a <literal>property-ref</literal>. This makes the association multiplicity "
"effectively one to one."
msgstr ""
"<literal>unique</literal>（オプション）： 外部キーカラムに対してユニーク制約"
"をつけたDDLの生成を可能にします。 また、<literal>property-ref</literal> の"
"ターゲットにすることもできます。 これにより関連の多重度を効果的に一対一にしま"
"す。"

#. Tag: para
#: basic_mapping.xml:1548
#, no-c-format
msgid ""
"<literal>not-null</literal> (optional): Enable the DDL generation of a "
"nullability constraint for the foreign key columns."
msgstr ""
"<literal>not-null</literal> (オプション):外部キーカラムに対して、 null値を許"
"可するDDLの生成を可能にします"

#. Tag: para
#: basic_mapping.xml:1554
#, no-c-format
msgid ""
"<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
"literal>): Specifies that updates to this property do or do not require "
"acquisition of the optimistic lock. In other words, dertermines if a version "
"increment should occur when this property is dirty."
msgstr ""
"<literal>optimistic-lock</literal> (オプション - デフォルトは <literal>true</"
"literal> ): このプロパティの更新に楽観的ロックの取得を要求するかどうかを指定"
"します。 言い換えれば、このプロパティがダーティであるときにバージョンを増やす"
"べきかを決定します。"

#. Tag: para
#: basic_mapping.xml:1562
#, no-c-format
msgid ""
"<literal>lazy</literal> (optional - defaults to <literal>proxy</literal>): "
"By default, single point associations are proxied. <literal>lazy=\"no-proxy"
"\"</literal> specifies that the property should be fetched lazily when the "
"instance variable is first accessed (requires build-time bytecode "
"instrumentation). <literal>lazy=\"false\"</literal> specifies that the "
"association will always be eagerly fetched."
msgstr ""
"<literal>lazy</literal> (オプション - デフォルトは <literal>proxy</"
"literal> ): デフォルトでは、多重度１の関連がプロキシとなります。 "
"<literal>lazy=\"no-proxy\"</literal> は、インスタンス変数に最初にアクセスした"
"ときに、 プロパティを遅延フェッチするよう指定します (ビルド時にバイトコード実"
"装が必要になります)。 <literal>lazy=\"false\"</literal> は関連を常に即時に"
"フェッチするよう指定します。"

#. Tag: para
#: basic_mapping.xml:1572
#, no-c-format
msgid ""
"<literal>not-found</literal> (optional - defaults to <literal>exception</"
"literal>): Specifies how foreign keys that reference missing rows will be "
"handled: <literal>ignore</literal> will treat a missing row as a null "
"association."
msgstr ""
"<literal>not-found</literal> (オプション - デフォルトは <literal>exception</"
"literal> ): 欠落した行を参照する外部キーをどのように扱うかを指定します。 "
"<literal>ignore</literal> は欠落した行をnull関連として扱います。"

#. Tag: para
#: basic_mapping.xml:1579 basic_mapping.xml:1733
#, fuzzy, no-c-format
msgid ""
"<literal>entity-name</literal> (optional): The entity name of the associated "
"class."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>entity-name</literal> (オプション):関連したクラスのエンティティ"
"名。\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>entity-name</literal> (オプション):関連クラスのエンティティ名"

#. Tag: para
#: basic_mapping.xml:1585
#, no-c-format
msgid ""
"<literal>formula</literal> (optional): an SQL expression that defines the "
"value for a <emphasis>computed</emphasis> foreign key."
msgstr ""
"<literal>formula</literal> (オプション): <emphasis> 計算された</emphasis> 外"
"部キーに対して値を定義するSQL式"

#. Tag: para
#: basic_mapping.xml:1592
#, no-c-format
msgid ""
"Setting a value of the <literal>cascade</literal> attribute to any "
"meaningful value other than <literal>none</literal> will propagate certain "
"operations to the associated object. The meaningful values are the names of "
"Hibernate's basic operations, <literal>persist, merge, delete, save-update, "
"evict, replicate, lock, refresh</literal>, as well as the special values "
"<literal>delete-orphan</literal> and <literal>all</literal> and comma-"
"separated combinations of operation names, for example, <literal>cascade="
"\"persist,merge,evict\"</literal> or <literal>cascade=\"all,delete-orphan\"</"
"literal>. See <xref linkend=\"objectstate-transitive\"/> for a full "
"explanation. Note that single valued associations (many-to-one and one-to-"
"one associations) do not support orphan delete."
msgstr ""
"<literal>cascade</literal> 属性に <literal>none</literal> 以外の意味のある値"
"をを設定すると、 関連オブジェクトへある操作が伝播することになります。 意味の"
"ある値とはHibernateの基本操作の名前のことで、 <literal>delete-orphan</"
"literal> と <literal>all</literal> 、操作名をカンマで区切った組み合わせ （例"
"えば <literal>cascade=\"persist,merge,evict\"</literal> や <literal>cascade="
"\"all,delete-orphan\"</literal>）、 またそれだけでなく <literal>persist, "
"merge, delete, save-update, evict, replicate, lock, refresh</literal> のこと"
"を指します。 詳しい説明は <xref linkend=\"objectstate-transitive\"/> を見てく"
"ださい。 値が一つの関連(many-to-oneとone-to-one関連)は、 単独での削除"
"（orphan delete)をサポートしていないことに注意してください。"

#. Tag: para
#: basic_mapping.xml:1605
#, no-c-format
msgid ""
"A typical <literal>many-to-one</literal> declaration looks as simple as this:"
msgstr ""
"典型的な <literal>many-to-one</literal> 宣言は次のようにシンプルです。："

#. Tag: programlisting
#: basic_mapping.xml:1609
#, no-c-format
msgid ""
"<![CDATA[<many-to-one name=\"product\" class=\"Product\" column=\"PRODUCT_ID"
"\"/>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1611
#, no-c-format
msgid ""
"The <literal>property-ref</literal> attribute should only be used for "
"mapping legacy data where a foreign key refers to a unique key of the "
"associated table other than the primary key. This is an ugly relational "
"model. For example, suppose the <literal>Product</literal> class had a "
"unique serial number, that is not the primary key. (The <literal>unique</"
"literal> attribute controls Hibernate's DDL generation with the SchemaExport "
"tool.)"
msgstr ""
"<literal>property-ref</literal> 属性は、外部キーが関連付けられたテーブルの、"
"主キーでない ユニークキーを参照しているレガシーデータをマップするためにだけ使"
"うべきです。 これは醜いリレーショナルモデルです。 例えば <literal>Product</"
"literal> クラスが、 主キーでないユニークなシリアルナンバーを持っていると仮定"
"してみてください。 （ <literal>unique</literal> 属性はSchemaExportツールを"
"使ったHibernateのDDL生成を制御します。）"

#. Tag: programlisting
#: basic_mapping.xml:1620
#, no-c-format
msgid ""
"<![CDATA[<property name=\"serialNumber\" unique=\"true\" type=\"string\" "
"column=\"SERIAL_NUMBER\"/>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1622
#, no-c-format
msgid "Then the mapping for <literal>OrderItem</literal> might use:"
msgstr ""
"以下のように <literal>OrderItem</literal> に対してマッピングを使えます："

#. Tag: programlisting
#: basic_mapping.xml:1626
#, no-c-format
msgid ""
"<![CDATA[<many-to-one name=\"product\" property-ref=\"serialNumber\" column="
"\"PRODUCT_SERIAL_NUMBER\"/>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1628
#, no-c-format
msgid "This is certainly not encouraged, however."
msgstr "しかし、これは決して推奨できません。"

#. Tag: para
#: basic_mapping.xml:1632
#, no-c-format
msgid ""
"If the referenced unique key comprises multiple properties of the associated "
"entity, you should map the referenced properties inside a named <literal>&lt;"
"properties&gt;</literal> element."
msgstr ""
"参照したユニークキーが、関連するエンティティの多数のプロパティから構成される"
"場合、 指定した <literal>&lt;properties&gt;</literal> 要素内で、参照するプロ"
"パティをマッピングするべきです。"

#. Tag: para
#: basic_mapping.xml:1637
#, no-c-format
msgid ""
"If the referenced unique key is the property of a component, you may specify "
"a property path:"
msgstr ""
"もし参照したユニークキーがコンポーネントのプロパティである場合は、プロパティ"
"のパスを指定できます。"

#. Tag: programlisting
#: basic_mapping.xml:1641
#, no-c-format
msgid ""
"<![CDATA[<many-to-one name=\"owner\" property-ref=\"identity.ssn\" column="
"\"OWNER_SSN\"/>]]>"
msgstr ""

#. Tag: title
#: basic_mapping.xml:1646
#, no-c-format
msgid "one-to-one"
msgstr "one-to-one"

#. Tag: para
#: basic_mapping.xml:1648
#, no-c-format
msgid ""
"A one-to-one association to another persistent class is declared using a "
"<literal>one-to-one</literal> element."
msgstr ""
"他の永続クラスへの一対一関連は、<literal>one-to-one</literal> 要素で定義しま"
"す。"

#. Tag: programlisting
#: basic_mapping.xml:1666
#, no-c-format
msgid ""
"<![CDATA[<one-to-one\n"
"        name=\"propertyName\"\n"
"        class=\"ClassName\"\n"
"        cascade=\"cascade_style\"\n"
"        constrained=\"true|false\"\n"
"        fetch=\"join|select\"\n"
"        property-ref=\"propertyNameFromAssociatedClass\"\n"
"        access=\"field|property|ClassName\"\n"
"        formula=\"any SQL expression\"\n"
"        lazy=\"proxy|no-proxy|false\"\n"
"        entity-name=\"EntityName\"\n"
"        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
"        embed-xml=\"true|false\"\n"
"        foreign-key=\"foreign_key_name\"\n"
"/>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1680
#, no-c-format
msgid ""
"<literal>cascade</literal> (optional) specifies which operations should be "
"cascaded from the parent object to the associated object."
msgstr ""
"<literal>cascade</literal>（オプション）： 親オブジェクトから関連オブジェクト"
"へ、どの操作をカスケードするかを指定します。"

#. Tag: para
#: basic_mapping.xml:1686
#, no-c-format
msgid ""
"<literal>constrained</literal> (optional) specifies that a foreign key "
"constraint on the primary key of the mapped table references the table of "
"the associated class. This option affects the order in which <literal>save()"
"</literal> and <literal>delete()</literal> are cascaded, and determines "
"whether the association may be proxied (it is also used by the schema export "
"tool)."
msgstr ""
"<literal>constrained</literal>（オプション）： マッピングされたテーブルの主"
"キーに対する外部キー制約が、 関連クラスのテーブルを参照することを指定しま"
"す。 このオプションは <literal>save()</literal> と <literal>delete()</"
"literal> がカスケードされる順序に影響し、 そして関連がプロキシされるかどうか"
"にも影響します （そしてスキーマエクスポートツールにも使われます）。"

#. Tag: para
#: basic_mapping.xml:1701
#, no-c-format
msgid ""
"<literal>property-ref</literal>: (optional) The name of a property of the "
"associated class that is joined to the primary key of this class. If not "
"specified, the primary key of the associated class is used."
msgstr ""
"<literal>property-ref</literal>（オプション）： このクラスの主キーに結合され"
"た関連クラスのプロパティ名。 指定されなければ、関連クラスの主キーが使われま"
"す。"

#. Tag: para
#: basic_mapping.xml:1714
#, no-c-format
msgid ""
"<literal>formula</literal> (optional): Almost all one to one associations "
"map to the primary key of the owning entity. In the rare case that this is "
"not the case, you may specify a some other column, columns or expression to "
"join on using an SQL formula. (See <literal>org.hibernate.test."
"onetooneformula</literal> for an example.)"
msgstr ""
"<literal>formula</literal> (オプション): ほとんどすべての一対一関連はオーナー"
"のエンティティの主キーへとマッピングされます。 これ以外の稀な場合は、 他のカ"
"ラムや、複数のカラム、SQL構文を使った結合するための式を指定できます。 （例は "
"<literal>org.hibernate.test.onetooneformula</literal> を参照してください。）"

#. Tag: para
#: basic_mapping.xml:1722
#, no-c-format
msgid ""
"<literal>lazy</literal> (optional - defaults to <literal>proxy</literal>): "
"By default, single point associations are proxied. <literal>lazy=\"no-proxy"
"\"</literal> specifies that the property should be fetched lazily when the "
"instance variable is first accessed (requires build-time bytecode "
"instrumentation). <literal>lazy=\"false\"</literal> specifies that the "
"association will always be eagerly fetched. <emphasis>Note that if "
"<literal>constrained=\"false\"</literal>, proxying is impossible and "
"Hibernate will eager fetch the association!</emphasis>"
msgstr ""
"<literal>lazy</literal> (オプション - デフォルトは <literal>proxy</"
"literal> ): デフォルトでは、多重度１の関連がプロキシとなります。 "
"<literal>lazy=\"no-proxy\"</literal> は、インスタンス変数に最初にアクセスした"
"ときに、 プロパティを遅延フェッチするよう指定します (ビルド時にバイトコード実"
"装が必要になります)。 <literal>lazy=\"false\"</literal> は関連を常に即時に"
"フェッチするよう指定します。 <emphasis>もし <literal>constrained=\"false\"</"
"literal> ならば、 プロキシは使用不可能となり、関連を即時にフェッチすることに"
"注意してください！</emphasis>"

#. Tag: para
#: basic_mapping.xml:1740
#, no-c-format
msgid "There are two varieties of one-to-one association:"
msgstr "一対一関連には2種類あります："

#. Tag: para
#: basic_mapping.xml:1744
#, no-c-format
msgid "primary key associations"
msgstr "主キー関連"

#. Tag: para
#: basic_mapping.xml:1747
#, no-c-format
msgid "unique foreign key associations"
msgstr "ユニーク外部キー関連"

#. Tag: para
#: basic_mapping.xml:1752
#, no-c-format
msgid ""
"Primary key associations don't need an extra table column; if two rows are "
"related by the association then the two table rows share the same primary "
"key value. So if you want two objects to be related by a primary key "
"association, you must make sure that they are assigned the same identifier "
"value!"
msgstr ""
"主キー関連には、特別なテーブルカラムは必要ありません。 もし2つの行が関連によ"
"り関係していれば、2つのテーブルは同じ主キーの値を共有します。 そのため2つのオ"
"ブジェクトを主キー関連によって関連付けたいのであれば、 確実に同じ識別子の値を"
"代入しなければなりません。"

#. Tag: para
#: basic_mapping.xml:1759
#, no-c-format
msgid ""
"For a primary key association, add the following mappings to "
"<literal>Employee</literal> and <literal>Person</literal>, respectively."
msgstr ""
"主キー関連を行うためには、以下のマッピングを <literal>Employee</literal> と "
"<literal>Person</literal> のそれぞれに追加してください。"

#. Tag: programlisting
#: basic_mapping.xml:1764
#, no-c-format
msgid "<![CDATA[<one-to-one name=\"person\" class=\"Person\"/>]]>"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1765
#, no-c-format
msgid ""
"<![CDATA[<one-to-one name=\"employee\" class=\"Employee\" constrained=\"true"
"\"/>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1767
#, no-c-format
msgid ""
"Now we must ensure that the primary keys of related rows in the PERSON and "
"EMPLOYEE tables are equal. We use a special Hibernate identifier generation "
"strategy called <literal>foreign</literal>:"
msgstr ""
"ここで、PERSONとEMPLOYEEテーブルの関係する行の主キーが同じであることを確実に"
"しなければいけません。 ここでは、<literal>foreign</literal> という特殊な"
"Hibernate識別子生成戦略を使います："

#. Tag: programlisting
#: basic_mapping.xml:1773
#, no-c-format
msgid ""
"<![CDATA[<class name=\"person\" table=\"PERSON\">\n"
"    <id name=\"id\" column=\"PERSON_ID\">\n"
"        <generator class=\"foreign\">\n"
"            <param name=\"property\">employee</param>\n"
"        </generator>\n"
"    </id>\n"
"    ...\n"
"    <one-to-one name=\"employee\"\n"
"        class=\"Employee\"\n"
"        constrained=\"true\"/>\n"
"</class>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1775
#, no-c-format
msgid ""
"A newly saved instance of <literal>Person</literal> is then assigned the "
"same primary key value as the <literal>Employee</literal> instance refered "
"with the <literal>employee</literal> property of that <literal>Person</"
"literal>."
msgstr ""
"<literal>Employee</literal> インスタンスが、<literal>Person</literal> の "
"<literal>employee</literal> プロパティで参照されるように、 新しくセーブされ"
"た <literal>Person</literal> のインスタンスには同じ主キーの値が代入されま"
"す。 新しくセーブする <literal>Person</literal> インスタンスは、 その "
"<literal>Person</literal> の <literal>employee</literal> プロパティが参照す"
"る <literal>Employee</literal> インスタンスとして同じ主キーが割り当てられま"
"す。"

#. Tag: para
#: basic_mapping.xml:1781
#, no-c-format
msgid ""
"Alternatively, a foreign key with a unique constraint, from "
"<literal>Employee</literal> to <literal>Person</literal>, may be expressed "
"as:"
msgstr ""
"もう1つの方法として、<literal>Employee</literal> から <literal>Person</"
"literal> への ユニーク制約を使った外部キー関連は以下のように表現されます："

#. Tag: programlisting
#: basic_mapping.xml:1786
#, no-c-format
msgid ""
"<![CDATA[<many-to-one name=\"person\" class=\"Person\" column=\"PERSON_ID\" "
"unique=\"true\"/>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1788
#, no-c-format
msgid ""
"And this association may be made bidirectional by adding the following to "
"the <literal>Person</literal> mapping:"
msgstr ""
"そしてこの関連は、 以下の記述を <literal>Person</literal> のマッピングに追加"
"することで双方向にすることができます："

#. Tag: programlisting
#: basic_mapping.xml:1793
#, no-c-format
msgid ""
"<![CDATA[<one-to-one name=\"employee\" class=\"Employee\" property-ref="
"\"person\"/>]]>"
msgstr ""

#. Tag: title
#: basic_mapping.xml:1798
#, no-c-format
msgid "natural-id"
msgstr "natural-id"

#. Tag: programlisting
#: basic_mapping.xml:1800
#, no-c-format
msgid ""
"<![CDATA[<natural-id mutable=\"true|false\"/>\n"
"        <property ... />\n"
"        <many-to-one ... />\n"
"        ......\n"
"</natural-id>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1802
#, no-c-format
msgid ""
"Even though we recommend the use of surrogate keys as primary keys, you "
"should still try to identify natural keys for all entities. A natural key is "
"a property or combination of properties that is unique and non-null. If it "
"is also immutable, even better. Map the properties of the natural key inside "
"the <literal>&lt;natural-id&gt;</literal> element. Hibernate will generate "
"the necessary unique key and nullability constraints, and your mapping will "
"be more self-documenting."
msgstr ""
"主キーとして代理キーの使用を推奨しますが、 すべてのエンティティに対して自然"
"キーを識別するようにすべきです。 自然キーはユニークかつ非nullな一つのプロパ"
"ティ、またはプロパティの連結です。 不変であればさらに良いです。 <literal>&lt;"
"natural-id&gt;</literal> 要素内で自然キーのプロパティをマッピングします。 "
"Hibernateは必然的にユニークかつnull値を許可する制約を生成し、 こうしてマッピ"
"ングはより自己記述的になります。"

#. Tag: para
#: basic_mapping.xml:1811
#, no-c-format
msgid ""
"We strongly recommend that you implement <literal>equals()</literal> and "
"<literal>hashCode()</literal> to compare the natural key properties of the "
"entity."
msgstr ""
"エンティティの自然キープロパティの比較には、 <literal>equals()</literal> と "
"<literal>hashCode()</literal> の実装を強くお勧めします。"

#. Tag: para
#: basic_mapping.xml:1816
#, no-c-format
msgid ""
"This mapping is not intended for use with entities with natural primary keys."
msgstr ""
"このマッピングは自然主キーを使ったエンティティでの使用を意図していません。"

#. Tag: para
#: basic_mapping.xml:1822
#, no-c-format
msgid ""
"<literal>mutable</literal> (optional, defaults to <literal>false</literal>): "
"By default, natural identifier properties as assumed to be immutable "
"(constant)."
msgstr ""
"<literal>mutable</literal> (オプション, デフォルトは <literal>false</"
"literal> ): デフォルトでは、自然識別子プロパティは不変(定数)と想定されていま"
"す。"

#. Tag: title
#: basic_mapping.xml:1832
#, no-c-format
msgid "component, dynamic-component"
msgstr "component, dynamic-component"

#. Tag: para
#: basic_mapping.xml:1834
#, no-c-format
msgid ""
"The <literal>&lt;component&gt;</literal> element maps properties of a child "
"object to columns of the table of a parent class. Components may, in turn, "
"declare their own properties, components or collections. See \"Components\" "
"below."
msgstr ""
"<literal>&lt;component&gt;</literal> 要素は、 子オブジェクトのプロパティを親"
"クラスのテーブルのカラムへマッピングします。 コンポーネントは自分のプロパ"
"ティ、コンポーネント、コレクションの順に定義できます。 以下の「コンポーネン"
"ト」を見てください。"

#. Tag: programlisting
#: basic_mapping.xml:1852
#, no-c-format
msgid ""
"<![CDATA[<component\n"
"        name=\"propertyName\"\n"
"        class=\"className\"\n"
"        insert=\"true|false\"\n"
"        update=\"true|false\"\n"
"        access=\"field|property|ClassName\"\n"
"        lazy=\"true|false\"\n"
"        optimistic-lock=\"true|false\"\n"
"        unique=\"true|false\"\n"
"        node=\"element-name|.\"\n"
">\n"
"\n"
"        <property ...../>\n"
"        <many-to-one .... />\n"
"        ........\n"
"</component>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1860
#, no-c-format
msgid ""
"<literal>class</literal> (optional - defaults to the property type "
"determined by reflection): The name of the component (child) class."
msgstr ""
"<literal>class</literal> （オプション - デフォルトはリフレクションにより決定"
"されるプロパティの型）： コンポーネント（子）クラスの名前。"

#. Tag: para
#: basic_mapping.xml:1866 basic_mapping.xml:1955
#, fuzzy, no-c-format
msgid ""
"<literal>insert</literal>: Do the mapped columns appear in SQL "
"<literal>INSERT</literal>s?"
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>insert</literal> ：マッピングされたカラムがSQLの <literal>INSERT</"
"literal> に現れるようにするどうかを指定します。\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>insert</literal>：マッピングされたカラムがSQLの <literal>INSERT</"
"literal> に現れるようにするかどうかを指定します。"

#. Tag: para
#: basic_mapping.xml:1872 basic_mapping.xml:1961
#, fuzzy, no-c-format
msgid ""
"<literal>update</literal>: Do the mapped columns appear in SQL "
"<literal>UPDATE</literal>s?"
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>update</literal> : マッピングされたカラムがSQL の <literal>UPDATE</"
"literal> に現れるようにするかどうかを指定します。\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>update</literal>：マッピングされたカラムがSQLの <literal>UPDATE</"
"literal> に現れるようにするかどうかを指定します。"

#. Tag: para
#: basic_mapping.xml:1884
#, no-c-format
msgid ""
"<literal>lazy</literal> (optional - defaults to <literal>false</literal>): "
"Specifies that this component should be fetched lazily when the instance "
"variable is first accessed (requires build-time bytecode instrumentation)."
msgstr ""
"<literal>lazy</literal> (optional - デフォルトは <literal>false</literal> ): "
"インスタンス変数に最初にアクセスしたときに、 コンポーネントを遅延してフェッチ"
"するよう指定します。 (バイトコード実装を作成する時間が必要になります)"

#. Tag: para
#: basic_mapping.xml:1891
#, no-c-format
msgid ""
"<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
"literal>): Specifies that updates to this component do or do not require "
"acquisition of the optimistic lock. In other words, determines if a version "
"increment should occur when this property is dirty."
msgstr ""
"<literal>optimistic-lock</literal> (オプション - デフォルトは <literal>true</"
"literal> ): このプロパティの更新に、楽観ロックの取得を要求するかどうかを指定"
"します。 言い換えれば、このプロパティがダーティであるときにバージョンを増やす"
"べきかを決定します。"

#. Tag: para
#: basic_mapping.xml:1899 basic_mapping.xml:1975
#, no-c-format
msgid ""
"<literal>unique</literal> (optional - defaults to <literal>false</literal>): "
"Specifies that a unique constraint exists upon all mapped columns of the "
"component."
msgstr ""
"<literal>unique</literal> (オプション - デフォルトは <literal>false</"
"literal> ): コンポーネントのすべてのマッピングするカラムに、ユニーク制約が存"
"在するかを指定します。"

#. Tag: para
#: basic_mapping.xml:1908
#, no-c-format
msgid ""
"The child <literal>&lt;property&gt;</literal> tags map properties of the "
"child class to table columns."
msgstr ""
"子の <literal>&lt;property&gt;</literal> タグで、 子のクラスのプロパティを"
"テーブルカラムにマッピングします。"

#. Tag: para
#: basic_mapping.xml:1913
#, no-c-format
msgid ""
"The <literal>&lt;component&gt;</literal> element allows a <literal>&lt;"
"parent&gt;</literal> subelement that maps a property of the component class "
"as a reference back to the containing entity."
msgstr ""
"<literal>&lt;component&gt;</literal> 要素は、親エンティティへ戻る参照とし"
"て、 コンポーネントのクラスのプロパティをマッピングする <literal>&lt;"
"parent&gt;</literal> サブ要素を許可します。"

#. Tag: para
#: basic_mapping.xml:1919
#, no-c-format
msgid ""
"The <literal>&lt;dynamic-component&gt;</literal> element allows a "
"<literal>Map</literal> to be mapped as a component, where the property names "
"refer to keys of the map, see <xref linkend=\"components-dynamic\"/>."
msgstr ""
"<literal>&lt;dynamic-component&gt;</literal> 要素は、 <literal>Map</literal> "
"がコンポーネントとしてマッピングされることを可能にします。 プロパティ名はmap"
"のキーを参照します。<xref linkend=\"components-dynamic\"/> を参照してくださ"
"い。"

#. Tag: title
#: basic_mapping.xml:1928
#, no-c-format
msgid "properties"
msgstr "properties"

#. Tag: para
#: basic_mapping.xml:1930
#, no-c-format
msgid ""
"The <literal>&lt;properties&gt;</literal> element allows the definition of a "
"named, logical grouping of properties of a class. The most important use of "
"the construct is that it allows a combination of properties to be the target "
"of a <literal>property-ref</literal>. It is also a convenient way to define "
"a multi-column unique constraint."
msgstr ""
"<literal>&lt;properties&gt;</literal> 要素はクラスのプロパティの指定された、 "
"論理的なグルーピングを可能にします。 この構造の最も重要な使用方法は、 "
"<literal>property-ref</literal> のターゲットになるプロパティの結合を許可する"
"ことです。 それはまた、複数カラムのユニーク制約を定義する簡単な方法でもありま"
"す。"

#. Tag: programlisting
#: basic_mapping.xml:1946
#, no-c-format
msgid ""
"<![CDATA[<properties\n"
"        name=\"logicalName\"\n"
"        insert=\"true|false\"\n"
"        update=\"true|false\"\n"
"        optimistic-lock=\"true|false\"\n"
"        unique=\"true|false\"\n"
">\n"
"\n"
"        <property ...../>\n"
"        <many-to-one .... />\n"
"        ........\n"
"</properties>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1949
#, no-c-format
msgid ""
"<literal>name</literal>: The logical name of the grouping - <emphasis>not</"
"emphasis> an actual property name."
msgstr ""
"<literal>name</literal> : グルーピングの論理名。 実際のプロパティ名では "
"<emphasis>ありません</emphasis> 。"

#. Tag: para
#: basic_mapping.xml:1967
#, no-c-format
msgid ""
"<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
"literal>): Specifies that updates to these properties do or do not require "
"acquisition of the optimistic lock. In other words, determines if a version "
"increment should occur when these properties are dirty."
msgstr ""
"<literal>optimistic-lock</literal> (オプション - デフォルトは <literal>true</"
"literal> ): これらのプロパティの更新に楽観的ロックの取得を要求するかどうかを"
"指定します。 言い換えれば、このプロパティがダーティであるときにバージョンを増"
"やすべきかを決定します。"

#. Tag: para
#: basic_mapping.xml:1984
#, no-c-format
msgid ""
"For example, if we have the following <literal>&lt;properties&gt;</literal> "
"mapping:"
msgstr ""
"例えば、もし以下のような <literal>&lt;properties&gt;</literal> マッピングが"
"あった場合："

#. Tag: programlisting
#: basic_mapping.xml:1988
#, no-c-format
msgid ""
"<![CDATA[<class name=\"Person\">\n"
"    <id name=\"personNumber\"/>\n"
"    ...\n"
"    <properties name=\"name\"\n"
"            unique=\"true\" update=\"false\">\n"
"        <property name=\"firstName\"/>\n"
"        <property name=\"initial\"/>\n"
"        <property name=\"lastName\"/>\n"
"    </properties>\n"
"</class>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1990
#, no-c-format
msgid ""
"Then we might have some legacy data association which refers to this unique "
"key of the <literal>Person</literal> table, instead of to the primary key:"
msgstr ""
"主キーの代わりに <literal>Person</literal> テーブルのユニークキーへの参照を持"
"つ、 レガシーデータの関連を持つかもしれません。："

#. Tag: programlisting
#: basic_mapping.xml:1995
#, no-c-format
msgid ""
"<![CDATA[<many-to-one name=\"person\"\n"
"         class=\"Person\" property-ref=\"name\">\n"
"    <column name=\"firstName\"/>\n"
"    <column name=\"initial\"/>\n"
"    <column name=\"lastName\"/>\n"
"</many-to-one>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1997
#, no-c-format
msgid ""
"We don't recommend the use of this kind of thing outside the context of "
"mapping legacy data."
msgstr ""
"しかし、このようなレガシーデータマッピングのコンテキスト外への使用は推奨しま"
"せん。"

#. Tag: title
#: basic_mapping.xml:2005
#, no-c-format
msgid "subclass"
msgstr "subclass"

#. Tag: para
#: basic_mapping.xml:2007
#, no-c-format
msgid ""
"Finally, polymorphic persistence requires the declaration of each subclass "
"of the root persistent class. For the table-per-class-hierarchy mapping "
"strategy, the <literal>&lt;subclass&gt;</literal> declaration is used."
msgstr ""
"最後にポリモーフィックな永続化には、ルートの永続クラスの各サブクラスの定義が"
"必要です。 table-per-class-hierarchyマッピング戦略では、 <literal>&lt;"
"subclass&gt;</literal> 定義が使われます。"

#. Tag: programlisting
#: basic_mapping.xml:2020
#, no-c-format
msgid ""
"<![CDATA[<subclass\n"
"        name=\"ClassName\"\n"
"        discriminator-value=\"discriminator_value\"\n"
"        proxy=\"ProxyInterface\"\n"
"        lazy=\"true|false\"\n"
"        dynamic-update=\"true|false\"\n"
"        dynamic-insert=\"true|false\"\n"
"        entity-name=\"EntityName\"\n"
"        node=\"element-name\"\n"
"        extends=\"SuperclassName\">\n"
"\n"
"        <property .... />\n"
"        .....\n"
"</subclass>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2023 basic_mapping.xml:2081 basic_mapping.xml:2144
#, no-c-format
msgid ""
"<literal>name</literal>: The fully qualified class name of the subclass."
msgstr "<literal>name</literal>：サブクラスの完全修飾されたクラス名。"

#. Tag: para
#: basic_mapping.xml:2028
#, no-c-format
msgid ""
"<literal>discriminator-value</literal> (optional - defaults to the class "
"name): A value that distiguishes individual subclasses."
msgstr ""
"<literal>discriminator-value</literal>（オプション - デフォルトはクラス"
"名）： 個々のサブクラスを区別するための値。"

#. Tag: para
#: basic_mapping.xml:2034 basic_mapping.xml:2091 basic_mapping.xml:2154
#, fuzzy, no-c-format
msgid ""
"<literal>proxy</literal> (optional): Specifies a class or interface to use "
"for lazy initializing proxies."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>proxy</literal>（オプション）： 遅延初期化プロキシに使うクラスやイン"
"ターフェイスを指定します。\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>proxy</literal> (オプション): 遅延初期化プロキシに使用するクラスやイ"
"ンターフェイスを指定します。\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>proxy</literal> (オプション): 遅延初期化プロキシに使用するクラスやイ"
"ンターフェイスを指定します。"

#. Tag: para
#: basic_mapping.xml:2040 basic_mapping.xml:2097 basic_mapping.xml:2160
#, fuzzy, no-c-format
msgid ""
"<literal>lazy</literal> (optional, defaults to <literal>true</literal>): "
"Setting <literal>lazy=\"false\"</literal> disables the use of lazy fetching."
msgstr ""
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>lazy</literal>（オプション, デフォルトは <literal>true</"
"literal> ）： <literal>lazy=\"false\"</literal> と設定すると、遅延フェッチが"
"使用できません。\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>lazy</literal> (オプション, デフォルトは <literal>true</literal> ): "
"<literal>lazy=\"false\"</literal> とすると、遅延フェッチが使用できません。\n"
"#-#-#-#-#  - (PACKAGE VERSION)  #-#-#-#-#\n"
"<literal>lazy</literal> (オプション, デフォルトは <literal>true</literal> ): "
"<literal>lazy=\"false\"</literal> とすると、遅延フェッチが使用できません。"

#. Tag: para
#: basic_mapping.xml:2048
#, no-c-format
msgid ""
"Each subclass should declare its own persistent properties and subclasses. "
"<literal>&lt;version&gt;</literal> and <literal>&lt;id&gt;</literal> "
"properties are assumed to be inherited from the root class. Each subclass in "
"a heirarchy must define a unique <literal>discriminator-value</literal>. If "
"none is specified, the fully qualified Java class name is used."
msgstr ""
"各サブクラスでは、永続プロパティとサブクラスを定義します。 <literal>&lt;"
"version&gt;</literal> と <literal>&lt;id&gt;</literal> プロパティは、 ルート"
"クラスから継承されると仮定されます。 階層構造におけるサブクラスは、 ユニーク"
"な <literal>discriminator-value</literal> を定義しなければなりません。 noneが"
"指定されると、完全修飾されたJavaクラス名が使われます。"

#. Tag: para
#: basic_mapping.xml:2056 basic_mapping.xml:2114 basic_mapping.xml:2172
#, no-c-format
msgid ""
"For information about inheritance mappings, see <xref linkend=\"inheritance"
"\"/>."
msgstr ""
"継承のマッピングに関する情報は <xref linkend=\"inheritance\"/> を見てくださ"
"い。"

#. Tag: title
#: basic_mapping.xml:2063
#, no-c-format
msgid "joined-subclass"
msgstr "joined-subclass"

#. Tag: para
#: basic_mapping.xml:2065
#, no-c-format
msgid ""
"Alternatively, each subclass may be mapped to its own table (table-per-"
"subclass mapping strategy). Inherited state is retrieved by joining with the "
"table of the superclass. We use the <literal>&lt;joined-subclass&gt;</"
"literal> element."
msgstr ""
"もう1つの方法として、各サブクラスを自身のテーブルへマッピングすることができま"
"す (table-per-subclass mapping strategy)。 継承した状態はスーパークラスのテー"
"ブルを使った結合で検索します。 <literal>&lt;joined-subclass&gt;</literal> 要"
"素を使用します。"

#. Tag: programlisting
#: basic_mapping.xml:2078
#, no-c-format
msgid ""
"<![CDATA[<joined-subclass\n"
"        name=\"ClassName\"\n"
"        table=\"tablename\"\n"
"        proxy=\"ProxyInterface\"\n"
"        lazy=\"true|false\"\n"
"        dynamic-update=\"true|false\"\n"
"        dynamic-insert=\"true|false\"\n"
"        schema=\"schema\"\n"
"        catalog=\"catalog\"\n"
"        extends=\"SuperclassName\"\n"
"        persister=\"ClassName\"\n"
"        subselect=\"SQL expression\"\n"
"        entity-name=\"EntityName\"\n"
"        node=\"element-name\">\n"
"\n"
"        <key .... >\n"
"\n"
"        <property .... />\n"
"        .....\n"
"</joined-subclass>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2086 basic_mapping.xml:2149
#, no-c-format
msgid "<literal>table</literal>: The name of the subclass table."
msgstr "<literal>table</literal> :サブクラステーブルの名前。"

#. Tag: para
#: basic_mapping.xml:2105
#, no-c-format
msgid ""
"No discriminator column is required for this mapping strategy. Each subclass "
"must, however, declare a table column holding the object identifier using "
"the <literal>&lt;key&gt;</literal> element. The mapping at the start of the "
"chapter would be re-written as:"
msgstr ""
"このマッピング戦略には、識別カラムは必要ありません。 しかし各サブクラスは "
"<literal>&lt;key&gt;</literal> 要素を使い、 オブジェクト識別子を保持するテー"
"ブルカラムを定義しなければなりません。 この章の初めのマッピングは以下のように"
"書き直せます："

#. Tag: programlisting
#: basic_mapping.xml:2112
#, no-c-format
msgid ""
"<![CDATA[<?xml version=\"1.0\"?>\n"
"<!DOCTYPE hibernate-mapping PUBLIC\n"
"        \"-//Hibernate/Hibernate Mapping DTD//EN\"\n"
"        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\n"
"\n"
"<hibernate-mapping package=\"eg\">\n"
"\n"
"        <class name=\"Cat\" table=\"CATS\">\n"
"                <id name=\"id\" column=\"uid\" type=\"long\">\n"
"                        <generator class=\"hilo\"/>\n"
"                </id>\n"
"                <property name=\"birthdate\" type=\"date\"/>\n"
"                <property name=\"color\" not-null=\"true\"/>\n"
"                <property name=\"sex\" not-null=\"true\"/>\n"
"                <property name=\"weight\"/>\n"
"                <many-to-one name=\"mate\"/>\n"
"                <set name=\"kittens\">\n"
"                        <key column=\"MOTHER\"/>\n"
"                        <one-to-many class=\"Cat\"/>\n"
"                </set>\n"
"                <joined-subclass name=\"DomesticCat\" table=\"DOMESTIC_CATS"
"\">\n"
"                    <key column=\"CAT\"/>\n"
"                    <property name=\"name\" type=\"string\"/>\n"
"                </joined-subclass>\n"
"        </class>\n"
"\n"
"        <class name=\"eg.Dog\">\n"
"                <!-- mapping for Dog could go here -->\n"
"        </class>\n"
"\n"
"</hibernate-mapping>]]>"
msgstr ""

#. Tag: title
#: basic_mapping.xml:2121
#, no-c-format
msgid "union-subclass"
msgstr "union-subclass"

#. Tag: para
#: basic_mapping.xml:2123
#, no-c-format
msgid ""
"A third option is to map only the concrete classes of an inheritance "
"hierarchy to tables, (the table-per-concrete-class strategy) where each "
"table defines all persistent state of the class, including inherited state. "
"In Hibernate, it is not absolutely necessary to explicitly map such "
"inheritance hierarchies. You can simply map each class with a separate "
"<literal>&lt;class&gt;</literal> declaration. However, if you wish use "
"polymorphic associations (e.g. an association to the superclass of your "
"hierarchy), you need to use the <literal>&lt;union-subclass&gt;</literal> "
"mapping."
msgstr ""
"3つ目の選択肢は、継承階層の具象クラスのみをテーブルにマッピングすることです "
"(the table-per-concrete-class戦略)。 それぞれのテーブルは継承の状態を含めすべ"
"てのクラスの永続状態を定義します。 Hibernateではその様な継承階層が必ずしも必"
"要ではありません。 単純にそれぞれのクラスを、 別々の <literal>&lt;class&gt;</"
"literal> 宣言を使ってマッピングすることができます。 しかしポリモーフィックな"
"関連(例えば 階層のスーパークラスへの関連)を使いたいなら、 <literal>&lt;union-"
"subclass&gt;</literal> マッピングを使う必要があります。"

#. Tag: programlisting
#: basic_mapping.xml:2141
#, no-c-format
msgid ""
"<![CDATA[<union-subclass\n"
"        name=\"ClassName\"\n"
"        table=\"tablename\"\n"
"        proxy=\"ProxyInterface\"\n"
"        lazy=\"true|false\"\n"
"        dynamic-update=\"true|false\"\n"
"        dynamic-insert=\"true|false\"\n"
"        schema=\"schema\"\n"
"        catalog=\"catalog\"\n"
"        extends=\"SuperclassName\"\n"
"        abstract=\"true|false\"\n"
"        persister=\"ClassName\"\n"
"        subselect=\"SQL expression\"\n"
"        entity-name=\"EntityName\"\n"
"        node=\"element-name\">\n"
"\n"
"        <property .... />\n"
"        .....\n"
"</union-subclass>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2168
#, no-c-format
msgid ""
"No discriminator column or key column is required for this mapping strategy."
msgstr "このマッピング戦略では識別カラムやキーカラムは必要ありません。"

#. Tag: title
#: basic_mapping.xml:2179
#, no-c-format
msgid "join"
msgstr "join"

#. Tag: para
#: basic_mapping.xml:2181
#, no-c-format
msgid ""
"Using the <literal>&lt;join&gt;</literal> element, it is possible to map "
"properties of one class to several tables, when there's a 1-to-1 "
"relationship between the tables."
msgstr ""
"<literal>&lt;join&gt;</literal> 要素を使うことで、 １つのクラスのプロパティを"
"いくつものテーブルにマッピングすることができます。"

#. Tag: programlisting
#: basic_mapping.xml:2195
#, no-c-format
msgid ""
"<![CDATA[<join\n"
"        table=\"tablename\"\n"
"        schema=\"owner\"\n"
"        catalog=\"catalog\"\n"
"        fetch=\"join|select\"\n"
"        inverse=\"true|false\"\n"
"        optional=\"true|false\">\n"
"\n"
"        <key ... />\n"
"\n"
"        <property ... />\n"
"        ...\n"
"</join>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2199
#, no-c-format
msgid "<literal>table</literal>: The name of the joined table."
msgstr "<literal>table</literal> :結合したテーブルの名前"

#. Tag: para
#: basic_mapping.xml:2216
#, no-c-format
msgid ""
"<literal>fetch</literal> (optional - defaults to <literal>join</literal>): "
"If set to <literal>join</literal>, the default, Hibernate will use an inner "
"join to retrieve a <literal>&lt;join&gt;</literal> defined by a class or its "
"superclasses and an outer join for a <literal>&lt;join&gt;</literal> defined "
"by a subclass. If set to <literal>select</literal> then Hibernate will use a "
"sequential select for a <literal>&lt;join&gt;</literal> defined on a "
"subclass, which will be issued only if a row turns out to represent an "
"instance of the subclass. Inner joins will still be used to retrieve a "
"<literal>&lt;join&gt;</literal> defined by the class and its superclasses."
msgstr ""
"<literal>fetch</literal> (オプション - デフォルトは <literal>join</"
"literal> ): <literal>join</literal> を設定した場合、 Hibernateはデフォルト"
"で、クラスやスーパークラスで定義された <literal>&lt;join&gt;</literal> を検索"
"するのに内部結合を使い、サブクラスで定義された <literal>&lt;join&gt;</"
"literal> を検索するのに外部結合を使います。 <literal>select</literal> を設定"
"した場合には、 Hibernateはサブクラスで定義された <literal>&lt;join&gt;</"
"literal> の選択に順次選択を使います。この場合、 行がサブクラスのインスタンス"
"を代表することがわかった場合にのみ発行されます。 内部結合はクラスやそのスー"
"パークラスで定義された <literal>&lt;join&gt;</literal> を検索 するために使用"
"します。"

#. Tag: para
#: basic_mapping.xml:2229
#, no-c-format
msgid ""
"<literal>inverse</literal> (optional - defaults to <literal>false</"
"literal>): If enabled, Hibernate will not try to insert or update the "
"properties defined by this join."
msgstr ""
"<literal>inverse</literal> (オプション - デフォルトは <literal>false</"
"literal> ): もし可能であれば、Hibernateはこの結合で定義されているプロパティに"
"対し 挿入や更新を行いません。"

#. Tag: para
#: basic_mapping.xml:2236
#, no-c-format
msgid ""
"<literal>optional</literal> (optional - defaults to <literal>false</"
"literal>): If enabled, Hibernate will insert a row only if the properties "
"defined by this join are non-null and will always use an outer join to "
"retrieve the properties."
msgstr ""
"<literal>optional</literal> (オプション - デフォルトは <literal>false</"
"literal> ): もし可能であれば、Hibernateはこの結合で定義されたプロパティがnull"
"でない場合にのみ 行を挿入し、そのプロパティの検索には常に外部結合を使用しま"
"す。"

#. Tag: para
#: basic_mapping.xml:2245
#, no-c-format
msgid ""
"For example, the address information for a person can be mapped to a "
"separate table (while preserving value type semantics for all properties):"
msgstr ""
"例えば人のアドレスの情報を分離したテーブルにマッピングすることが可能です (す"
"べてのプロパティに対して値型のセマンティクスを保持します)。"

#. Tag: programlisting
#: basic_mapping.xml:2250
#, no-c-format
msgid ""
"<![CDATA[<class name=\"Person\"\n"
"    table=\"PERSON\">\n"
"\n"
"    <id name=\"id\" column=\"PERSON_ID\">...</id>\n"
"\n"
"    <join table=\"ADDRESS\">\n"
"        <key column=\"ADDRESS_ID\"/>\n"
"        <property name=\"address\"/>\n"
"        <property name=\"zip\"/>\n"
"        <property name=\"country\"/>\n"
"    </join>\n"
"    ...]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2252
#, no-c-format
msgid ""
"This feature is often only useful for legacy data models, we recommend fewer "
"tables than classes and a fine-grained domain model. However, it is useful "
"for switching between inheritance mapping strategies in a single hierarchy, "
"as explained later."
msgstr ""
"この特徴はしばしばレガシーデータモデルに対してのみ有用ですが、 クラスよりも少"
"ないテーブルと、きめの細かいドメインモデルを推奨します。 しかし後で説明するよ"
"うに、１つのクラス階層で継承のマッピング戦略を切り替える時には有用です。"

#. Tag: title
#: basic_mapping.xml:2262
#, no-c-format
msgid "<title>key</title>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2264
#, no-c-format
msgid ""
"We've seen the <literal>&lt;key&gt;</literal> element crop up a few times "
"now. It appears anywhere the parent mapping element defines a join to a new "
"table, and defines the foreign key in the joined table, that references the "
"primary key of the original table."
msgstr ""
"今まで何度か <literal>&lt;key&gt;</literal> 要素が出てきました。 この要素は新"
"しいテーブルへの結合を定義したり、 結合テーブルで外部キーを定義したりする親要"
"素のどこにでも現れ、 オリジナルテーブルの主キーを参照します。"

#. Tag: programlisting
#: basic_mapping.xml:2280
#, no-c-format
msgid ""
"<![CDATA[<key\n"
"        column=\"columnname\"\n"
"        on-delete=\"noaction|cascade\"\n"
"        property-ref=\"propertyName\"\n"
"        not-null=\"true|false\"\n"
"        update=\"true|false\"\n"
"        unique=\"true|false\"\n"
"/>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2291
#, no-c-format
msgid ""
"<literal>on-delete</literal> (optional, defaults to <literal>noaction</"
"literal>): Specifies whether the foreign key constraint has database-level "
"cascade delete enabled."
msgstr ""
"<literal>on-delete</literal> (オプション, デフォルトは <literal>noaction</"
"literal>): 外部キー制約がデータベースレベルでカスケード削除が可能かどうかを指"
"定します。"

#. Tag: para
#: basic_mapping.xml:2298
#, no-c-format
msgid ""
"<literal>property-ref</literal> (optional): Specifies that the foreign key "
"refers to columns that are not the primary key of the orginal table. "
"(Provided for legacy data.)"
msgstr ""
"<literal>property-ref</literal> (オプション): オリジナルテーブルの主キーでは"
"ないカラムを参照する外部キーを指定します (レガシーデータに対して提供されま"
"す)。"

#. Tag: para
#: basic_mapping.xml:2305
#, no-c-format
msgid ""
"<literal>not-null</literal> (optional): Specifies that the foreign key "
"columns are not nullable (this is implied whenever the foreign key is also "
"part of the primary key)."
msgstr ""
"<literal>not-null</literal> (オプション): 外部キーカラムがnull値を許容しない"
"ことを指定します (このことは外部キーが主キーの一部であることを暗黙的に示しま"
"す)。"

#. Tag: para
#: basic_mapping.xml:2312
#, no-c-format
msgid ""
"<literal>update</literal> (optional): Specifies that the foreign key should "
"never be updated (this is implied whenever the foreign key is also part of "
"the primary key)."
msgstr ""
"<literal>update</literal> (オプション): 外部キーを決して更新してはならないこ"
"とを指定します (このことは外部キーが主キーの一部であることを暗黙的に示しま"
"す)。"

#. Tag: para
#: basic_mapping.xml:2319
#, no-c-format
msgid ""
"<literal>unique</literal> (optional): Specifies that the foreign key should "
"have a unique constraint (this is implied whenever the foreign key is also "
"the primary key)."
msgstr ""
"<literal>unique</literal> (オプション): 外部キーがユニーク制約を持つべきであ"
"ることを指定します (このことは外部キーが主キーの一部であることを暗黙的に示し"
"ます)。"

#. Tag: para
#: basic_mapping.xml:2327
#, no-c-format
msgid ""
"We recommend that for systems where delete performance is important, all "
"keys should be defined <literal>on-delete=\"cascade\"</literal>, and "
"Hibernate will use a database-level <literal>ON CASCADE DELETE</literal> "
"constraint, instead of many individual <literal>DELETE</literal> statements. "
"Be aware that this feature bypasses Hibernate's usual optimistic locking "
"strategy for versioned data."
msgstr ""
"削除のパフォーマンスが重要であるシステムには、 すべてのキーを <literal>on-"
"delete=\"cascade\"</literal> と定義することを推奨します。 そうすることで"
"Hibernateは、<literal>DELETE</literal> 文を毎回発行する代わりに、 データベー"
"スレベルの <literal>ON CASCADE DELETE</literal> 制約を使用します。 この特徴は"
"バージョン付けられたデータに対するHibernateの通常の楽観的ロック戦略を 無視す"
"るということに注意してください。"

#. Tag: para
#: basic_mapping.xml:2335
#, no-c-format
msgid ""
"The <literal>not-null</literal> and <literal>update</literal> attributes are "
"useful when mapping a unidirectional one to many association. If you map a "
"unidirectional one to many to a non-nullable foreign key, you "
"<emphasis>must</emphasis> declare the key column using <literal>&lt;key not-"
"null=\"true\"&gt;</literal>."
msgstr ""
"<literal>not-null</literal> と <literal>update</literal> 属性は、単方向一対多"
"関連の時には有用です。 単方向一対多関連をnullを許容しない外部キーにマッピング"
"するときは、 <literal>&lt;key not-null=\"true\"&gt;</literal> を使ってキーカ"
"ラムを宣言 <emphasis> しなくてはなりません</emphasis> 。"

#. Tag: title
#: basic_mapping.xml:2345
#, no-c-format
msgid "column and formula elements"
msgstr "column と formula 要素"

#. Tag: para
#: basic_mapping.xml:2346
#, no-c-format
msgid ""
"Any mapping element which accepts a <literal>column</literal> attribute will "
"alternatively accept a <literal>&lt;column&gt;</literal> subelement. "
"Likewise, <literal>&lt;formula&gt;</literal> is an alternative to the "
"<literal>formula</literal> attribute."
msgstr ""
"<literal>column</literal> 属性を記述できる任意のマッピング要素はまた、 "
"<literal>&lt;column&gt;</literal> サブ要素も記述できます。 同様に "
"<literal>&lt;formula&gt;</literal> も <literal>formula</literal> 属性の代替手"
"段です。"

#. Tag: programlisting
#: basic_mapping.xml:2352
#, no-c-format
msgid ""
"<![CDATA[<column\n"
"        name=\"column_name\"\n"
"        length=\"N\"\n"
"        precision=\"N\"\n"
"        scale=\"N\"\n"
"        not-null=\"true|false\"\n"
"        unique=\"true|false\"\n"
"        unique-key=\"multicolumn_unique_key_name\"\n"
"        index=\"index_name\"\n"
"        sql-type=\"sql_type_name\"\n"
"        check=\"SQL expression\"\n"
"        default=\"SQL expression\"/>]]>"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2354
#, no-c-format
msgid "<![CDATA[<formula>SQL expression</formula>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2356
#, no-c-format
msgid ""
"<literal>column</literal> and <literal>formula</literal> attributes may even "
"be combined within the same property or association mapping to express, for "
"example, exotic join conditions."
msgstr ""
"同じプロパティや関連のマッピングの中で、 <literal>column</literal> と "
"<literal>formula</literal> 属性を組み合わせることができます。 例えば、特殊な"
"結合条件などです。"

#. Tag: programlisting
#: basic_mapping.xml:2362
#, no-c-format
msgid ""
"<![CDATA[<many-to-one name=\"homeAddress\" class=\"Address\"\n"
"        insert=\"false\" update=\"false\">\n"
"    <column name=\"person_id\" not-null=\"true\" length=\"10\"/>\n"
"    <formula>'MAILING'</formula>\n"
"</many-to-one>]]>"
msgstr ""

#. Tag: title
#: basic_mapping.xml:2367
#, no-c-format
msgid "import"
msgstr "import"

#. Tag: para
#: basic_mapping.xml:2369
#, no-c-format
msgid ""
"Suppose your application has two persistent classes with the same name, and "
"you don't want to specify the fully qualified (package) name in Hibernate "
"queries. Classes may be \"imported\" explicitly, rather than relying upon "
"<literal>auto-import=\"true\"</literal>. You may even import classes and "
"interfaces that are not explicitly mapped."
msgstr ""
"アプリケーションに同じ名前の2つの永続クラスがあり、 Hibernateクエリで完全修飾"
"された（パッケージの）名前を指定したくないと仮定します。 そのような場合は "
"<literal>auto-import=\"true\"</literal> に頼らず、 クラスが「インポート」され"
"たものであると明示できます。 明示的にマッピングされていないクラスやインター"
"フェイスでさえもインポートできます。"

#. Tag: programlisting
#: basic_mapping.xml:2376
#, no-c-format
msgid "<![CDATA[<import class=\"java.lang.Object\" rename=\"Universe\"/>]]>"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2383
#, no-c-format
msgid ""
"<![CDATA[<import\n"
"        class=\"ClassName\"\n"
"        rename=\"ShortName\"\n"
"/>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2386
#, no-c-format
msgid ""
"<literal>class</literal>: The fully qualified class name of of any Java "
"class."
msgstr "<literal>class</literal>：Javaクラスの完全修飾されたクラス名。"

#. Tag: para
#: basic_mapping.xml:2391
#, no-c-format
msgid ""
"<literal>rename</literal> (optional - defaults to the unqualified class "
"name): A name that may be used in the query language."
msgstr ""
"<literal>rename</literal>（オプション - デフォルトは修飾されていないクラス"
"名）： クエリ言語で使われる名前。"

#. Tag: title
#: basic_mapping.xml:2402
#, no-c-format
msgid "<title>any</title>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2404
#, no-c-format
msgid ""
"There is one further type of property mapping. The <literal>&lt;any&gt;</"
"literal> mapping element defines a polymorphic association to classes from "
"multiple tables. This type of mapping always requires more than one column. "
"The first column holds the type of the associated entity. The remaining "
"columns hold the identifier. It is impossible to specify a foreign key "
"constraint for this kind of association, so this is most certainly not meant "
"as the usual way of mapping (polymorphic) associations. You should use this "
"only in very special cases (eg. audit logs, user session data, etc)."
msgstr ""
"プロパティマッピングにはさらにもう1つの型があります。 <literal>&lt;any&gt;</"
"literal> マッピング要素は、 複数のテーブルからクラスへのポリモーフィックな関"
"連を定義します。 この型のマッピングには必ず複数のカラムが必要です。1番目のカ"
"ラムは関連エンティティの型を保持します。 残りのカラムは識別子を保持します。こ"
"の種類の関連には外部キー制約を指定することはできません。 そのためこれは最も使"
"われることのない（ポリモーフィックな）関連のマッピング方法です。 非常に特別な"
"場合（例えば、検査ログやユーザセッションデータなど)に限って、これを使うべきで"
"す。"

#. Tag: para
#: basic_mapping.xml:2414
#, no-c-format
msgid ""
"The <literal>meta-type</literal> attribute lets the application specify a "
"custom type that maps database column values to persistent classes which "
"have identifier properties of the type specified by <literal>id-type</"
"literal>. You must specify the mapping from values of the meta-type to class "
"names."
msgstr ""
"<literal>meta-type</literal> により、 アプリケーションはカスタム型を指定でき"
"ます。このカスタム型は データベースカラムの値を、<literal>id-type</literal> "
"で指定した型の 識別子プロパティを持った永続クラスへマッピングします。 meta-"
"typeの値からクラス名へのマッピングを指定しなければなりません。"

#. Tag: programlisting
#: basic_mapping.xml:2421
#, no-c-format
msgid ""
"<![CDATA[<any name=\"being\" id-type=\"long\" meta-type=\"string\">\n"
"    <meta-value value=\"TBL_ANIMAL\" class=\"Animal\"/>\n"
"    <meta-value value=\"TBL_HUMAN\" class=\"Human\"/>\n"
"    <meta-value value=\"TBL_ALIEN\" class=\"Alien\"/>\n"
"    <column name=\"table_name\"/>\n"
"    <column name=\"id\"/>\n"
"</any>]]>"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2432
#, no-c-format
msgid ""
"<![CDATA[<any\n"
"        name=\"propertyName\"\n"
"        id-type=\"idtypename\"\n"
"        meta-type=\"metatypename\"\n"
"        cascade=\"cascade_style\"\n"
"        access=\"field|property|ClassName\"\n"
"        optimistic-lock=\"true|false\"\n"
">\n"
"        <meta-value ... />\n"
"        <meta-value ... />\n"
"        .....\n"
"        <column .... />\n"
"        <column .... />\n"
"        .....\n"
"</any>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2435
#, no-c-format
msgid "<literal>name</literal>: the property name."
msgstr "<literal>name</literal>：プロパティ名。"

#. Tag: para
#: basic_mapping.xml:2440
#, no-c-format
msgid "<literal>id-type</literal>: the identifier type."
msgstr "<literal>id-type</literal>：識別子の型。"

#. Tag: para
#: basic_mapping.xml:2445
#, no-c-format
msgid ""
"<literal>meta-type</literal> (optional - defaults to <literal>string</"
"literal>): Any type that is allowed for a discriminator mapping."
msgstr ""
"<literal>meta-type</literal>（オプション - デフォルトは <literal>string</"
"literal> ）： ディスクリミネータマッピングで許された型"

#. Tag: para
#: basic_mapping.xml:2451
#, no-c-format
msgid ""
"<literal>cascade</literal> (optional- defaults to <literal>none</literal>): "
"the cascade style."
msgstr ""
"<literal>cascade</literal>（オプション - デフォルトは <literal>none</"
"literal> ）： カスケードのスタイル。"

#. Tag: para
#: basic_mapping.xml:2463
#, no-c-format
msgid ""
"<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
"literal>): Specifies that updates to this property do or do not require "
"acquisition of the optimistic lock. In other words, define if a version "
"increment should occur if this property is dirty."
msgstr ""
"<literal>optimistic-lock</literal> (オプション - デフォルトは <literal>true</"
"literal> ): このプロパティの更新に楽観ロックの取得を要求するかどうかを指定し"
"ます。 言い換えれば、このプロパティがダーティであるときにバージョンを増やすべ"
"きかを定義します。"

#. Tag: title
#: basic_mapping.xml:2478
#, no-c-format
msgid "Hibernate Types"
msgstr "Hibernateの型"

#. Tag: title
#: basic_mapping.xml:2481
#, no-c-format
msgid "Entities and values"
msgstr "エンティティと値"

#. Tag: para
#: basic_mapping.xml:2483
#, no-c-format
msgid ""
"To understand the behaviour of various Java language-level objects with "
"respect to the persistence service, we need to classify them into two groups:"
msgstr ""
"永続サービスに関わる様々なJava言語レベルのオブジェクトの振る舞いを理解するた"
"めには、 オブジェクトを2つのグループに分ける必要があります："

#. Tag: para
#: basic_mapping.xml:2488
#, no-c-format
msgid ""
"An <emphasis>entity</emphasis> exists independently of any other objects "
"holding references to the entity. Contrast this with the usual Java model "
"where an unreferenced object is garbage collected. Entities must be "
"explicitly saved and deleted (except that saves and deletions may be "
"<emphasis>cascaded</emphasis> from a parent entity to its children). This is "
"different from the ODMG model of object persistence by reachablity - and "
"corresponds more closely to how application objects are usually used in "
"large systems. Entities support circular and shared references. They may "
"also be versioned."
msgstr ""
"<emphasis> エンティティ</emphasis> はエンティティへの参照を保持する、 他のす"
"べてのオブジェクトから独立して存在します。 参照されないオブジェクトがガベージ"
"コレクトされてしまう性質を持つ通常のJavaモデルと、 これを比べてみてくださ"
"い。 （親エンティティから子へ、セーブと削除が <emphasis>カスケード</"
"emphasis> されうることを除いて） エンティティは明示的にセーブまたは削除されな"
"ければなりません。 これは到達可能性によるオブジェクト永続化のODMGモデルとは異"
"なっています。 大規模なシステムでアプリケーションオブジェクトが普通どのように"
"使われるかにより密接に対応します。 エンティティは循環と参照の共有をサポートし"
"ます。 またそれらはバージョン付けすることもできます。"

#. Tag: para
#: basic_mapping.xml:2499
#, no-c-format
msgid ""
"An entity's persistent state consists of references to other entities and "
"instances of <emphasis>value</emphasis> types. Values are primitives, "
"collections (not what's inside a collection), components and certain "
"immutable objects. Unlike entities, values (in particular collections and "
"components) <emphasis>are</emphasis> persisted and deleted by reachability. "
"Since value objects (and primitives) are persisted and deleted along with "
"their containing entity they may not be independently versioned. Values have "
"no independent identity, so they cannot be shared by two entities or "
"collections."
msgstr ""
"エンティティの永続状態は他のエンティティや <emphasis>値</emphasis> 型の イン"
"スタンスへの参照から構成されます。 値はプリミティブ、コレクション(コレクショ"
"ンの内部ではなく)、 コンポーネント、不変オブジェクトです。 エンティティとは違"
"い、値は（特にコレクションとコンポーネントにおいて）、 到達可能性による永続化"
"や削除が <emphasis>行われます</emphasis> 。 値オブジェクト（とプリミティブ）"
"は、包含するエンティティと一緒に永続化や削除が行われるので、 それらを独立に"
"バージョン付けすることはできません。 値には独立したアイデンティティがないの"
"で、 複数のエンティティやコレクションがこれを共有することはできません。"

#. Tag: para
#: basic_mapping.xml:2510
#, no-c-format
msgid ""
"Up until now, we've been using the term \"persistent class\" to refer to "
"entities. We will continue to do that. Strictly speaking, however, not all "
"user-defined classes with persistent state are entities. A "
"<emphasis>component</emphasis> is a user defined class with value semantics. "
"A Java property of type <literal>java.lang.String</literal> also has value "
"semantics. Given this definition, we can say that all types (classes) "
"provided by the JDK have value type semantics in Java, while user-defined "
"types may be mapped with entity or value type semantics. This decision is up "
"to the application developer. A good hint for an entity class in a domain "
"model are shared references to a single instance of that class, while "
"composition or aggregation usually translates to a value type."
msgstr ""
"これまで「永続クラス」という言葉をエンティティの意味で使ってきました。 これか"
"らもそうしていきます。 厳密に言うと、永続状態を持つユーザ定義のクラスのすべて"
"が エンティティというわけではありません。 <emphasis>コンポーネント</"
"emphasis> は値のセマンティクスを持つユーザ定義クラスです。 <literal>java."
"lang.String</literal> 型のプロパティもまた値のセマンティクスを持ちます。 定義"
"するなら、JDKで提供されているすべてのJavaの型(クラス)が値のセマンティクスを持"
"つといえます。 一方ユーザ定義型は、エンティティや値型のセマンティクスとともに"
"マッピングできます。 この決定はアプリケーション開発者次第です。 そのクラスの"
"１つのインスタンスへの共有参照は、 ドメインモデル内のエンティティクラスに対す"
"る良いヒントになります。 一方合成集約や集約は、通常値型へ変換されます。"

#. Tag: para
#: basic_mapping.xml:2524
#, no-c-format
msgid "We'll revisit both concepts throughout the documentation."
msgstr "本ドキュメントを通して、何度もこの概念を取り上げます。"

#. Tag: para
#: basic_mapping.xml:2528
#, no-c-format
msgid ""
"The challenge is to map the Java type system (and the developers' definition "
"of entities and value types) to the SQL/database type system. The bridge "
"between both systems is provided by Hibernate: for entities we use "
"<literal>&lt;class&gt;</literal>, <literal>&lt;subclass&gt;</literal> and so "
"on. For value types we use <literal>&lt;property&gt;</literal>, <literal>&lt;"
"component&gt;</literal>, etc, usually with a <literal>type</literal> "
"attribute. The value of this attribute is the name of a Hibernate "
"<emphasis>mapping type</emphasis>. Hibernate provides many mappings (for "
"standard JDK value types) out of the box. You can write your own mapping "
"types and implement your custom conversion strategies as well, as you'll see "
"later."
msgstr ""
"Java型のシステム(もしくは開発者が定義したエンティティと値型)を SQL/データベー"
"ス型のシステムにマッピングすることは難しいです。 Hibernateは２つのシステムの"
"架け橋を提供します。 エンティティに対しては <literal>&lt;class&gt;</literal> "
"や <literal>&lt;subclass&gt;</literal> などを使用します。 値型に対しては "
"<literal>&lt;property&gt;</literal> や <literal>&lt;component&gt;</literal> "
"などを、通常 <literal>type</literal> とともに使います。 この属性の値は"
"Hibernateの <emphasis>マッピング型</emphasis> の名前です。 Hibernateは(標準"
"JDKの値型に対して)多くの自由なマッピングを提供します。 後で見るように、自身の"
"マッピング型を記述し、同様にカスタムの変換戦略を実装することができます。"

#. Tag: para
#: basic_mapping.xml:2541
#, no-c-format
msgid "All built-in Hibernate types except collections support null semantics."
msgstr ""
"コレクションを除く組み込みのHibernateの型はすべて、nullセマンティクスをサポー"
"トします。"

#. Tag: title
#: basic_mapping.xml:2548
#, no-c-format
msgid "Basic value types"
msgstr "基本的な型"

#. Tag: para
#: basic_mapping.xml:2550
#, fuzzy, no-c-format
msgid ""
"The built-in <emphasis>basic mapping types</emphasis> may be roughly "
"categorized into"
msgstr ""
"組み込みの <emphasis>基本的なマッピング型</emphasis> は大まかに以下のように分"
"けられます。 <placeholder-1/>"

#. Tag: literal
#: basic_mapping.xml:2555
#, no-c-format
msgid ""
"integer, long, short, float, double, character, byte, boolean, yes_no, "
"true_false"
msgstr ""
"integer, long, short, float, double, character, byte, boolean, yes_no, "
"true_false"

#. Tag: para
#: basic_mapping.xml:2558
#, no-c-format
msgid ""
"Type mappings from Java primitives or wrapper classes to appropriate (vendor-"
"specific) SQL column types. <literal>boolean, yes_no</literal> and "
"<literal>true_false</literal> are all alternative encodings for a Java "
"<literal>boolean</literal> or <literal>java.lang.Boolean</literal>."
msgstr ""
"Javaのプリミティブやラッパークラスから適切な（ベンダー固有の） SQLカラム型へ"
"の型マッピング。 <literal>boolean, yes_no</literal> と <literal>true_false</"
"literal> は、 すべてJavaの <literal>boolean</literal> または <literal>java."
"lang.Boolean</literal> の代替エンコードです。"

#. Tag: literal
#: basic_mapping.xml:2567
#, no-c-format
msgid "string"
msgstr "string"

#. Tag: para
#: basic_mapping.xml:2569
#, no-c-format
msgid ""
"A type mapping from <literal>java.lang.String</literal> to <literal>VARCHAR</"
"literal> (or Oracle <literal>VARCHAR2</literal>)."
msgstr ""
"<literal>java.lang.String</literal> から <literal>VARCHAR</literal> （または"
"Oracleの <literal>VARCHAR2</literal> ）への型マッピング。"

#. Tag: literal
#: basic_mapping.xml:2576
#, no-c-format
msgid "date, time, timestamp"
msgstr "date, time, timestamp"

#. Tag: para
#: basic_mapping.xml:2578
#, no-c-format
msgid ""
"Type mappings from <literal>java.util.Date</literal> and its subclasses to "
"SQL types <literal>DATE</literal>, <literal>TIME</literal> and "
"<literal>TIMESTAMP</literal> (or equivalent)."
msgstr ""
"<literal>java.util.Date</literal> とそのサブクラスからSQL型の <literal>DATE</"
"literal>, <literal>TIME</literal> , <literal>TIMESTAMP</literal> （またはそれ"
"らと等価なもの） への型マッピング。"

#. Tag: literal
#: basic_mapping.xml:2586
#, no-c-format
msgid "calendar, calendar_date"
msgstr "calendar, calendar_date"

#. Tag: para
#: basic_mapping.xml:2588
#, no-c-format
msgid ""
"Type mappings from <literal>java.util.Calendar</literal> to SQL types "
"<literal>TIMESTAMP</literal> and <literal>DATE</literal> (or equivalent)."
msgstr ""
"<literal>java.util.Calendar</literal> からSQL型 の「 <literal>TIMESTAMP</"
"literal> , <literal>DATE</literal> (またはそれらと等価なもの）への型マッピン"
"グ。"

#. Tag: literal
#: basic_mapping.xml:2596
#, no-c-format
msgid "big_decimal, big_integer"
msgstr "big_decimal, big_integer"

#. Tag: para
#: basic_mapping.xml:2598
#, no-c-format
msgid ""
"Type mappings from <literal>java.math.BigDecimal</literal> and <literal>java."
"math.BigInteger</literal> to <literal>NUMERIC</literal> (or Oracle "
"<literal>NUMBER</literal>)."
msgstr ""
"<literal>java.math.BigDecimal</literal> と <literal>java.math.BigInteger</"
"literal> から <literal>NUMERIC</literal>（またはOracleの <literal>NUMBER</"
"literal> ）への型マッピング。"

#. Tag: literal
#: basic_mapping.xml:2606
#, no-c-format
msgid "locale, timezone, currency"
msgstr "locale, timezone, currency"

#. Tag: para
#: basic_mapping.xml:2608
#, no-c-format
msgid ""
"Type mappings from <literal>java.util.Locale</literal>, <literal>java.util."
"TimeZone</literal> and <literal>java.util.Currency</literal> to "
"<literal>VARCHAR</literal> (or Oracle <literal>VARCHAR2</literal>). "
"Instances of <literal>Locale</literal> and <literal>Currency</literal> are "
"mapped to their ISO codes. Instances of <literal>TimeZone</literal> are "
"mapped to their <literal>ID</literal>."
msgstr ""
"<literal>java.util.Locale</literal> , <literal>java.util.TimeZone</"
"literal> , <literal>java.util.Currency</literal> から <literal>VARCHAR</"
"literal> （またはOracleの <literal>VARCHAR2</literal> ）への型マッピング。 "
"<literal>Locale</literal> と <literal>Currency</literal> のインスタンスは、 "
"それらのISOコードにマッピングされます。 <literal>TimeZone</literal> のインス"
"タンスは、 それらの <literal>ID</literal> にマッピングされます。"

#. Tag: literal
#: basic_mapping.xml:2620
#, fuzzy, no-c-format
msgid "<literal>class</literal>"
msgstr "<literal>all</literal> すべてのカラムをチェックします。"

#. Tag: para
#: basic_mapping.xml:2622
#, no-c-format
msgid ""
"A type mapping from <literal>java.lang.Class</literal> to <literal>VARCHAR</"
"literal> (or Oracle <literal>VARCHAR2</literal>). A <literal>Class</literal> "
"is mapped to its fully qualified name."
msgstr ""
"<literal>java.lang.Class</literal> から <literal>VARCHAR</literal> （または"
"Oracleの <literal>VARCHAR2</literal> ）への型マッピング。 <literal>Class</"
"literal> はその完全修飾された名前にマッピングされます。"

#. Tag: literal
#: basic_mapping.xml:2630
#, no-c-format
msgid "binary"
msgstr "binary"

#. Tag: para
#: basic_mapping.xml:2632
#, no-c-format
msgid "Maps byte arrays to an appropriate SQL binary type."
msgstr "バイト配列は、適切なSQLのバイナリ型にマッピングされます。"

#. Tag: literal
#: basic_mapping.xml:2638
#, no-c-format
msgid "text"
msgstr "text"

#. Tag: para
#: basic_mapping.xml:2640
#, no-c-format
msgid ""
"Maps long Java strings to a SQL <literal>CLOB</literal> or <literal>TEXT</"
"literal> type."
msgstr ""
"長いJava文字列は、SQLの <literal>CLOB</literal> または <literal>TEXT</"
"literal> 型にマッピングされます。"

#. Tag: literal
#: basic_mapping.xml:2647
#, no-c-format
msgid "serializable"
msgstr "serializable"

#. Tag: para
#: basic_mapping.xml:2649
#, no-c-format
msgid ""
"Maps serializable Java types to an appropriate SQL binary type. You may also "
"indicate the Hibernate type <literal>serializable</literal> with the name of "
"a serializable Java class or interface that does not default to a basic type."
msgstr ""
"シリアライズ可能なJava型は、適切なSQLのバイナリ型にマッピングされます。 デ"
"フォルトで基本型ではないシリアライズ可能なJavaクラスや インターフェイスの名前"
"を指定することで、 Hibernateの型を <literal>serializable</literal> とすること"
"もできます。"

#. Tag: literal
#: basic_mapping.xml:2658
#, no-c-format
msgid "clob, blob"
msgstr "clob, blob"

#. Tag: para
#: basic_mapping.xml:2660
#, no-c-format
msgid ""
"Type mappings for the JDBC classes <literal>java.sql.Clob</literal> and "
"<literal>java.sql.Blob</literal>. These types may be inconvenient for some "
"applications, since the blob or clob object may not be reused outside of a "
"transaction. (Furthermore, driver support is patchy and inconsistent.)"
msgstr ""
"JDBCクラス <literal>java.sql.Clob</literal> と <literal>java.sql.Blob</"
"literal> に対する型マッピング。 blobやclobオブジェクトはトランザクションの外"
"では再利用できないため、 アプリケーションによっては不便かもしれません。 （さ"
"らにはドライバサポートが一貫していません。）"

#. Tag: literal
#: basic_mapping.xml:2670
#, no-c-format
msgid ""
"imm_date, imm_time, imm_timestamp, imm_calendar, imm_calendar_date, "
"imm_serializable, imm_binary"
msgstr ""
"imm_date, imm_time, imm_timestamp, imm_calendar, imm_calendar_date, "
"imm_serializable, imm_binary"

#. Tag: para
#: basic_mapping.xml:2674
#, no-c-format
msgid ""
"Type mappings for what are usually considered mutable Java types, where "
"Hibernate makes certain optimizations appropriate only for immutable Java "
"types, and the application treats the object as immutable. For example, you "
"should not call <literal>Date.setTime()</literal> for an instance mapped as "
"<literal>imm_timestamp</literal>. To change the value of the property, and "
"have that change made persistent, the application must assign a new "
"(nonidentical) object to the property."
msgstr ""
"ほとんどの場合に可変であるJavaの型に対する型マッピング。 Hibernateは不変な"
"Javaの型に対しては最適化を行い、 アプリケーションはそれを不変オブジェクトとし"
"て扱います。 例えば <literal>imm_timestamp</literal> としてマップしたインスタ"
"ンスに対して、 <literal>Date.setTime()</literal> を呼び出してはなりません。 "
"プロパティの値を変更しその変更を永続化するためには、 アプリケーションはプロパ"
"ティに対して新しい(同一でない)オブジェクトを割り当てなければなりません。"

#. Tag: para
#: basic_mapping.xml:2689
#, no-c-format
msgid ""
"Unique identifiers of entities and collections may be of any basic type "
"except <literal>binary</literal>, <literal>blob</literal> and <literal>clob</"
"literal>. (Composite identifiers are also allowed, see below.)"
msgstr ""
"エンティティとコレクションのユニークな識別子は、<literal>binary</literal> , "
"<literal>blob</literal> , <literal>clob</literal> を除く、どんな基本型でも構"
"いません。 （複合識別子でも構いません。以下を見てください。）"

#. Tag: para
#: basic_mapping.xml:2695
#, no-c-format
msgid ""
"The basic value types have corresponding <literal>Type</literal> constants "
"defined on <literal>org.hibernate.Hibernate</literal>. For example, "
"<literal>Hibernate.STRING</literal> represents the <literal>string</literal> "
"type."
msgstr ""
"基本的な値型には、<literal>org.hibernate.Hibernate</literal> で定義された "
"<literal>Type</literal> 定数がそれぞれあります。 例えば、<literal>Hibernate."
"STRING</literal> は <literal>string</literal> 型を表現しています。"

#. Tag: title
#: basic_mapping.xml:2704
#, no-c-format
msgid "Custom value types"
msgstr "カスタム型"

#. Tag: para
#: basic_mapping.xml:2706
#, no-c-format
msgid ""
"It is relatively easy for developers to create their own value types. For "
"example, you might want to persist properties of type <literal>java.lang."
"BigInteger</literal> to <literal>VARCHAR</literal> columns. Hibernate does "
"not provide a built-in type for this. But custom types are not limited to "
"mapping a property (or collection element) to a single table column. So, for "
"example, you might have a Java property <literal>getName()</literal>/"
"<literal>setName()</literal> of type <literal>java.lang.String</literal> "
"that is persisted to the columns <literal>FIRST_NAME</literal>, "
"<literal>INITIAL</literal>, <literal>SURNAME</literal>."
msgstr ""
"開発者が独自の値型を作成することは、比較的簡単です。 例えば、<literal>java."
"lang.BigInteger</literal> 型のプロパティを <literal>VARCHAR</literal> カラム"
"に永続化したいかもしれません。 Hibernateはこのための組み込み型を用意していま"
"せん。 しかしカスタム型は、プロパティ（またはコレクションの要素）を1つのテー"
"ブルカラムに マッピングするのに制限はありません。 そのため例えば、"
"<literal>java.lang.String</literal> 型の <literal>getName()</literal> / "
"<literal>setName()</literal> Javaプロパティを <literal>FIRST_NAME</"
"literal> , <literal>INITIAL</literal>, <literal>SURNAME</literal> カラムに永"
"続化できます。"

#. Tag: para
#: basic_mapping.xml:2717
#, no-c-format
msgid ""
"To implement a custom type, implement either <literal>org.hibernate."
"UserType</literal> or <literal>org.hibernate.CompositeUserType</literal> and "
"declare properties using the fully qualified classname of the type. Check "
"out <literal>org.hibernate.test.DoubleStringType</literal> to see the kind "
"of things that are possible."
msgstr ""
"カスタム型を実装するには、<literal>org.hibernate.UserType</literal> または "
"<literal>org.hibernate.CompositeUserType</literal> を実装し、 型の完全修飾さ"
"れた名前を使ってプロパティを定義します。 どのような種類のものが可能かを調べる"
"には、 <literal>org.hibernate.test.DoubleStringType</literal> を確認してくだ"
"さい。"

#. Tag: programlisting
#: basic_mapping.xml:2725
#, no-c-format
msgid ""
"<![CDATA[<property name=\"twoStrings\" type=\"org.hibernate.test."
"DoubleStringType\">\n"
"    <column name=\"first_string\"/>\n"
"    <column name=\"second_string\"/>\n"
"</property>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2727
#, no-c-format
msgid ""
"Notice the use of <literal>&lt;column&gt;</literal> tags to map a property "
"to multiple columns."
msgstr ""
"<literal>&lt;column&gt;</literal> タグで、 プロパティを複数のカラムへマッピン"
"グできることに注目してください。"

#. Tag: para
#: basic_mapping.xml:2732
#, no-c-format
msgid ""
"The <literal>CompositeUserType</literal>, <literal>EnhancedUserType</"
"literal>, <literal>UserCollectionType</literal>, and "
"<literal>UserVersionType</literal> interfaces provide support for more "
"specialized uses."
msgstr ""
"<literal>CompositeUserType</literal> , <literal>EnhancedUserType</literal> , "
"<literal>UserCollectionType</literal> , <literal>UserVersionType</literal> イ"
"ンターフェイスは、より特殊な使用法に対してのサポートを提供します。"

#. Tag: para
#: basic_mapping.xml:2738
#, no-c-format
msgid ""
"You may even supply parameters to a <literal>UserType</literal> in the "
"mapping file. To do this, your <literal>UserType</literal> must implement "
"the <literal>org.hibernate.usertype.ParameterizedType</literal> interface. "
"To supply parameters to your custom type, you can use the <literal>&lt;"
"type&gt;</literal> element in your mapping files."
msgstr ""
"マッピングファイル内で <literal>UserType</literal> へパラメータを提供できま"
"す。 このためには、<literal>UserType</literal> は <literal>org.hibernate."
"usertype.ParameterizedType</literal> を実装しなくてはなりません。 カスタム型"
"パラメータを提供するために、 マッピングファイル内で <literal>&lt;type&gt;</"
"literal> 要素を使用できます。"

#. Tag: programlisting
#: basic_mapping.xml:2746
#, no-c-format
msgid ""
"<![CDATA[<property name=\"priority\">\n"
"    <type name=\"com.mycompany.usertypes.DefaultValueIntegerType\">\n"
"        <param name=\"default\">0</param>\n"
"    </type>\n"
"</property>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2748
#, no-c-format
msgid ""
"The <literal>UserType</literal> can now retrieve the value for the parameter "
"named <literal>default</literal> from the <literal>Properties</literal> "
"object passed to it."
msgstr ""
"<literal>UserType</literal> は、 引数として渡された <literal>Properties</"
"literal> オブジェクトから、 <literal>default</literal> で指定したパラメータに"
"対する値を検索することができます。"

#. Tag: para
#: basic_mapping.xml:2753
#, no-c-format
msgid ""
"If you use a certain <literal>UserType</literal> very often, it may be "
"useful to define a shorter name for it. You can do this using the "
"<literal>&lt;typedef&gt;</literal> element. Typedefs assign a name to a "
"custom type, and may also contain a list of default parameter values if the "
"type is parameterized."
msgstr ""
"特定の <literal>UserType</literal> を頻繁に使用するならば、短い名前を定義する"
"と便利になるでしょう。 <literal>&lt;typedef&gt;</literal> 要素を使ってこのよ"
"うなことが行えます。 Typedefsはカスタム型に名前を割り当てます。 その型がパラ"
"メータを持つならば、 パラメータのデフォルト値のリストを含むこともできます。"

#. Tag: programlisting
#: basic_mapping.xml:2760
#, no-c-format
msgid ""
"<![CDATA[<typedef class=\"com.mycompany.usertypes.DefaultValueIntegerType\" "
"name=\"default_zero\">\n"
"    <param name=\"default\">0</param>\n"
"</typedef>]]>"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2762
#, no-c-format
msgid "<![CDATA[<property name=\"priority\" type=\"default_zero\"/>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2764
#, no-c-format
msgid ""
"It is also possible to override the parameters supplied in a typedef on a "
"case-by-case basis by using type parameters on the property mapping."
msgstr ""
"プロパティのマッピングで型パラメータを使うことで、 typedefで提供されたパラ"
"メータをその都度オーバーライドすることが可能です。"

#. Tag: para
#: basic_mapping.xml:2769
#, no-c-format
msgid ""
"Even though Hibernate's rich range of built-in types and support for "
"components means you will very rarely <emphasis>need</emphasis> to use a "
"custom type, it is nevertheless considered good form to use custom types for "
"(non-entity) classes that occur frequently in your application. For example, "
"a <literal>MonetaryAmount</literal> class is a good candidate for a "
"<literal>CompositeUserType</literal>, even though it could easily be mapped "
"as a component. One motivation for this is abstraction. With a custom type, "
"your mapping documents would be future-proofed against possible changes in "
"your way of representing monetary values."
msgstr ""
"Hibernateの幅広い組み込み型とコンポーネントに対するサポートは、 カスタム型を"
"めったに <emphasis>使わない</emphasis> ということを意味します。 それでもな"
"お、アプリケーションで頻出する(エンティティではない)クラスに対するカスタム型"
"の使用は、 よいやり方であるとみなされます。 例えば <literal>MonetaryAmount</"
"literal> クラスはコンポーネントとして簡単にマッピングできますが、 "
"<literal>CompositeUserType</literal> の良い候補です。 カスタム型を使用する動"
"機の1つは抽象化です。 カスタム型を使うことで、通貨をどのように表現しようとも "
"マッピングドキュメントは起こりうる変化に対応できます。"

#. Tag: title
#: basic_mapping.xml:2785
#, no-c-format
msgid "Mapping a class more than once"
msgstr "１つのクラスに１つ以上のマッピング"

#. Tag: para
#: basic_mapping.xml:2786
#, no-c-format
msgid ""
"It is possible to provide more than one mapping for a particular persistent "
"class. In this case you must specify an <emphasis>entity name</emphasis> do "
"disambiguate between instances of the two mapped entities. (By default, the "
"entity name is the same as the class name.) Hibernate lets you specify the "
"entity name when working with persistent objects, when writing queries, or "
"when mapping associations to the named entity."
msgstr ""
"ある永続クラスに、一つ以上のマッピングを提供することが出来ます。 この場合、"
"マッピングする２つのエンティティのインスタンスを明確にするために、 <emphasis>"
"エンティティ名</emphasis> を指定しなければなりません (デフォルトではエンティ"
"ティ名はクラス名と同じです。)。 永続オブジェクトを扱うとき、クエリを書き込む"
"とき、 指定されたエンティティへの関連をマッピングするときには、 Hibernateでは"
"エンティティ名を指定しなければなりません。"

#. Tag: programlisting
#: basic_mapping.xml:2794
#, no-c-format
msgid ""
"<![CDATA[<class name=\"Contract\" table=\"Contracts\"\n"
"        entity-name=\"CurrentContract\">\n"
"    ...\n"
"    <set name=\"history\" inverse=\"true\"\n"
"            order-by=\"effectiveEndDate desc\">\n"
"        <key column=\"currentContractId\"/>\n"
"        <one-to-many entity-name=\"HistoricalContract\"/>\n"
"    </set>\n"
"</class>\n"
"\n"
"<class name=\"Contract\" table=\"ContractHistory\"\n"
"        entity-name=\"HistoricalContract\">\n"
"    ...\n"
"    <many-to-one name=\"currentContract\"\n"
"            column=\"currentContractId\"\n"
"            entity-name=\"CurrentContract\"/>\n"
"</class>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2796
#, no-c-format
msgid ""
"Notice how associations are now specified using <literal>entity-name</"
"literal> instead of <literal>class</literal>."
msgstr ""
"関連が<literal>class</literal> の代わりに <literal>entity-name</literal> を"
"使って、 どのように指定されるのかに注目してください。"

#. Tag: title
#: basic_mapping.xml:2804
#, no-c-format
msgid "SQL quoted identifiers"
msgstr "バッククォートで囲んだ SQL 識別子"

#. Tag: para
#: basic_mapping.xml:2805
#, no-c-format
msgid ""
"You may force Hibernate to quote an identifier in the generated SQL by "
"enclosing the table or column name in backticks in the mapping document. "
"Hibernate will use the correct quotation style for the SQL <literal>Dialect</"
"literal> (usually double quotes, but brackets for SQL Server and backticks "
"for MySQL)."
msgstr ""
"マッピングドキュメントでテーブルやカラムの名前をバッククォートで囲むことで、 "
"Hibernateで生成されたSQL中の識別子を引用させることができます。 HibernateはSQL"
"の <literal>Dialect</literal> に対応する、正しい引用スタイルを使います （普通"
"はダブルクォートですが、SQL Serverではかぎ括弧、MySQLではバッククォートで"
"す）。"

#. Tag: programlisting
#: basic_mapping.xml:2812
#, no-c-format
msgid ""
"<![CDATA[<class name=\"LineItem\" table=\"`Line Item`\">\n"
"    <id name=\"id\" column=\"`Item Id`\"/><generator class=\"assigned\"/></"
"id>\n"
"    <property name=\"itemNumber\" column=\"`Item #`\"/>\n"
"    ...\n"
"</class>]]>"
msgstr ""

#. Tag: title
#: basic_mapping.xml:2818
#, no-c-format
msgid "Metadata alternatives"
msgstr "メタデータの代替手段"

#. Tag: para
#: basic_mapping.xml:2820
#, no-c-format
msgid ""
"XML isn't for everyone, and so there are some alternative ways to define O/R "
"mapping metadata in Hibernate."
msgstr ""
"XMLの記述以外に、 HibernateではO/Rマッピングのメタデータを定義する代替方法が"
"あります。"

#. Tag: title
#: basic_mapping.xml:2825
#, no-c-format
msgid "Using XDoclet markup"
msgstr "XDoclet マークアップの使用"

#. Tag: para
#: basic_mapping.xml:2827
#, no-c-format
msgid ""
"Many Hibernate users prefer to embed mapping information directly in "
"sourcecode using XDoclet <literal>@hibernate.tags</literal>. We will not "
"cover this approach in this document, since strictly it is considered part "
"of XDoclet. However, we include the following example of the <literal>Cat</"
"literal> class with XDoclet mappings."
msgstr ""
"多くのHibernateユーザはXDocletの <literal>@hibernate.tags</literal> を使っ"
"て、 ソースコード内に直接マッピング情報を埋め込むことを好みます。 これは厳密"
"に言えばXDocletの分野なので、本ドキュメントではこの方法を対象とはしません。 "
"しかしXDocletを使った以下の <literal>Cat</literal> マッピングの例を示します。"

#. Tag: programlisting
#: basic_mapping.xml:2834
#, no-c-format
msgid ""
"<![CDATA[package eg;\n"
"import java.util.Set;\n"
"import java.util.Date;\n"
"\n"
"/**\n"
" * @hibernate.class\n"
" *  table=\"CATS\"\n"
" */\n"
"public class Cat {\n"
"    private Long id; // identifier\n"
"    private Date birthdate;\n"
"    private Cat mother;\n"
"    private Set kittens\n"
"    private Color color;\n"
"    private char sex;\n"
"    private float weight;\n"
"\n"
"    /*\n"
"     * @hibernate.id\n"
"     *  generator-class=\"native\"\n"
"     *  column=\"CAT_ID\"\n"
"     */\n"
"    public Long getId() {\n"
"        return id;\n"
"    }\n"
"    private void setId(Long id) {\n"
"        this.id=id;\n"
"    }\n"
"\n"
"    /**\n"
"     * @hibernate.many-to-one\n"
"     *  column=\"PARENT_ID\"\n"
"     */\n"
"    public Cat getMother() {\n"
"        return mother;\n"
"    }\n"
"    void setMother(Cat mother) {\n"
"        this.mother = mother;\n"
"    }\n"
"\n"
"    /**\n"
"     * @hibernate.property\n"
"     *  column=\"BIRTH_DATE\"\n"
"     */\n"
"    public Date getBirthdate() {\n"
"        return birthdate;\n"
"    }\n"
"    void setBirthdate(Date date) {\n"
"        birthdate = date;\n"
"    }\n"
"    /**\n"
"     * @hibernate.property\n"
"     *  column=\"WEIGHT\"\n"
"     */\n"
"    public float getWeight() {\n"
"        return weight;\n"
"    }\n"
"    void setWeight(float weight) {\n"
"        this.weight = weight;\n"
"    }\n"
"\n"
"    /**\n"
"     * @hibernate.property\n"
"     *  column=\"COLOR\"\n"
"     *  not-null=\"true\"\n"
"     */\n"
"    public Color getColor() {\n"
"        return color;\n"
"    }\n"
"    void setColor(Color color) {\n"
"        this.color = color;\n"
"    }\n"
"    /**\n"
"     * @hibernate.set\n"
"     *  inverse=\"true\"\n"
"     *  order-by=\"BIRTH_DATE\"\n"
"     * @hibernate.collection-key\n"
"     *  column=\"PARENT_ID\"\n"
"     * @hibernate.collection-one-to-many\n"
"     */\n"
"    public Set getKittens() {\n"
"        return kittens;\n"
"    }\n"
"    void setKittens(Set kittens) {\n"
"        this.kittens = kittens;\n"
"    }\n"
"    // addKitten not needed by Hibernate\n"
"    public void addKitten(Cat kitten) {\n"
"        kittens.add(kitten);\n"
"    }\n"
"\n"
"    /**\n"
"     * @hibernate.property\n"
"     *  column=\"SEX\"\n"
"     *  not-null=\"true\"\n"
"     *  update=\"false\"\n"
"     */\n"
"    public char getSex() {\n"
"        return sex;\n"
"    }\n"
"    void setSex(char sex) {\n"
"        this.sex=sex;\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2836
#, no-c-format
msgid "See the Hibernate web site for more examples of XDoclet and Hibernate."
msgstr ""
"Hibernateのウェブサイトには、XDocletとHibernateに関するサンプルが多数ありま"
"す。"

#. Tag: title
#: basic_mapping.xml:2843
#, no-c-format
msgid "Using JDK 5.0 Annotations"
msgstr "JDK 5.0 アノテーションの使用"

#. Tag: para
#: basic_mapping.xml:2845
#, no-c-format
msgid ""
"JDK 5.0 introduced XDoclet-style annotations at the language level, type-"
"safe and checked at compile time. This mechnism is more powerful than "
"XDoclet annotations and better supported by tools and IDEs. IntelliJ IDEA, "
"for example, supports auto-completion and syntax highlighting of JDK 5.0 "
"annotations. The new revision of the EJB specification (JSR-220) uses JDK "
"5.0 annotations as the primary metadata mechanism for entity beans. "
"Hibernate3 implements the <literal>EntityManager</literal> of JSR-220 (the "
"persistence API), support for mapping metadata is available via the "
"<emphasis>Hibernate Annotations</emphasis> package, as a separate download. "
"Both EJB3 (JSR-220) and Hibernate3 metadata is supported."
msgstr ""
"JDK5.0ではタイプセーフかつコンパイル時にチェックできる、 言語レベルのXDoclet"
"スタイルのアノテーションを導入しました。 このメカニズムはXDocletのアノテー"
"ションよりも強力で、ツールやIDEも多くがサポートしています。 例えばIntelliJ "
"IDEAは、JDK5.0にアノテーションの自動補完と構文の強調表示をサポートしていま"
"す。 EJB仕様 (JSR-220)の新しいバージョンでは、エンティティビーンに対する主要"
"なメタデータメカニズムとして JDK5.0のアノテーションを使用しています。 "
"Hibernate3ではJSR-220 (永続化API)の <literal>EntityManager</literal> を実装"
"し、 メタデータマッピングに対するサポートは、 別ダウンロードの "
"<emphasis>Hibernate Annotations</emphasis> パッケージにより利用可能です。 こ"
"れはEJB3(JSR-220)とHibernate3のメタデータをどちらもサポートしています。"

#. Tag: para
#: basic_mapping.xml:2856
#, no-c-format
msgid "This is an example of a POJO class annotated as an EJB entity bean:"
msgstr "以下はEJBのエンティティビーンとして注釈されたPOJOクラスの例です。"

#. Tag: programlisting
#: basic_mapping.xml:2860
#, no-c-format
msgid ""
"<![CDATA[@Entity(access = AccessType.FIELD)\n"
"public class Customer implements Serializable {\n"
"\n"
"    @Id;\n"
"    Long id;\n"
"\n"
"    String firstName;\n"
"    String lastName;\n"
"    Date birthday;\n"
"\n"
"    @Transient\n"
"    Integer age;\n"
"\n"
"    @Embedded\n"
"    private Address homeAddress;\n"
"\n"
"    @OneToMany(cascade=CascadeType.ALL)\n"
"    @JoinColumn(name=\"CUSTOMER_ID\")\n"
"    Set<Order> orders;\n"
"\n"
"    // Getter/setter and business methods\n"
"}]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2862
#, no-c-format
msgid ""
"Note that support for JDK 5.0 Annotations (and JSR-220) is still work in "
"progress and not completed. Please refer to the Hibernate Annotations module "
"for more details."
msgstr ""
"JDK5.0のアノテーション(とJSR-220)のサポートは進行中の作業であり、完全ではない"
"ことに注意してください。 さらに詳しい情報はHibernateのアノテーション・モ"
"ジュールを参照してください。"

#. Tag: title
#: basic_mapping.xml:2871
#, no-c-format
msgid "Generated Properties"
msgstr "生成プロパティ"

#. Tag: para
#: basic_mapping.xml:2872
#, no-c-format
msgid ""
"Generated properties are properties which have their values generated by the "
"database. Typically, Hibernate applications needed to <literal>refresh</"
"literal> objects which contain any properties for which the database was "
"generating values. Marking properties as generated, however, lets the "
"application delegate this responsibility to Hibernate. Essentially, whenever "
"Hibernate issues an SQL INSERT or UPDATE for an entity which has defined "
"generated properties, it immediately issues a select afterwards to retrieve "
"the generated values."
msgstr ""
"生成プロパティとは、データベースによって生成された値を持つプロパティです。 通"
"常、Hibernateアプリケーションは、データベースが値を生成したプロパティを含むオ"
"ブジェクトを <literal>リフレッシュ</literal> する必要がありました。 しかし、"
"プロパティが生成されたということをマークすることで、 アプリケーションはリフ"
"レッシュの責任をHibernateに委譲します。 基本的に、生成プロパティを持つと定義"
"したエンティティに対して HibernateがINSERTやUPDATEのSQLを発行した後すぐに、 "
"生成された値を読み込むための SELECT SQL が発行されます。"

#. Tag: para
#: basic_mapping.xml:2881
#, no-c-format
msgid ""
"Properties marked as generated must additionally be non-insertable and non-"
"updateable. Only <link linkend=\"mapping-declaration-version\">versions</"
"link>, <link linkend=\"mapping-declaration-timestamp\">timestamps</link>, "
"and <link linkend=\"mapping-declaration-property\">simple properties</link> "
"can be marked as generated."
msgstr ""
"生成プロパティは、挿入不可能かつ更新不可能でなければなりません。 <xref "
"linkend=\"mapping-declaration-version\">versions</xref> 、 <xref linkend="
"\"mapping-declaration-timestamp\">timestamps</xref> 、 <xref linkend="
"\"mapping-declaration-property\">simple properties</xref> だけが生成されたと"
"マークできます。"

#. Tag: para
#: basic_mapping.xml:2888
#, no-c-format
msgid ""
"<literal>never</literal> (the default) - means that the given property value "
"is not generated within the database."
msgstr ""
"<literal>never</literal> (デフォルト) - 与えられたプロパティの値は、 データ"
"ベースから生成されないことを意味します。"

#. Tag: para
#: basic_mapping.xml:2892
#, no-c-format
msgid ""
"<literal>insert</literal> - states that the given property value is "
"generated on insert, but is not regenerated on subsequent updates. Things "
"like created-date would fall into this category. Note that even thought "
"<link linkend=\"mapping-declaration-version\">version</link> and <link "
"linkend=\"mapping-declaration-timestamp\">timestamp</link> properties can be "
"marked as generated, this option is not available there..."
msgstr ""
"<literal>insert</literal> - 与えられたプロパティの値は挿入時に生成されるが、 "
"続いて起こる更新時には生成されないこと示します。 作成された日付などは、このカ"
"テゴリに分類されます。 <xref linkend=\"mapping-declaration-version"
"\">version</xref> や <xref linkend=\"mapping-declaration-timestamp"
"\">timestamp</xref> の プロパティは生成されたとマークできますが、このオプショ"
"ンは利用できないことに注意してください。"

#. Tag: para
#: basic_mapping.xml:2900
#, no-c-format
msgid ""
"<literal>always</literal> - states that the property value is generated both "
"on insert and on update."
msgstr ""
"<literal>always</literal> - 挿入時も更新時もプロパティの値が生成されることを"
"示します。"

#. Tag: title
#: basic_mapping.xml:2907
#, no-c-format
msgid "Auxiliary Database Objects"
msgstr "補助的なデータベース・オブジェクト"

#. Tag: para
#: basic_mapping.xml:2908
#, no-c-format
msgid ""
"Allows CREATE and DROP of arbitrary database objects, in conjunction with "
"Hibernate's schema evolution tools, to provide the ability to fully define a "
"user schema within the Hibernate mapping files. Although designed "
"specifically for creating and dropping things like triggers or stored "
"procedures, really any SQL command that can be run via a <literal>java.sql."
"Statement.execute()</literal> method is valid here (ALTERs, INSERTS, etc). "
"There are essentially two modes for defining auxiliary database objects..."
msgstr ""
"Hibernateのスキーマ・エボリューションツールと連動することで、 任意のデータ"
"ベース・オブジェクト（トリガーやストアドプロシージャなど）のCREATEとDROPによ"
"り、 Hibernateのマッピングファイル内のユーザ・スキーマをすべて定義することが"
"出来ます。 主にトリガやストアドプロシージャのようなデータベース・オブジェクト"
"を生成や削除することを意図していますが、 実際には <literal>java.sql."
"Statement.execute()</literal> メソッドによって実行できる 任意のSQLコマンド"
"（ALTER、INSERTなど）が実行できます。 補助的なデータベース・オブジェクトを定"
"義するための、2つの基本的な方法があります。"

#. Tag: para
#: basic_mapping.xml:2917
#, no-c-format
msgid ""
"The first mode is to explicitly list the CREATE and DROP commands out in the "
"mapping file:"
msgstr ""
"1つ目の方法は、CREATEとDROPコマンドをマッピングファイルの外に、明示的に記載す"
"ることです。"

#. Tag: programlisting
#: basic_mapping.xml:2921
#, no-c-format
msgid ""
"<![CDATA[<hibernate-mapping>\n"
"    ...\n"
"    <database-object>\n"
"        <create>CREATE TRIGGER my_trigger ...</create>\n"
"        <drop>DROP TRIGGER my_trigger</drop>\n"
"    </database-object>\n"
"</hibernate-mapping>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2922
#, no-c-format
msgid ""
"The second mode is to supply a custom class which knows how to construct the "
"CREATE and DROP commands. This custom class must implement the <literal>org."
"hibernate.mapping.AuxiliaryDatabaseObject</literal> interface."
msgstr ""
"2つ目の方法は、CREATEとDROPコマンドの組み立て方を知っているカスタムクラスを提"
"供することです。 このカスタムクラスは <literal>org.hibernate.mapping."
"AuxiliaryDatabaseObject</literal> インタフェースを 実装しなければなりません。"

#. Tag: programlisting
#: basic_mapping.xml:2927
#, no-c-format
msgid ""
"<![CDATA[<hibernate-mapping>\n"
"    ...\n"
"    <database-object>\n"
"        <definition class=\"MyTriggerDefinition\"/>\n"
"    </database-object>\n"
"</hibernate-mapping>]]>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2928
#, no-c-format
msgid ""
"Additionally, these database objects can be optionally scoped such that they "
"only apply when certain dialects are used."
msgstr ""
"さらに、あるデータベース方言が使用される時にだけ適用するといったように、 デー"
"タベース・オブジェクトが使われるケースを限定できます。"

#. Tag: programlisting
#: basic_mapping.xml:2932
#, no-c-format
msgid ""
"<![CDATA[<hibernate-mapping>\n"
"    ...\n"
"    <database-object>\n"
"        <definition class=\"MyTriggerDefinition\"/>\n"
"        <dialect-scope name=\"org.hibernate.dialect.Oracle9Dialect\"/>\n"
"        <dialect-scope name=\"org.hibernate.dialect.OracleDialect\"/>\n"
"    </database-object>\n"
"</hibernate-mapping>]]>"
msgstr ""

#~ msgid "class"
#~ msgstr "class"

#~ msgid "id"
#~ msgstr "id"

#~ msgid ""
#~ "<literal>optimizer</literal> (optional, defaults to <literal>none</"
#~ "literal>): See <xref linkend=\"mapping-declaration-id-enhanced-optimizers"
#~ "\"/>"
#~ msgstr ""
#~ "<literal>optimizer</literal> (optional, defaults to <literal>none</"
#~ "literal>): See <xref linkend=\"mapping-declaration-id-enhanced-optimizers"
#~ "\"/>"

#~ msgid ""
#~ "<literal>optimizer</literal> (optional, defaults to <literal/>): See "
#~ "<xref linkend=\"mapping-declaration-id-enhanced-optimizers\"/>"
#~ msgstr ""
#~ "<literal>optimizer</literal> (optional, defaults to <literal/>): See "
#~ "<xref linkend=\"mapping-declaration-id-enhanced-optimizers\"/>"

#~ msgid "key"
#~ msgstr "key"

#~ msgid "any"
#~ msgstr "any"
