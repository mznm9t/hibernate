#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"

#: index.docbook:5
msgid "Native SQL"
msgstr "SQL Nativo"

#: index.docbook:7
msgid ""
"You may also express queries in the native SQL dialect of your database. "
"This is useful if you want to utilize database specific features such as "
"query hints or the <literal>CONNECT</literal> keyword in Oracle. It also "
"provides a clean migration path from a direct SQL/JDBC based application to "
"Hibernate."
msgstr ""
"Puedes tambi&#x00e9;n expresar consultas en el dialecto SQL nativo de tu "
"base de datos. Esto es &#x00fa;til si quieres utilizar aspectos espec&#x00ed;"
"ficos de base de datos tal como consejos (hints) de consulta o la palabra "
"clave <literal>CONNECT</literal> en Oracle. Provee adem&#x00e1;s una clara "
"ruta de migraci&#x00f3;n desde una aplicaci&#x00f3;n basada en SQL/JDBC "
"directo a Hibernate."

#: index.docbook:13
msgid ""
"Hibernate3 allows you to specify handwritten SQL (including stored "
"procedures) for all create, update, delete, and load operations."
msgstr ""
"Hibernate3 te permite especificar SQL escrito a mano (incluyendo "
"procedimientos almacenados) para todas las operaciones de creaci&#x00f3;n, "
"actualizaci&#x00f3;n, borrado y carga."

#: index.docbook:17
msgid "Using a <literal>SQLQuery</literal>"
msgstr "Using a <literal>SQLQuery</literal>"

#: index.docbook:19
msgid ""
"Execution of native SQL queries is controlled via the <literal>SQLQuery</"
"literal> interface, which is obtained by calling <literal>Session."
"createSQLQuery()</literal>. The following describes how to use this API for "
"querying."
msgstr ""
"Execution of native SQL queries is controlled via the <literal>SQLQuery</"
"literal> interface, which is obtained by calling <literal>Session."
"createSQLQuery()</literal>. The following describes how to use this API for "
"querying."

#: index.docbook:25
msgid "Scalar queries"
msgstr "Scalar queries"

#: index.docbook:27
msgid "The most basic SQL query is to get a list of scalars (values)."
msgstr "The most basic SQL query is to get a list of scalars (values)."

#: index.docbook:30
msgid ""
"<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\").list();\n"
"sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").list();\n"
"]]>"
msgstr ""
"<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\").list();\n"
"                                                                         sess."
"createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").list();\n"
"                                                                         ]]>"

#: index.docbook:32
msgid ""
"These will both return a List of Object arrays (Object[]) with scalar values "
"for each column in the CATS table. Hibernate will use ResultSetMetadata to "
"deduce the actual order and types of the returned scalar values."
msgstr ""
"These will both return a List of Object arrays (Object[]) with scalar values "
"for each column in the CATS table. Hibernate will use ResultSetMetadata to "
"deduce the actual order and types of the returned scalar values."

#: index.docbook:37
msgid ""
"To avoid the overhead of using <literal>ResultSetMetadata</literal> or "
"simply to be more explicit in what is returned one can use <literal>addScalar"
"()</literal>."
msgstr ""
"To avoid the overhead of using <literal>ResultSetMetadata</literal> or "
"simply to be more explicit in what is returned one can use <literal>addScalar"
"()</literal>."

#: index.docbook:41
msgid ""
"<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\")\n"
" .addScalar(\"ID\", Hibernate.LONG)\n"
" .addScalar(\"NAME\", Hibernate.STRING)\n"
" .addScalar(\"BIRTHDATE\", Hibernate.DATE)\n"
"]]>"
msgstr ""
"<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\")\n"
"                                                                         ."
"addScalar(\"ID\", Hibernate.LONG)\n"
"                                                                         ."
"addScalar(\"NAME\", Hibernate.STRING)\n"
"                                                                         ."
"addScalar(\"BIRTHDATE\", Hibernate.DATE)\n"
"                                                                         ]]>"

#: index.docbook:43, index.docbook:89, index.docbook:170, index.docbook:321
msgid "This query specified:"
msgstr "This query specified:"

#: index.docbook:47, index.docbook:93, index.docbook:325
msgid "the SQL query string"
msgstr "the SQL query string"

#: index.docbook:51
msgid "the columns and types to return"
msgstr "the columns and types to return"

#: index.docbook:55
msgid ""
"This will still return Object arrays, but now it will not use "
"<literal>ResultSetMetdata</literal> but will instead explicitly get the ID, "
"NAME and BIRTHDATE column as respectively a Long, String and a Short from "
"the underlying resultset. This also means that only these three columns will "
"be returned, even though the query is using <literal>*</literal> and could "
"return more than the three listed columns."
msgstr ""
"This will still return Object arrays, but now it will not use "
"<literal>ResultSetMetdata</literal> but will instead explicitly get the ID, "
"NAME and BIRTHDATE column as respectively a Long, String and a Short from "
"the underlying resultset. This also means that only these three columns will "
"be returned, even though the query is using <literal>*</literal> and could "
"return more than the three listed columns."

#: index.docbook:63
msgid ""
"It is possible to leave out the type information for all or some of the "
"scalars."
msgstr ""
"It is possible to leave out the type information for all or some of the "
"scalars."

#: index.docbook:66
msgid ""
"<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\")\n"
" .addScalar(\"ID\", Hibernate.LONG)\n"
" .addScalar(\"NAME\")\n"
" .addScalar(\"BIRTHDATE\")\n"
"]]>"
msgstr ""
"<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\")\n"
"                                                                         ."
"addScalar(\"ID\", Hibernate.LONG)\n"
"                                                                         ."
"addScalar(\"NAME\")\n"
"                                                                         ."
"addScalar(\"BIRTHDATE\")\n"
"                                                                         ]]>"

#: index.docbook:68
msgid ""
"This is essentially the same query as before, but now "
"<literal>ResultSetMetaData</literal> is used to decide the type of NAME and "
"BIRTHDATE where as the type of ID is explicitly specified."
msgstr ""
"This is essentially the same query as before, but now "
"<literal>ResultSetMetaData</literal> is used to decide the type of NAME and "
"BIRTHDATE where as the type of ID is explicitly specified."

#: index.docbook:72
msgid ""
"How the java.sql.Types returned from ResultSetMetaData is mapped to "
"Hibernate types is controlled by the Dialect. If a specific type is not "
"mapped or does not result in the expected type it is possible to customize "
"it via calls to <literal>registerHibernateType</literal> in the Dialect."
msgstr ""
"How the java.sql.Types returned from ResultSetMetaData is mapped to "
"Hibernate types is controlled by the Dialect. If a specific type is not "
"mapped or does not result in the expected type it is possible to customize "
"it via calls to <literal>registerHibernateType</literal> in the Dialect."

#: index.docbook:80
msgid "Entity queries"
msgstr "Entity queries"

#: index.docbook:82
msgid ""
"The above queries were all about returning scalar values, basically "
"returning the \"raw\" values from the resultset. The following shows how to "
"get entity objects from a native sql query via <literal>addEntity()</"
"literal>."
msgstr ""
"The above queries were all about returning scalar values, basically "
"returning the \"raw\" values from the resultset. The following shows how to "
"get entity objects from a native sql query via <literal>addEntity()</"
"literal>."

#: index.docbook:87
msgid ""
"<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\").addEntity(Cat.class);\n"
"sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").addEntity(Cat."
"class);\n"
"]]>"
msgstr ""
"<![CDATA[sess.createSQLQuery(\"SELECT * FROM CATS\").addEntity(Cat.class);\n"
"                                                                         sess."
"createSQLQuery(\"SELECT ID, NAME, BIRTHDATE FROM CATS\").addEntity(Cat."
"class);\n"
"                                                                         ]]>"

#: index.docbook:97
msgid "the entity returned by the query"
msgstr "the entity returned by the query"

#: index.docbook:101
msgid ""
"Assuming that Cat is mapped as a class with the columns ID, NAME and "
"BIRTHDATE the above queries will both return a List where each element is a "
"Cat entity."
msgstr ""
"Assuming that Cat is mapped as a class with the columns ID, NAME and "
"BIRTHDATE the above queries will both return a List where each element is a "
"Cat entity."

#: index.docbook:105
msgid ""
"If the entity is mapped with a <literal>many-to-one</literal> to another "
"entity it is required to also return this when performing the native query, "
"otherwise a database specific \"column not found\" error will occur. The "
"additional columns will automatically be returned when using the * notation, "
"but we prefer to be explicit as in the following example for a <literal>many-"
"to-one</literal> to a <literal>Dog</literal>:"
msgstr ""
"If the entity is mapped with a <literal>many-to-one</literal> to another "
"entity it is required to also return this when performing the native query, "
"otherwise a database specific \"column not found\" error will occur. The "
"additional columns will automatically be returned when using the * notation, "
"but we prefer to be explicit as in the following example for a <literal>many-"
"to-one</literal> to a <literal>Dog</literal>:"

#: index.docbook:113
msgid ""
"<![CDATA[sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, DOG_ID FROM CATS"
"\").addEntity(Cat.class);\n"
"]]>"
msgstr ""
"<![CDATA[sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, DOG_ID FROM CATS"
"\").addEntity(Cat.class);\n"
"                                                                         ]]>"

#: index.docbook:115
msgid "This will allow cat.getDog() to function properly."
msgstr "This will allow cat.getDog() to function properly."

#: index.docbook:119
msgid "Handling associations and collections"
msgstr "Handling associations and collections"

#: index.docbook:121
msgid ""
"It is possible to eagerly join in the <literal>Dog</literal> to avoid the "
"possible extra roundtrip for initializing the proxy. This is done via the "
"<literal>addJoin()</literal> method, which allows you to join in an "
"association or collection."
msgstr ""
"It is possible to eagerly join in the <literal>Dog</literal> to avoid the "
"possible extra roundtrip for initializing the proxy. This is done via the "
"<literal>addJoin()</literal> method, which allows you to join in an "
"association or collection."

#: index.docbook:126
msgid ""
"<![CDATA[sess.createSQLQuery(\"SELECT c.ID, NAME, BIRTHDATE, DOG_ID, D_ID, "
"D_NAME FROM CATS c, DOGS d WHERE c.DOG_ID = d.D_ID\")\n"
" .addEntity(\"cat\", Cat.class)\n"
" .addJoin(\"cat.dog\");\n"
"]]>"
msgstr ""
"<![CDATA[sess.createSQLQuery(\"SELECT c.ID, NAME, BIRTHDATE, DOG_ID, D_ID, "
"D_NAME FROM CATS c, DOGS d WHERE c.DOG_ID = d.D_ID\")\n"
"                                                                         ."
"addEntity(\"cat\", Cat.class)\n"
"                                                                         ."
"addJoin(\"cat.dog\");\n"
"                                                                         ]]>"

#: index.docbook:128
msgid ""
"In this example the returned <literal>Cat</literal>'s will have their "
"<literal>dog</literal> property fully initialized without any extra "
"roundtrip to the database. Notice that we added a alias name (\"cat\") to be "
"able to specify the target property path of the join. It is possible to do "
"the same eager joining for collections, e.g. if the <literal>Cat</literal> "
"had a one-to-many to <literal>Dog</literal> instead."
msgstr ""
"In this example the returned <literal>Cat</literal>'s will have their "
"<literal>dog</literal> property fully initialized without any extra "
"roundtrip to the database. Notice that we added a alias name (\"cat\") to be "
"able to specify the target property path of the join. It is possible to do "
"the same eager joining for collections, e.g. if the <literal>Cat</literal> "
"had a one-to-many to <literal>Dog</literal> instead."

#: index.docbook:136
msgid ""
"<![CDATA[sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, D_ID, D_NAME, "
"CAT_ID FROM CATS c, DOGS d WHERE c.ID = d.CAT_ID\")\n"
" .addEntity(\"cat\", Cat.class)\n"
" .addJoin(\"cat.dogs\");\n"
"]]>"
msgstr ""
"<![CDATA[sess.createSQLQuery(\"SELECT ID, NAME, BIRTHDATE, D_ID, D_NAME, "
"CAT_ID FROM CATS c, DOGS d WHERE c.ID = d.CAT_ID\")\n"
"                                                                         ."
"addEntity(\"cat\", Cat.class)\n"
"                                                                         ."
"addJoin(\"cat.dogs\");\n"
"                                                                         ]]>"

#: index.docbook:138
msgid ""
"At this stage we are reaching the limits of what is possible with native "
"queries without starting to enhance the sql queries to make them usable in "
"Hibernate; the problems starts to arise when returning multiple entities of "
"the same type or when the default alias/column names are not enough."
msgstr ""
"At this stage we are reaching the limits of what is possible with native "
"queries without starting to enhance the sql queries to make them usable in "
"Hibernate; the problems starts to arise when returning multiple entities of "
"the same type or when the default alias/column names are not enough."

#: index.docbook:146
msgid "Returning multiple entities"
msgstr "Returning multiple entities"

#: index.docbook:148
msgid ""
"Until now the result set column names are assumed to be the same as the "
"column names specified in the mapping document. This can be problematic for "
"SQL queries which join multiple tables, since the same column names may "
"appear in more than one table."
msgstr ""
"Until now the result set column names are assumed to be the same as the "
"column names specified in the mapping document. This can be problematic for "
"SQL queries which join multiple tables, since the same column names may "
"appear in more than one table."

#: index.docbook:153
msgid ""
"Column alias injection is needed in the following query (which most likely "
"will fail):"
msgstr ""
"Column alias injection is needed in the following query (which most likely "
"will fail):"

#: index.docbook:156
msgid ""
"<![CDATA[sess.createSQLQuery(\"SELECT c.*, m.*  FROM CATS c, CATS m WHERE c."
"MOTHER_ID = c.ID\")\n"
" .addEntity(\"cat\", Cat.class)\n"
" .addEntity(\"mother\", Cat.class)\n"
"]]>"
msgstr ""
"<![CDATA[sess.createSQLQuery(\"SELECT c.*, m.*  FROM CATS c, CATS m WHERE c."
"MOTHER_ID = c.ID\")\n"
"                                                                         ."
"addEntity(\"cat\", Cat.class)\n"
"                                                                         ."
"addEntity(\"mother\", Cat.class)\n"
"                                                                         ]]>"

#: index.docbook:158
msgid ""
"The intention for this query is to return two Cat instances per row, a cat "
"and its mother. This will fail since there is a conflict of names since they "
"are mapped to the same column names and on some databases the returned "
"column aliases will most likely be on the form \"c.ID\", \"c.NAME\", etc. "
"which are not equal to the columns specificed in the mappings (\"ID\" and "
"\"NAME\")."
msgstr ""
"The intention for this query is to return two Cat instances per row, a cat "
"and its mother. This will fail since there is a conflict of names since they "
"are mapped to the same column names and on some databases the returned "
"column aliases will most likely be on the form \"c.ID\", \"c.NAME\", etc. "
"which are not equal to the columns specificed in the mappings (\"ID\" and "
"\"NAME\")."

#: index.docbook:165
msgid "The following form is not vulnerable to column name duplication:"
msgstr "The following form is not vulnerable to column name duplication:"

#: index.docbook:168
msgid ""
"<![CDATA[sess.createSQLQuery(\"SELECT {cat.*}, {mother.*}  FROM CATS c, CATS "
"m WHERE c.MOTHER_ID = c.ID\")\n"
" .addEntity(\"cat\", Cat.class)\n"
" .addEntity(\"mother\", Cat.class)\n"
"]]>"
msgstr ""
"<![CDATA[sess.createSQLQuery(\"SELECT {cat.*}, {mother.*}  FROM CATS c, CATS "
"m WHERE c.MOTHER_ID = c.ID\")\n"
"                                                                         ."
"addEntity(\"cat\", Cat.class)\n"
"                                                                         ."
"addEntity(\"mother\", Cat.class)\n"
"                                                                         ]]>"

#: index.docbook:174
msgid ""
"the SQL query string, with placeholders for Hibernate to inject column "
"aliases"
msgstr ""
"the SQL query string, with placeholders for Hibernate to inject column "
"aliases"

#: index.docbook:179
msgid "the entities returned by the query"
msgstr "the entities returned by the query"

#: index.docbook:183
msgid ""
"The {cat.*} and {mother.*} notation used above is a shorthand for \"all "
"properties\". Alternatively, you may list the columns explicity, but even in "
"this case we let Hibernate inject the SQL column aliases for each property. "
"The placeholder for a column alias is just the property name qualified by "
"the table alias. In the following example, we retrieve Cats and their "
"mothers from a different table (cat_log) to the one declared in the mapping "
"metadata. Notice that we may even use the property aliases in the where "
"clause if we like."
msgstr ""
"The {cat.*} and {mother.*} notation used above is a shorthand for \"all "
"properties\". Alternatively, you may list the columns explicity, but even in "
"this case we let Hibernate inject the SQL column aliases for each property. "
"The placeholder for a column alias is just the property name qualified by "
"the table alias. In the following example, we retrieve Cats and their "
"mothers from a different table (cat_log) to the one declared in the mapping "
"metadata. Notice that we may even use the property aliases in the where "
"clause if we like."

#: index.docbook:192
msgid ""
"<![CDATA[String sql = \"SELECT ID as {c.id}, NAME as {c.name}, \" + \n"
"         \"BIRTHDATE as {c.birthDate}, MOTHER_ID as {c.mother}, {mother.*} "
"\" +\n"
"         \"FROM CAT_LOG c, CAT_LOG m WHERE {c.mother} = c.ID\";\n"
"\n"
"List loggedCats = sess.createSQLQuery(sql)\n"
"        .addEntity(\"cat\", Cat.class)\n"
"        .addEntity(\"mother\", Cat.class).list()\n"
"]]>"
msgstr ""
"<![CDATA[String sql = \"SELECT ID as {c.id}, NAME as {c.name}, \" + \n"
"                                                    \"BIRTHDATE as {c."
"birthDate}, MOTHER_ID as {c.mother}, {mother.*} \" +\n"
"                                                    \"FROM CAT_LOG c, "
"CAT_LOG m WHERE {c.mother} = c.ID\";\n"
"                                                    \n"
"                                                    List loggedCats = sess."
"createSQLQuery(sql)\n"
"                                                    .addEntity(\"cat\", Cat."
"class)\n"
"                                                    .addEntity(\"mother\", "
"Cat.class).list()\n"
"                                                    ]]>"

#: index.docbook:195
msgid "Alias and property references"
msgstr "Alias and property references"

#: index.docbook:197
msgid ""
"For most cases the above alias injection is needed, but for queries relating "
"to more complex mappings like composite properties, inheritance "
"discriminators, collections etc. there are some specific aliases to use to "
"allow Hibernate to inject the proper aliases."
msgstr ""
"For most cases the above alias injection is needed, but for queries relating "
"to more complex mappings like composite properties, inheritance "
"discriminators, collections etc. there are some specific aliases to use to "
"allow Hibernate to inject the proper aliases."

#: index.docbook:202
msgid ""
"The following table shows the different possibilities of using the alias "
"injection. Note: the alias names in the result are examples, each alias will "
"have a unique and probably different name when used."
msgstr ""
"The following table shows the different possibilities of using the alias "
"injection. Note: the alias names in the result are examples, each alias will "
"have a unique and probably different name when used."

#: index.docbook:208
msgid "Alias injection names"
msgstr "Alias injection names"

#: index.docbook:219
msgid "Description"
msgstr "Description"

#: index.docbook:221
msgid "Syntax"
msgstr "Syntax"

#: index.docbook:223
msgid "Example"
msgstr "Example"

#: index.docbook:229
msgid "A simple property"
msgstr "A simple property"

#: index.docbook:231
msgid "{[aliasname].[propertyname]"
msgstr "{[aliasname].[propertyname]"

#: index.docbook:233
msgid "A_NAME as {item.name}"
msgstr "A_NAME as {item.name}"

#: index.docbook:237
msgid "A composite property"
msgstr "A composite property"

#: index.docbook:239
msgid "{[aliasname].[componentname].[propertyname]}"
msgstr "{[aliasname].[componentname].[propertyname]}"

#: index.docbook:241
msgid "CURRENCY as {item.amount.currency}, VALUE as {item.amount.value}"
msgstr "CURRENCY as {item.amount.currency}, VALUE as {item.amount.value}"

#: index.docbook:246
msgid "Discriminator of an entity"
msgstr "Discriminator of an entity"

#: index.docbook:248
msgid "{[aliasname].class}"
msgstr "{[aliasname].class}"

#: index.docbook:250
msgid "DISC as {item.class}"
msgstr "DISC as {item.class}"

#: index.docbook:254
msgid "All properties of an entity"
msgstr "All properties of an entity"

#: index.docbook:256, index.docbook:304
msgid "{[aliasname].*}"
msgstr "{[aliasname].*}"

#: index.docbook:258
msgid "{item.*}"
msgstr "{item.*}"

#: index.docbook:262
msgid "A collection key"
msgstr "A collection key"

#: index.docbook:264
msgid "{[aliasname].key}"
msgstr "{[aliasname].key}"

#: index.docbook:266
msgid "ORGID as {coll.key}"
msgstr "ORGID as {coll.key}"

#: index.docbook:270
msgid "The id of an collection"
msgstr "The id of an collection"

#: index.docbook:272
msgid "{[aliasname].id}"
msgstr "{[aliasname].id}"

#: index.docbook:274
msgid "EMPID as {coll.id}"
msgstr "EMPID as {coll.id}"

#: index.docbook:278
msgid "The element of an collection"
msgstr "The element of an collection"

#: index.docbook:280
msgid "{[aliasname].element}"
msgstr "{[aliasname].element}"

#: index.docbook:282
msgid "XID as {coll.element}"
msgstr "XID as {coll.element}"

#: index.docbook:286
msgid "roperty of the element in the collection"
msgstr "roperty of the element in the collection"

#: index.docbook:288
msgid "{[aliasname].element.[propertyname]}"
msgstr "{[aliasname].element.[propertyname]}"

#: index.docbook:290
msgid "NAME as {coll.element.name}"
msgstr "NAME as {coll.element.name}"

#: index.docbook:294
msgid "All properties of the element in the collection"
msgstr "All properties of the element in the collection"

#: index.docbook:296
msgid "{[aliasname].element.*}"
msgstr "{[aliasname].element.*}"

#: index.docbook:298
msgid "{coll.element.*}"
msgstr "{coll.element.*}"

#: index.docbook:302
msgid "All properties of the the collection"
msgstr "All properties of the the collection"

#: index.docbook:306
msgid "{coll.*}"
msgstr "{coll.*}"

#: index.docbook:315
msgid "Returning non-managed entities"
msgstr "Returning non-managed entities"

#: index.docbook:317
msgid ""
"It is possible to apply a ResultTransformer to native sql queries. Allowing "
"it to e.g. return non-managed entities."
msgstr ""
"It is possible to apply a ResultTransformer to native sql queries. Allowing "
"it to e.g. return non-managed entities."

#: index.docbook:319
msgid ""
"<![CDATA[sess.createSQLQuery(\"SELECT NAME, BIRTHDATE FROM CATS\")\n"
"        .setResultTransformer(Transformers.aliasToBean(CatDTO.class))]]>"
msgstr ""
"<![CDATA[sess.createSQLQuery(\"SELECT NAME, BIRTHDATE FROM CATS\")\n"
"                                                                         ."
"setResultTransformer(Transformers.aliasToBean(CatDTO.class))]]>"

#: index.docbook:329
msgid "a result transformer"
msgstr "a result transformer"

#: index.docbook:333
msgid ""
"The above query will return a list of <literal>CatDTO</literal> which has "
"been instantiated and injected the values of NAME and BIRTHNAME into its "
"corresponding properties or fields."
msgstr ""
"The above query will return a list of <literal>CatDTO</literal> which has "
"been instantiated and injected the values of NAME and BIRTHNAME into its "
"corresponding properties or fields."

#: index.docbook:340
msgid "Handling inheritance"
msgstr "Handling inheritance"

#: index.docbook:342
msgid ""
"Native sql queries which query for entities that is mapped as part of an "
"inheritance must include all properties for the baseclass and all it "
"subclasses."
msgstr ""
"Native sql queries which query for entities that is mapped as part of an "
"inheritance must include all properties for the baseclass and all it "
"subclasses."

#: index.docbook:348
msgid "Parameters"
msgstr "Parameters"

#: index.docbook:350
msgid "Native sql queries support positional as well as named parameters:"
msgstr "Native sql queries support positional as well as named parameters:"

#: index.docbook:353
msgid ""
"<![CDATA[Query query = sess.createSQLQuery(\"SELECT * FROM CATS WHERE NAME "
"like ?\").addEntity(Cat.class);\n"
"List pusList = query.setString(0, \"Pus%\").list();\n"
"     \n"
"query = sess.createSQLQuery(\"SELECT * FROM CATS WHERE NAME like :name\")."
"addEntity(Cat.class);\n"
"List pusList = query.setString(\"name\", \"Pus%\").list();          ]]>"
msgstr ""
"<![CDATA[Query query = sess.createSQLQuery(\"SELECT * FROM CATS WHERE NAME "
"like ?\").addEntity(Cat.class);\n"
"                                                   List pusList = query."
"setString(0, \"Pus%\").list();\n"
"                                                   \n"
"                                                   query = sess."
"createSQLQuery(\"SELECT * FROM CATS WHERE NAME like :name\").addEntity(Cat."
"class);\n"
"                                                   List pusList = query."
"setString(\"name\", \"Pus%\").list();          ]]>"

#: index.docbook:361
msgid "Named SQL queries"
msgstr "Consultas SQL con nombre"

#: index.docbook:363
msgid ""
"Named SQL queries may be defined in the mapping document and called in "
"exactly the same way as a named HQL query. In this case, we do "
"<emphasis>not</emphasis> need to call <literal>addEntity()</literal>."
msgstr ""
"Las consultas SQL con nombre pueden definirse en el documento de mapeo y "
"llamadas exactamente en la misma forma en que a una consulta HQL con nombre. "
"En este caso, <emphasis>no</emphasis> necesitamos llamar a <literal>addEntity"
"()</literal>."

#: index.docbook:368
msgid ""
"<![CDATA[<sql-query name=\"persons\">\n"
"    <return alias=\"person\" class=\"eg.Person\"/>\n"
"    SELECT person.NAME AS {person.name},\n"
"           person.AGE AS {person.age},\n"
"           person.SEX AS {person.sex}\n"
"    FROM PERSON person\n"
"    WHERE person.NAME LIKE :namePattern\n"
"</sql-query>]]>"
msgstr ""
"<![CDATA[<sql-query name=\"persons\">\n"
"    <return alias=\"person\" class=\"eg.Person\"/>\n"
"    SELECT person.NAME AS {person.name},\n"
"           person.AGE AS {person.age},\n"
"           person.SEX AS {person.sex}\n"
"    FROM PERSON person \n"
"    WHERE person.NAME LIKE :namePattern\n"
"</sql-query>]]>"

#: index.docbook:370
msgid ""
"<![CDATA[List people = sess.getNamedQuery(\"persons\")\n"
"    .setString(\"namePattern\", namePattern)\n"
"    .setMaxResults(50)\n"
"    .list();]]>"
msgstr ""
"<![CDATA[List people = sess.getNamedQuery(\"persons\")\n"
"    .setString(\"namePattern\", namePattern)\n"
"    .setMaxResults(50)\n"
"    .list();]]>"

#: index.docbook:372
msgid ""
"The <literal>&lt;return-join&gt;</literal> and <literal>&lt;load-"
"collection&gt;</literal> elements are used to join associations and define "
"queries which initialize collections, respectively."
msgstr ""
"Los elementos <literal>&lt;return-join&gt;</literal> y <literal>&lt;load-"
"collection&gt;</literal> se usan para unir asociaciones y definir consultas "
"que inicialicen colecciones, respectivamente."

#: index.docbook:377
msgid ""
"<![CDATA[<sql-query name=\"personsWith\">\n"
"    <return alias=\"person\" class=\"eg.Person\"/>\n"
"    <return-join alias=\"address\" property=\"person.mailingAddress\"/>\n"
"    SELECT person.NAME AS {person.name},\n"
"           person.AGE AS {person.age},\n"
"           person.SEX AS {person.sex},\n"
"           address.STREET AS {address.street},\n"
"           address.CITY AS {address.city},\n"
"           address.STATE AS {address.state},\n"
"           address.ZIP AS {address.zip}\n"
"    FROM PERSON person\n"
"    JOIN ADDRESS address\n"
"        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
"    WHERE person.NAME LIKE :namePattern\n"
"</sql-query>]]>"
msgstr ""
"<![CDATA[<sql-query name=\"personsWith\">\n"
"    <return alias=\"person\" class=\"eg.Person\"/>\n"
"    <return-join alias=\"address\" property=\"person.mailingAddress\"/>\n"
"    SELECT person.NAME AS {person.name},\n"
"           person.AGE AS {person.age},\n"
"           person.SEX AS {person.sex},\n"
"           address.STREET AS {address.street},\n"
"           address.CITY AS {address.city},\n"
"           address.STATE AS {address.state},\n"
"           address.ZIP AS {address.zip}\n"
"    FROM PERSON person \n"
"    JOIN ADDRESS address\n"
"            ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
"    WHERE person.NAME LIKE :namePattern\n"
"</sql-query>]]>"

#: index.docbook:379
msgid ""
"A named SQL query may return a scalar value. You must declare the column "
"alias and Hibernate type using the <literal>&lt;return-scalar&gt;</literal> "
"element:"
msgstr ""
"Una consulta SQL con nombre puede devolver un valor escalar. Debes "
"especificar el alias de columna y tipo Hibernate usando el elementp "
"<literal>&lt;return-scalar&gt;</literal>:"

#: index.docbook:383
msgid ""
"<![CDATA[<sql-query name=\"mySqlQuery\">\n"
"    <return-scalar column=\"name\" type=\"string\"/>\n"
"    <return-scalar column=\"age\" type=\"long\"/>\n"
"    SELECT p.NAME AS name,\n"
"           p.AGE AS age,\n"
"    FROM PERSON p WHERE p.NAME LIKE 'Hiber%'\n"
"</sql-query>]]>"
msgstr ""
"<![CDATA[<sql-query name=\"mySqlQuery\">\n"
"    <return-scalar column=\"name\" type=\"string\"/>\n"
"    <return-scalar column=\"age\" type=\"long\"/>\n"
"    SELECT p.NAME AS name,\n"
"           p.AGE AS age,\n"
"    FROM PERSON p WHERE p.NAME LIKE 'Hiber%'\n"
"</sql-query>]]>"

#: index.docbook:385
msgid ""
"You can externalize the resultset mapping informations in a <literal>&lt;"
"resultset&gt;</literal> element to either reuse them accross several named "
"queries or through the <literal>setResultSetMapping()</literal> API."
msgstr ""
"You can externalize the resultset mapping informations in a <literal>&lt;"
"resultset&gt;</literal> element to either reuse them accross several named "
"queries or through the <literal>setResultSetMapping()</literal> API."

#: index.docbook:390
msgid ""
"<![CDATA[<resultset name=\"personAddress\">\n"
"    <return alias=\"person\" class=\"eg.Person\"/>\n"
"    <return-join alias=\"address\" property=\"person.mailingAddress\"/>\n"
"</resultset>\n"
"\n"
"<sql-query name=\"personsWith\" resultset-ref=\"personAddress\">\n"
"    SELECT person.NAME AS {person.name},\n"
"           person.AGE AS {person.age},\n"
"           person.SEX AS {person.sex},\n"
"           address.STREET AS {address.street},\n"
"           address.CITY AS {address.city},\n"
"           address.STATE AS {address.state},\n"
"           address.ZIP AS {address.zip}\n"
"    FROM PERSON person\n"
"    JOIN ADDRESS address\n"
"        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
"    WHERE person.NAME LIKE :namePattern\n"
"</sql-query>]]>"
msgstr ""
"<![CDATA[<resultset name=\"personAddress\">\n"
"                <return alias=\"person\" class=\"eg.Person\"/>\n"
"                <return-join alias=\"address\" property=\"person."
"mailingAddress\"/>\n"
"        </resultset>\n"
"        \n"
"        <sql-query name=\"personsWith\" resultset-ref=\"personAddress\">\n"
"                SELECT person.NAME AS {person.name},\n"
"                person.AGE AS {person.age},\n"
"                person.SEX AS {person.sex},\n"
"                address.STREET AS {address.street},\n"
"                address.CITY AS {address.city},\n"
"                address.STATE AS {address.state},\n"
"                address.ZIP AS {address.zip}\n"
"                FROM PERSON person\n"
"                JOIN ADDRESS address\n"
"                ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'\n"
"                WHERE person.NAME LIKE :namePattern\n"
"        </sql-query>]]>"

#: index.docbook:392
msgid ""
"You can alternatively use the resultset mapping information in your hbm "
"files directly in java code."
msgstr ""
"You can alternatively use the resultset mapping information in your hbm "
"files directly in java code."

#: index.docbook:395
msgid ""
"<![CDATA[List cats = sess.createSQLQuery(\n"
"        \"select {cat.*}, {kitten.*} from cats cat, cats kitten where kitten."
"mother = cat.id\"\n"
"    )\n"
"    .setResultSetMapping(\"catAndKitten\")\n"
"    .list();]]>"
msgstr ""
"<![CDATA[List cats = sess.createSQLQuery(\n"
"                              \"select {cat.*}, {kitten.*} from cats cat, "
"cats kitten where kitten.mother = cat.id\"\n"
"                              )\n"
"                              .setResultSetMapping(\"catAndKitten\")\n"
"    .list();]]>"

#: index.docbook:398
msgid "Using return-property to explicitly specify column/alias names"
msgstr ""
"Usando return-property para especificar expl&#x00ed;citamente nombres de "
"columna/alias"

#: index.docbook:401
msgid ""
"With <literal>&lt;return-property&gt;</literal> you can explicitly tell "
"Hibernate what column aliases to use, instead of using the <literal>{}</"
"literal>-syntax to let Hibernate inject its own aliases."
msgstr ""
"Con <literal>&lt;return-property&gt;</literal> puedes decirle expl&#x00ed;"
"citamente a Hibernate qu&#x00e9; alias de columna usar, en vez de usar la "
"sint&#x00e1;xis <literal>{}</literal> para dejar que Hibernate inyecte sus "
"propios alias."

#: index.docbook:406
msgid ""
"<![CDATA[<sql-query name=\"mySqlQuery\">\n"
"    <return alias=\"person\" class=\"eg.Person\">\n"
"        <return-property name=\"name\" column=\"myName\"/>\n"
"        <return-property name=\"age\" column=\"myAge\"/>\n"
"        <return-property name=\"sex\" column=\"mySex\"/>\n"
"    </return>\n"
"    SELECT person.NAME AS myName,\n"
"           person.AGE AS myAge,\n"
"           person.SEX AS mySex,\n"
"    FROM PERSON person WHERE person.NAME LIKE :name\n"
"</sql-query>\n"
"]]>"
msgstr ""
"<![CDATA[<sql-query name=\"mySqlQuery\">\n"
"    <return alias=\"person\" class=\"eg.Person\">\n"
"        <return-property name=\"name\" column=\"myName\"/>\n"
"        <return-property name=\"age\" column=\"myAge\"/>\n"
"        <return-property name=\"sex\" column=\"mySex\"/>\n"
"    </return>\n"
"    SELECT person.NAME AS myName,\n"
"           person.AGE AS myAge,\n"
"           person.SEX AS mySex,\n"
"    FROM PERSON person WHERE person.NAME LIKE :name\n"
"</sql-query>\n"
"]]>"

#: index.docbook:408
msgid ""
"<literal>&lt;return-property&gt;</literal> also works with multiple columns. "
"This solves a limitation with the <literal>{}</literal>-syntax which can not "
"allow fine grained control of multi-column properties."
msgstr ""
"<literal>&lt;return-property&gt;</literal> tambi&#x00e9;n trabaja con "
"m&#x00fa;ltiples columnas. Esto resuelve una limitaci&#x00f3;n de la "
"sint&#x00e1;xis <literal>{}</literal>, la cual no puede permitir un control "
"fino de propiedades multi-columna."

#: index.docbook:413
msgid ""
"<![CDATA[<sql-query name=\"organizationCurrentEmployments\">\n"
"    <return alias=\"emp\" class=\"Employment\">\n"
"        <return-property name=\"salary\">\n"
"            <return-column name=\"VALUE\"/>\n"
"            <return-column name=\"CURRENCY\"/>\n"
"        </return-property>\n"
"        <return-property name=\"endDate\" column=\"myEndDate\"/>\n"
"    </return>\n"
"        SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer},\n"
"        STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},\n"
"        REGIONCODE as {emp.regionCode}, EID AS {emp.id}, VALUE, CURRENCY\n"
"        FROM EMPLOYMENT\n"
"        WHERE EMPLOYER = :id AND ENDDATE IS NULL\n"
"        ORDER BY STARTDATE ASC\n"
"</sql-query>]]>"
msgstr ""
"<![CDATA[<sql-query name=\"organizationCurrentEmployments\">\n"
"    <return alias=\"emp\" class=\"Employment\">            \n"
"        <return-property name=\"salary\"> \n"
"            <return-column name=\"VALUE\"/>\n"
"            <return-column name=\"CURRENCY\"/>            \n"
"        </return-property>\n"
"        <return-property name=\"endDate\" column=\"myEndDate\"/>\n"
"    </return>\n"
"        SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer}, \n"
"        STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},\n"
"        REGIONCODE as {emp.regionCode}, EID AS {emp.id}, VALUE, CURRENCY\n"
"        FROM EMPLOYMENT\n"
"        WHERE EMPLOYER = :id AND ENDDATE IS NULL\n"
"        ORDER BY STARTDATE ASC\n"
"</sql-query>]]>"

#: index.docbook:415
msgid ""
"Notice that in this example we used <literal>&lt;return-property&gt;</"
"literal> in combination with the <literal>{}</literal>-syntax for injection. "
"Allowing users to choose how they want to refer column and properties."
msgstr ""
"Nota que en este ejemplo hemos usado <literal>&lt;return-property&gt;</"
"literal> en combinaci&#x00f3;n con la sint&#x00e1;xis <literal>{}</literal> "
"para inyecci&#x00f3;n, permitiendo a los usuarios elejir c&#x00f3;mo quieren "
"referirse a las columnas y propiedades."

#: index.docbook:420
msgid ""
"If your mapping has a discriminator you must use <literal>&lt;return-"
"discriminator&gt;</literal> to specify the discriminator column."
msgstr ""
"Si tu mapeo tiene un discriminador debes usar <literal>&lt;return-"
"discriminator&gt;</literal> para especificar la columna discriminadora."

#: index.docbook:426
msgid "Using stored procedures for querying"
msgstr "Usando procedimientos almacenados para consultar"

#: index.docbook:428
msgid ""
"Hibernate 3 introduces support for queries via stored procedures and "
"functions. Most of the following documentation is equivalent for both. The "
"stored procedure/function must return a resultset as the first out-parameter "
"to be able to work with Hibernate. An example of such a stored function in "
"Oracle 9 and higher is as follows:"
msgstr ""
"Hibernate3 introduce soporte para consultas v&#x00ed;a procedimientos "
"almacenados. Los procedimientos almacenados deben devolver un conjunto "
"resultado como el primer par&#x00e1;metro de salida para ser capaces de "
"funcionar con Hibernate. Un ejemplo de uno procedimiento almacenado en "
"Oracle 9 o superior es as&#x00ed;:"

#: index.docbook:434
msgid ""
"<![CDATA[CREATE OR REPLACE FUNCTION selectAllEmployments\n"
"    RETURN SYS_REFCURSOR\n"
"AS\n"
"    st_cursor SYS_REFCURSOR;\n"
"BEGIN\n"
"    OPEN st_cursor FOR\n"
" SELECT EMPLOYEE, EMPLOYER,\n"
" STARTDATE, ENDDATE,\n"
" REGIONCODE, EID, VALUE, CURRENCY\n"
" FROM EMPLOYMENT;\n"
"      RETURN  st_cursor;\n"
" END;]]>"
msgstr ""
"<![CDATA[CREATE OR REPLACE FUNCTION selectAllEmployments \n"
"    RETURN SYS_REFCURSOR \n"
"AS \n"
"    st_cursor SYS_REFCURSOR; \n"
"BEGIN \n"
"    OPEN st_cursor FOR \n"
" SELECT EMPLOYEE, EMPLOYER, \n"
" STARTDATE, ENDDATE, \n"
" REGIONCODE, EID, VALUE, CURRENCY \n"
" FROM EMPLOYMENT; \n"
"      RETURN  st_cursor; \n"
" END;]]>"

#: index.docbook:436
msgid "To use this query in Hibernate you need to map it via a named query."
msgstr ""
"Para usar esta consulta en Hibernate necesitas mapearla por medio de una "
"consulta con nombre."

#: index.docbook:439
msgid ""
"<![CDATA[<sql-query name=\"selectAllEmployees_SP\" callable=\"true\">\n"
"    <return alias=\"emp\" class=\"Employment\">\n"
"        <return-property name=\"employee\" column=\"EMPLOYEE\"/>\n"
"        <return-property name=\"employer\" column=\"EMPLOYER\"/>\n"
"        <return-property name=\"startDate\" column=\"STARTDATE\"/>\n"
"        <return-property name=\"endDate\" column=\"ENDDATE\"/>\n"
"        <return-property name=\"regionCode\" column=\"REGIONCODE\"/>\n"
"        <return-property name=\"id\" column=\"EID\"/>\n"
"        <return-property name=\"salary\">\n"
"            <return-column name=\"VALUE\"/>\n"
"            <return-column name=\"CURRENCY\"/>\n"
"        </return-property>\n"
"    </return>\n"
"    { ? = call selectAllEmployments() }\n"
"</sql-query>]]>"
msgstr ""
"<![CDATA[<sql-query name=\"selectAllEmployees_SP\" callable=\"true\">\n"
"    <return alias=\"emp\" class=\"Employment\">\n"
"        <return-property name=\"employee\" column=\"EMPLOYEE\"/>\n"
"        <return-property name=\"employer\" column=\"EMPLOYER\"/"
">            \n"
"        <return-property name=\"startDate\" column=\"STARTDATE\"/>\n"
"        <return-property name=\"endDate\" column=\"ENDDATE\"/>            \n"
"        <return-property name=\"regionCode\" column=\"REGIONCODE\"/"
">            \n"
"        <return-property name=\"id\" column=\"EID\"/"
">                        \n"
"        <return-property name=\"salary\"> \n"
"            <return-column name=\"VALUE\"/>\n"
"            <return-column name=\"CURRENCY\"/>            \n"
"        </return-property>\n"
"    </return>\n"
"    { ? = call selectAllEmployments() }\n"
"</sql-query>]]>"

#: index.docbook:441
msgid ""
"Notice stored procedures currently only return scalars and entities. "
"<literal>&lt;return-join&gt;</literal> and <literal>&lt;load-collection&gt;</"
"literal> are not supported."
msgstr ""
"Nota que los procedimientos almacenados s&#x00f3;lo devuelven escalares y "
"entidades. No est&#x00e1;n soportados <literal>&lt;return-join&gt;</literal> "
"y <literal>&lt;load-collection&gt;</literal>."

#: index.docbook:446
msgid "Rules/limitations for using stored procedures"
msgstr "Reglas/limitaciones para usar procedimientos almacenados"

#: index.docbook:448
msgid ""
"To use stored procedures with Hibernate the procedures/functions have to "
"follow some rules. If they do not follow those rules they are not usable "
"with Hibernate. If you still want to use these procedures you have to "
"execute them via <literal>session.connection()</literal>. The rules are "
"different for each database, since database vendors have different stored "
"procedure semantics/syntax."
msgstr ""
"Para usar procedimientos almacenados con Hibernate los procedimientos tienen "
"que seguir algunas reglas. Si no siguen esas reglas no son usables por "
"Hibernate. Si a&#x00fa;n quisieras usar estos procedimientos tendr&#x00ed;as "
"que ejecutarlos por medio de <literal>session.connection()</literal>. Las "
"reglas son diferentes para cada base de datos, ya que los vendedores de base "
"de datos tienen diferentes sem&#x00e1;nticas/sint&#x00e1;xis de "
"procedimientos almacenados."

#: index.docbook:455
msgid ""
"Stored procedure queries can't be paged with <literal>setFirstResult()/"
"setMaxResults()</literal>."
msgstr ""
"Las consultas de procedimientos almacenados no pueden ser paginadas con "
"<literal>setFirstResult()/setMaxResults()</literal>."

#: index.docbook:458
msgid ""
"Recommended call form is standard SQL92: <literal>{ ? = call functionName"
"(&lt;parameters&gt;) }</literal> or <literal>{ ? = call procedureName(&lt;"
"parameters&gt;}</literal>. Native call syntax is not supported."
msgstr "Para Oracle se aplican las siguientes reglas:"

#: index.docbook:463
msgid "For Oracle the following rules apply:"
msgstr ""
"El procedimiento debe devolver un conjunto resultado. Esto se hace "
"devolviendo un <literal>SYS_REFCURSOR</literal> en Oracle 9 o 10. En Oracle "
"necesitas definir un tipo <literal>REF CURSOR</literal>."

#: index.docbook:467
msgid ""
"A function must return a result set. The first parameter of a procedure must "
"be an <literal>OUT</literal> that returns a result set. This is done by "
"using a <literal>SYS_REFCURSOR</literal> type in Oracle 9 or 10. In Oracle "
"you need to define a <literal>REF CURSOR</literal> type, see Oracle "
"literature."
msgstr ""
"La forma recomendada es <literal>{ ? = call procName(&lt;parameters&gt;) }</"
"literal> o <literal>{ ? = call procName }</literal> (esto es m&#x00e1;s una "
"regla de Oracle que una regla de Hibernate)."

#: index.docbook:476
msgid "For Sybase or MS SQL server the following rules apply:"
msgstr "Para Sybase o MS SQL server se aplican las siguientes reglas:"

#: index.docbook:480
msgid ""
"The procedure must return a result set. Note that since these servers can/"
"will return multiple result sets and update counts, Hibernate will iterate "
"the results and take the first result that is a result set as its return "
"value. Everything else will be discarded."
msgstr ""
"El procedimiento debe devolver un conjunto resultado. Nota que ya que estos "
"servidores pueden y devolver&#x00e1;n m&#x00fa;ltiples conjuntos resultados "
"y cuentas de actualizaci&#x00f3;n, Hibernate iterar&#x00e1; los resultados y "
"tomar&#x00e1; el primer resultado que sea un conjunto resultado como su "
"valor a devolver. Todo lo dem&#x00e1;s ser&#x00e1; descartado."

#: index.docbook:488
msgid ""
"If you can enable <literal>SET NOCOUNT ON</literal> in your procedure it "
"will probably be more efficient, but this is not a requirement."
msgstr ""
"Si habilitas <literal>SET NOCOUNT ON</literal> en tu procedimiento "
"ser&#x00e1; probablemente m&#x00e1;s eficiente, pero esto no es un "
"requerimiento."

#: index.docbook:498
msgid "Custom SQL for create, update and delete"
msgstr "SQL personalizado para crear, actualizar y borrar"

#: index.docbook:500
msgid ""
"Hibernate3 can use custom SQL statements for create, update, and delete "
"operations. The class and collection persisters in Hibernate already contain "
"a set of configuration time generated strings (insertsql, deletesql, "
"updatesql etc.). The mapping tags <literal>&lt;sql-insert&gt;</literal>, "
"<literal>&lt;sql-delete&gt;</literal>, and <literal>&lt;sql-update&gt;</"
"literal> override these strings:"
msgstr ""
"Hibernate3 puede usar sentencias SQL personalizadas para las operaciones de "
"crear, actualizar y borrar. Los persistidores de clases y colecciones en "
"Hibernate ya contienen un conjunto de cadenas generadas en tiempo de "
"configuraci&#x00f3;n (insertsql, deletesql, updatesql, etc.). Las etiquetas "
"de mapeo <literal>&lt;sql-insert&gt;</literal>, <literal>&lt;sql-delete&gt;</"
"literal>, y <literal>&lt;sql-update&gt;</literal> sobrescriben estas cadenas:"

#: index.docbook:508
msgid ""
"<![CDATA[<class name=\"Person\">\n"
"    <id name=\"id\">\n"
"        <generator class=\"increment\"/>\n"
"    </id>\n"
"    <property name=\"name\" not-null=\"true\"/>\n"
"    <sql-insert>INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )</sql-"
"insert>\n"
"    <sql-update>UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?</sql-update>\n"
"    <sql-delete>DELETE FROM PERSON WHERE ID=?</sql-delete>\n"
"</class>]]>"
msgstr ""
"<![CDATA[<class name=\"Person\">\n"
"    <id name=\"id\">\n"
"        <generator class=\"increment\"/>\n"
"    </id>\n"
"    <property name=\"name\" not-null=\"true\"/>\n"
"    <sql-insert>INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )</sql-"
"insert>\n"
"    <sql-update>UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?</sql-update>\n"
"    <sql-delete>DELETE FROM PERSON WHERE ID=?</sql-delete>\n"
"</class>]]>"

#: index.docbook:510
msgid ""
"The SQL is directly executed in your database, so you are free to use any "
"dialect you like. This will of course reduce the portability of your mapping "
"if you use database specific SQL."
msgstr ""
"El SQL se ejecuta directamente en tu base de datos, de modo que eres libre "
"de usar cualquier dialecto que quieras. Esto reducir&#x00e1;, por supuesto, "
"la portabilidad de tu mapeo si usas SQL espec&#x00ed;fico de la base de "
"datos."

#: index.docbook:514
msgid ""
"Stored procedures are supported if the <literal>callable</literal> attribute "
"is set:"
msgstr ""
"Los procedimientos almacenados son soportados si est&#x00e1; establecido el "
"atributo <literal>callable</literal>:"

#: index.docbook:517
msgid ""
"<![CDATA[<class name=\"Person\">\n"
"    <id name=\"id\">\n"
"        <generator class=\"increment\"/>\n"
"    </id>\n"
"    <property name=\"name\" not-null=\"true\"/>\n"
"    <sql-insert callable=\"true\">{call createPerson (?, ?)}</sql-insert>\n"
"    <sql-delete callable=\"true\">{? = call deletePerson (?)}</sql-delete>\n"
"    <sql-update callable=\"true\">{? = call updatePerson (?, ?)}</sql-"
"update>\n"
"</class>]]>"
msgstr ""
"<![CDATA[<class name=\"Person\">\n"
"    <id name=\"id\">\n"
"        <generator class=\"increment\"/>\n"
"    </id>\n"
"    <property name=\"name\" not-null=\"true\"/>\n"
"    <sql-insert callable=\"true\">{call createPerson (?, ?)}</sql-insert>\n"
"    <sql-delete callable=\"true\">{? = call deletePerson (?)}</sql-delete>\n"
"    <sql-update callable=\"true\">{? = call updatePerson (?, ?)}</sql-"
"update>\n"
"</class>]]>"

#: index.docbook:519
msgid ""
"The order of the positional parameters are currently vital, as they must be "
"in the same sequence as Hibernate expects them."
msgstr ""
"El orden de los par&#x00e1;metros posicionales son actualmente vitales, ya "
"que deben estar en la misma secuencia en que las espera Hibernate."

#: index.docbook:522
msgid ""
"You can see the expected order by enabling debug logging for the "
"<literal>org.hibernate.persister.entity</literal> level. With this level "
"enabled Hibernate will print out the static SQL that is used to create, "
"update, delete etc. entities. (To see the expected sequence, remember to not "
"include your custom SQL in the mapping files as that will override the "
"Hibernate generated static sql.)"
msgstr ""
"Puedes ver el orden esperado habilitando el registro de depuraci&#x00f3;n "
"para el nivel <literal>org.hibernate.persister.entity</literal>. Con este "
"nivel habilitado, Hibernate imprimir&#x00e1; el SQL est&#x00e1;tico que se "
"usa para crear, actualizar, borrar, etc. las entidades. (Para ver la "
"secuencia esperada, recuerda no incluir tu SQL personalizado en los ficheros "
"de mapeo ya que sobrescribir&#x00e1;n el sql est&#x00e1;tico generado por "
"Hibernate.)"

#: index.docbook:529
msgid ""
"The stored procedures are in most cases (read: better do it than not) "
"required to return the number of rows inserted/updated/deleted, as Hibernate "
"has some runtime checks for the success of the statement. Hibernate always "
"registers the first statement parameter as a numeric output parameter for "
"the CUD operations:"
msgstr ""
"Los procedimientos almacenados son, en la mayor&#x00ed;a de los casos "
"(l&#x00e9;ase, mejor hacerlo que no hacerlo), obligados a devolver el "
"n&#x00fa;mero de filas insertadas/actualizadas/borradas, ya que Hibernate "
"tiene algunas comprobaciones en tiempo de ejecuci&#x00f3;n del &#x00e9;xito "
"de la sentencia. Hibernate siempre registra el primer par&#x00e1;metro de la "
"sentencia como un par&#x00e1;metro de salida num&#x00e9;rico para las "
"operaciones CUD:"

#: index.docbook:535
msgid ""
"<![CDATA[CREATE OR REPLACE FUNCTION updatePerson (uid IN NUMBER, uname IN "
"VARCHAR2)\n"
"    RETURN NUMBER IS\n"
"BEGIN\n"
"\n"
"    update PERSON\n"
"    set\n"
"        NAME = uname,\n"
"    where\n"
"        ID = uid;\n"
"\n"
"    return SQL%ROWCOUNT;\n"
"\n"
"END updatePerson;]]>"
msgstr ""
"<![CDATA[CREATE OR REPLACE FUNCTION updatePerson (uid IN NUMBER, uname IN "
"VARCHAR2)\n"
"    RETURN NUMBER IS\n"
"BEGIN\n"
"\n"
"    update PERSON\n"
"    set\n"
"        NAME = uname,\n"
"    where\n"
"        ID = uid;\n"
"\n"
"    return SQL%ROWCOUNT;\n"
"\n"
"END updatePerson;]]>"

#: index.docbook:539
msgid "Custom SQL for loading"
msgstr "SQL personalizado para carga"

#: index.docbook:541
msgid "You may also declare your own SQL (or HQL) queries for entity loading:"
msgstr ""
"Puedes tambi&#x00e9;n declarar tu propias consultas SQL (o HQL) para cargar "
"entidades:"

#: index.docbook:544
msgid ""
"<![CDATA[<sql-query name=\"person\">\n"
"    <return alias=\"pers\" class=\"Person\" lock-mode=\"upgrade\"/>\n"
"    SELECT NAME AS {pers.name}, ID AS {pers.id}\n"
"    FROM PERSON\n"
"    WHERE ID=?\n"
"    FOR UPDATE\n"
"</sql-query>]]>"
msgstr ""
"<![CDATA[<sql-query name=\"person\">\n"
"    <return alias=\"pers\" class=\"Person\" lock-mode=\"upgrade\"/>\n"
"    SELECT NAME AS {pers.name}, ID AS {pers.id} \n"
"    FROM PERSON \n"
"    WHERE ID=? \n"
"    FOR UPDATE\n"
"</sql-query>]]>"

#: index.docbook:546
msgid ""
"This is just a named query declaration, as discussed earlier. You may "
"reference this named query in a class mapping:"
msgstr ""
"Esto es s&#x00f3;lo una declaraci&#x00f3;n de consulta con nombrem como se "
"ha discutido anteriormente. Puedes hacer referencia a esta consulta con "
"nombre en un mapeo de clase:"

#: index.docbook:549
msgid ""
"<![CDATA[<class name=\"Person\">\n"
"    <id name=\"id\">\n"
"        <generator class=\"increment\"/>\n"
"    </id>\n"
"    <property name=\"name\" not-null=\"true\"/>\n"
"    <loader query-ref=\"person\"/>\n"
"</class>]]>"
msgstr ""
"<![CDATA[<class name=\"Person\">\n"
"    <id name=\"id\">\n"
"        <generator class=\"increment\"/>\n"
"    </id>\n"
"    <property name=\"name\" not-null=\"true\"/>\n"
"    <loader query-ref=\"person\"/>\n"
"</class>]]>"

#: index.docbook:551
msgid "This even works with stored procedures."
msgstr "Esto incluso funciona con procedimientos almacenados."

#: index.docbook:553
msgid "You may even define a query for collection loading:"
msgstr "Puedes incluso definit una consulta para la carga de colecciones:"

#: index.docbook:555
msgid ""
"<![CDATA[<set name=\"employments\" inverse=\"true\">\n"
"    <key/>\n"
"    <one-to-many class=\"Employment\"/>\n"
"    <loader query-ref=\"employments\"/>\n"
"</set>]]>"
msgstr ""
"<![CDATA[<set name=\"employments\" inverse=\"true\">\n"
"    <key/>\n"
"    <one-to-many class=\"Employment\"/>\n"
"    <loader query-ref=\"employments\"/>\n"
"</set>]]>"

#: index.docbook:557
msgid ""
"<![CDATA[<sql-query name=\"employments\">\n"
"    <load-collection alias=\"emp\" role=\"Person.employments\"/>\n"
"    SELECT {emp.*}\n"
"    FROM EMPLOYMENT emp\n"
"    WHERE EMPLOYER = :id\n"
"    ORDER BY STARTDATE ASC, EMPLOYEE ASC\n"
"</sql-query>]]>"
msgstr ""
"<![CDATA[<sql-query name=\"employments\">\n"
"    <load-collection alias=\"emp\" role=\"Person.employments\"/>\n"
"    SELECT {emp.*}\n"
"    FROM EMPLOYMENT emp\n"
"    WHERE EMPLOYER = :id\n"
"    ORDER BY STARTDATE ASC, EMPLOYEE ASC\n"
"</sql-query>]]>"

#: index.docbook:559
msgid ""
"You could even define an entity loader that loads a collection by join "
"fetching:"
msgstr ""
"Podr&#x00ed;as incluso definir un cargador de entidades que cargue una "
"colecci&#x00f3;n por recuperaci&#x00f3;n por uni&#x00f3;n (join fetching):"

#: index.docbook:562
msgid ""
"<![CDATA[<sql-query name=\"person\">\n"
"    <return alias=\"pers\" class=\"Person\"/>\n"
"    <return-join alias=\"emp\" property=\"pers.employments\"/>\n"
"    SELECT NAME AS {pers.*}, {emp.*}\n"
"    FROM PERSON pers\n"
"    LEFT OUTER JOIN EMPLOYMENT emp\n"
"        ON pers.ID = emp.PERSON_ID\n"
"    WHERE ID=?\n"
"</sql-query>]]>"
msgstr ""
"<![CDATA[<sql-query name=\"person\">\n"
"    <return alias=\"pers\" class=\"Person\"/>\n"
"    <return-join alias=\"emp\" property=\"pers.employments\"/> \n"
"    SELECT NAME AS {pers.*}, {emp.*}\n"
"    FROM PERSON pers\n"
"    LEFT OUTER JOIN EMPLOYMENT emp \n"
"        ON pers.ID = emp.PERSON_ID\n"
"    WHERE ID=?\n"
"</sql-query>]]>"

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"
