msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2008-08-14 15:28+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: query_hql.xml:29
#, no-c-format
msgid "HQL: The Hibernate Query Language"
msgstr "HQL: Langage de requêtage d'Hibernate"

#. Tag: para
#: query_hql.xml:31
#, no-c-format
msgid ""
"Hibernate is equipped with an extremely powerful query language that (quite "
"intentionally) looks very much like SQL. But don't be fooled by the syntax; "
"HQL is fully object-oriented, understanding notions like inheritence, "
"polymorphism and association."
msgstr ""
"Hibernate fourni un langage d'interrogation extrêmement puissant qui "
"ressemble (et c'est voulu) au SQL. Mais ne soyez pas distraits par la "
"syntaxe ; HQL est totalement orienté objet, comprenant des notions "
"d'héritage, de polymorphisme et d'association."

#. Tag: title
#: query_hql.xml:38
#, no-c-format
msgid "Case Sensitivity"
msgstr "Sensibilité à la casse"

#. Tag: para
#: query_hql.xml:40
#, no-c-format
msgid ""
"Queries are case-insensitive, except for names of Java classes and "
"properties. So <literal>SeLeCT</literal> is the same as <literal>sELEct</"
"literal> is the same as <literal>SELECT</literal> but <literal>org.hibernate."
"eg.FOO</literal> is not <literal>org.hibernate.eg.Foo</literal> and "
"<literal>foo.barSet</literal> is not <literal>foo.BARSET</literal>."
msgstr ""
"Les requêtes sont insensibles à la casse, à l'exception des noms des classes "
"Java et des propriétés. Ainsi, <literal>SeLeCT</literal> est identique à "
"<literal>sELEct</literal> et à <literal>SELECT</literal> mais <literal>net."
"sf.hibernate.eg.FOO</literal> n'est pas identique <literal>net.sf.hibernate."
"eg.Foo</literal> et <literal>foo.barSet</literal> n'est pas identique à "
"<literal>foo.BARSET</literal>."

#. Tag: para
#: query_hql.xml:51
#, no-c-format
msgid ""
"This manual uses lowercase HQL keywords. Some users find queries with "
"uppercase keywords more readable, but we find this convention ugly when "
"embedded in Java code."
msgstr ""
"Ce guide utilise les mots clés HQL en minuscule. Certains utilisateurs "
"trouvent les requêtes écrites avec les mots clés en majuscule plus lisibles, "
"mais nous trouvons cette convention pénible lorsqu'elle est lue dans du code "
"Java."

#. Tag: title
#: query_hql.xml:59
#, no-c-format
msgid "The from clause"
msgstr "La clause from"

#. Tag: para
#: query_hql.xml:61
#, no-c-format
msgid "The simplest possible Hibernate query is of the form:"
msgstr "La requête Hibernate la plus simple est de la forme :"

#. Tag: programlisting
#: query_hql.xml:65
#, no-c-format
msgid "<![CDATA[from eg.Cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:67
#, no-c-format
msgid ""
"which simply returns all instances of the class <literal>eg.Cat</literal>. "
"We don't usually need to qualify the class name, since <literal>auto-import</"
"literal> is the default. So we almost always just write:"
msgstr ""
"qui retourne simplement toutes les instances de la classe <literal>eg.Cat</"
"literal>. Nous n'avons pas besoin d'habitude de qualifier le nom de la "
"classe, puisque <literal>auto-import</literal> est la valeur par défaut. "
"Donc nous écrivons presque toujours :"

#. Tag: programlisting
#: query_hql.xml:73
#, no-c-format
msgid "<![CDATA[from Cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:75
#, no-c-format
msgid ""
"Most of the time, you will need to assign an <emphasis>alias</emphasis>, "
"since you will want to refer to the <literal>Cat</literal> in other parts of "
"the query."
msgstr ""
"La plupart du temps, vous devrez assigner un <emphasis>alias</emphasis> "
"puisque vous voudrez faire référence à <literal>Cat</literal> dans d'autres "
"parties de la requête."

#. Tag: programlisting
#: query_hql.xml:81 query_hql.xml:396
#, no-c-format
msgid "<![CDATA[from Cat as cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:83
#, no-c-format
msgid ""
"This query assigns the alias <literal>cat</literal> to <literal>Cat</"
"literal> instances, so we could use that alias later in the query. The "
"<literal>as</literal> keyword is optional; we could also write:"
msgstr ""
"Cette requête assigne l'alias <literal>cat</literal> à l'instance "
"<literal>Cat</literal>, nous pouvons donc utiliser cet alias ailleurs dans "
"la requête. Le mot clé <literal>as</literal> est optionnel ; nous aurions pu "
"écrire :"

#. Tag: programlisting
#: query_hql.xml:89
#, no-c-format
msgid "<![CDATA[from Cat cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:91
#, no-c-format
msgid ""
"Multiple classes may appear, resulting in a cartesian product or \"cross\" "
"join."
msgstr ""
"Plusieurs classes peuvent apparaître, ce qui conduira à un produit cartésien "
"(encore appelé jointures croisées)."

#. Tag: programlisting
#: query_hql.xml:95
#, no-c-format
msgid "<![CDATA[from Formula, Parameter]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:96
#, no-c-format
msgid "<![CDATA[from Formula as form, Parameter as param]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:98
#, no-c-format
msgid ""
"It is considered good practice to name query aliases using an initial "
"lowercase, consistent with Java naming standards for local variables (eg. "
"<literal>domesticCat</literal>)."
msgstr ""
"C'est une bonne pratique que de nommer les alias dans les requêtes en "
"utilisant l'initiale en miniscule, ce qui a le mérite d'être en phase avec "
"les standards de nommage Java pour les variables locales "
"(<literal>domesticCat</literal>)."

#. Tag: title
#: query_hql.xml:107
#, no-c-format
msgid "Associations and joins"
msgstr "Associations et jointures"

#. Tag: para
#: query_hql.xml:109
#, no-c-format
msgid ""
"We may also assign aliases to associated entities, or even to elements of a "
"collection of values, using a <literal>join</literal>."
msgstr ""
"On peut aussi assigner des alias à des entités associées, ou même aux "
"éléments d'une collection de valeurs, en utilisant un <literal>join</"
"literal> (jointure)."

#. Tag: programlisting
#: query_hql.xml:114
#, no-c-format
msgid ""
"<![CDATA[from Cat as cat\n"
"    inner join cat.mate as mate\n"
"    left outer join cat.kittens as kitten]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:116
#, no-c-format
msgid "<![CDATA[from Cat as cat left join cat.mate.kittens as kittens]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:118
#, no-c-format
msgid "<![CDATA[from Formula form full join form.parameter param]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:120
#, no-c-format
msgid "The supported join types are borrowed from ANSI SQL"
msgstr "Les types de jointures supportées sont celles de ANSI SQL"

#. Tag: literal
#: query_hql.xml:127
#, no-c-format
msgid "inner join"
msgstr "<literal>inner join</literal> (jointure fermée)"

#. Tag: literal
#: query_hql.xml:132
#, no-c-format
msgid "left outer join"
msgstr "<literal>left outer join</literal> (jointure ouverte par la gauche)"

#. Tag: literal
#: query_hql.xml:137
#, no-c-format
msgid "right outer join"
msgstr "<literal>right outer join</literal> (jointure ouverte par la droite)"

#. Tag: para
#: query_hql.xml:141
#, no-c-format
msgid "<literal>full join</literal> (not usually useful)"
msgstr ""
"<literal>full join</literal> (jointure ouverte totalement - généralement "
"inutile)"

#. Tag: para
#: query_hql.xml:147
#, no-c-format
msgid ""
"The <literal>inner join</literal>, <literal>left outer join</literal> and "
"<literal>right outer join</literal> constructs may be abbreviated."
msgstr ""
"Les constructions des jointures <literal>inner join</literal>, <literal>left "
"outer join</literal> et <literal>right outer join</literal> peuvent être "
"abbrégées."

#. Tag: programlisting
#: query_hql.xml:152
#, no-c-format
msgid ""
"<![CDATA[from Cat as cat\n"
"    join cat.mate as mate\n"
"    left join cat.kittens as kitten]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:154
#, no-c-format
msgid ""
"You may supply extra join conditions using the HQL <literal>with</literal> "
"keyword."
msgstr ""
"Nous pouvons soumettre des conditions de jointure supplémentaires en "
"utilisant le mot-clef HQL <literal>with</literal>."

#. Tag: programlisting
#: query_hql.xml:159
#, no-c-format
msgid ""
"<![CDATA[from Cat as cat\n"
"    left join cat.kittens as kitten\n"
"        with kitten.bodyWeight > 10.0]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:161
#, no-c-format
msgid ""
"In addition, a \"fetch\" join allows associations or collections of values "
"to be initialized along with their parent objects, using a single select. "
"This is particularly useful in the case of a collection. It effectively "
"overrides the outer join and lazy declarations of the mapping file for "
"associations and collections. See <xref linkend=\"performance-fetching\"/> "
"for more information."
msgstr ""
"Par ailleurs, une jointure \"fetchée\" (rapportée) permet d'initialiser les "
"associations ou collections de valeurs en même temps que leur objet parent, "
"le tout n'utilisant qu'un seul Select. Ceci est particulièrement utile dans "
"le cas des collections. Ce système permet de surcharger les déclarations "
"\"lazy\" et \"outer-join\" des fichiers de mapping pour les associations et "
"collections. Voir <xref linkend=\"performance-fetching\"/> pour plus "
"d'informations."

#. Tag: programlisting
#: query_hql.xml:169
#, no-c-format
msgid ""
"<![CDATA[from Cat as cat\n"
"    inner join fetch cat.mate\n"
"    left join fetch cat.kittens]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:171
#, no-c-format
msgid ""
"A fetch join does not usually need to assign an alias, because the "
"associated objects should not be used in the <literal>where</literal> clause "
"(or any other clause). Also, the associated objects are not returned "
"directly in the query results. Instead, they may be accessed via the parent "
"object. The only reason we might need an alias is if we are recursively join "
"fetching a further collection:"
msgstr ""
"Une jointure \"fetchée\" (rapportée) n'a généralement pas besoin de se voir "
"assigner un alias puisque les objets associés n'ont pas à être utilisés dans "
"les autres clauses. Notez aussi que les objets associés ne sont pas "
"retournés directement dans le résultat de la requête mais l'on peut y "
"accéder via l'objet parent. La seule raison pour laquelle nous pourrions "
"avoir besoin d'un alias est si nous récupérions récursivement une collection "
"supplémentaire :"

#. Tag: programlisting
#: query_hql.xml:179
#, no-c-format
msgid ""
"<![CDATA[from Cat as cat\n"
"    inner join fetch cat.mate\n"
"    left join fetch cat.kittens child\n"
"    left join fetch child.kittens]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:181
#, no-c-format
msgid ""
"Note that the <literal>fetch</literal> construct may not be used in queries "
"called using <literal>iterate()</literal> (though <literal>scroll()</"
"literal> can be used). Nor should <literal>fetch</literal> be used together "
"with <literal>setMaxResults()</literal> or <literal>setFirstResult()</"
"literal> as these operations are based on the result rows, which usually "
"contain duplicates for eager collection fetching, hence, the number of rows "
"is not what you'd expect. Nor may <literal>fetch</literal> be used together "
"with an ad hoc <literal>with</literal> condition. It is possible to create a "
"cartesian product by join fetching more than one collection in a query, so "
"take care in this case. Join fetching multiple collection roles also "
"sometimes gives unexpected results for bag mappings, so be careful about how "
"you formulate your queries in this case. Finally, note that <literal>full "
"join fetch</literal> and <literal>right join fetch</literal> are not "
"meaningful."
msgstr ""
"Notez que la construction de <literal>fetch</literal> ne peut pas être "
"utilisée dans les requêtes appelées par <literal>scroll()</literal> ou "
"<literal>iterate()</literal>. <literal>fetch</literal> ne devrait pas non "
"plus être utilisé avec <literal>setMaxResults()</literal> ou "
"<literal>setFirstResult()</literal>. <literal>fetch</literal> ne peut pas "
"non plus être utilisé avec une condition <literal>with</literal> ad hoc. Il "
"est possible de créer un produit cartésien par jointure en récupérant plus "
"d'une collection dans une requête, donc faites attention dans ce cas. "
"Récupérer par jointure de multiples collections donne aussi parfois des "
"résultats inattendus pour des mappings de bag, donc soyez prudent lorsque "
"vous formulez vos requêtes dans de tels cas. Finalement, notez que "
"<literal>full join fetch</literal> et <literal>right join fetch</literal> ne "
"sont pas utiles en général."

#. Tag: para
#: query_hql.xml:196
#, no-c-format
msgid ""
"If you are using property-level lazy fetching (with bytecode "
"instrumentation), it is possible to force Hibernate to fetch the lazy "
"properties immediately (in the first query) using <literal>fetch all "
"properties</literal>."
msgstr ""
"Si vous utilisez un chargement retardé pour les propriétés (avec une "
"instrumentation par bytecode), il est possible de forcer Hibernate à "
"récupérer les propriétés non encore chargées immédiatement (dans la première "
"requête) en utilisant <literal>fetch all properties</literal>."

#. Tag: programlisting
#: query_hql.xml:202
#, no-c-format
msgid "<![CDATA[from Document fetch all properties order by name]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:203
#, no-c-format
msgid ""
"<![CDATA[from Document doc fetch all properties where lower(doc.name) like '%"
"cats%']]>"
msgstr ""

#. Tag: title
#: query_hql.xml:208
#, no-c-format
msgid "Forms of join syntax"
msgstr "Formes de syntaxes pour les jointures"

#. Tag: para
#: query_hql.xml:210
#, no-c-format
msgid ""
"HQL supports two forms of association joining: <literal>implicit</literal> "
"and <literal>explicit</literal>."
msgstr ""
"HQL supporte deux formes pour joindre les associations: <literal>implicite</"
"literal> et <literal>explicite</literal>."

#. Tag: para
#: query_hql.xml:214
#, no-c-format
msgid ""
"The queries shown in the previous section all use the <literal>explicit</"
"literal> form where the join keyword is explicitly used in the from clause. "
"This is the recommended form."
msgstr ""
"Les requêtes présentes dans la section précédente utilisent la forme "
"<literal>explicite</literal> où le mode clé join est explicitement utilisé "
"dans la clause from. C'est la forme recommandée."

#. Tag: para
#: query_hql.xml:219
#, no-c-format
msgid ""
"The <literal>implicit</literal> form does not use the join keyword. Instead, "
"the associations are \"dereferenced\" using dot-notation. <literal>implicit</"
"literal> joins can appear in any of the HQL clauses. <literal>implicit</"
"literal> join result in inner joins in the resulting SQL statement."
msgstr ""
"La forme <literal>implicite</literal> n'utilise pas le mot clé join. A la "
"place, les associations sont \"déréférencées\" en utilisant le notation '.'. "
"Ces jointures peuvent apparaitre dans toutes les clauses. Les jointures "
"<literal>implicites</literal> résultent en des inner join dans le SQL généré."

#. Tag: programlisting
#: query_hql.xml:226
#, no-c-format
msgid "<![CDATA[from Cat as cat where cat.mate.name like '%s%']]>"
msgstr ""

#. Tag: title
#: query_hql.xml:230
#, no-c-format
msgid "Refering to identifier property"
msgstr "Refering to identifier property"

#. Tag: para
#: query_hql.xml:232
#, no-c-format
msgid ""
"There are, generally speaking, 2 ways to refer to an entity's identifier "
"property:"
msgstr ""
"There are, generally speaking, 2 ways to refer to an entity's identifier "
"property:"

#. Tag: para
#: query_hql.xml:237
#, no-c-format
msgid ""
"The special property (lowercase) <literal>id</literal> may be used to "
"reference the identifier property of an entity <emphasis>provided that "
"entity does not define a non-identifier property named id</emphasis>."
msgstr ""
"The special property (lowercase) <literal>id</literal> may be used to "
"reference the identifier property of an entity <emphasis>provided that "
"entity does not define a non-identifier property named id</emphasis>."

#. Tag: para
#: query_hql.xml:244
#, no-c-format
msgid ""
"If the entity defines a named identifier property, you may use that property "
"name."
msgstr ""
"If the entity defines a named identifier property, you may use that property "
"name."

#. Tag: para
#: query_hql.xml:250
#, no-c-format
msgid ""
"References to composite identifier properties follow the same naming rules. "
"If the entity has a non-identifier property named id, the composite "
"identifier property can only be referenced by its defined named; otherwise, "
"the special <literal>id</literal> property can be used to rerference the "
"identifier property."
msgstr ""
"References to composite identifier properties follow the same naming rules. "
"If the entity has a non-identifier property named id, the composite "
"identifier property can only be referenced by its defined named; otherwise, "
"the special <literal>id</literal> property can be used to rerference the "
"identifier property."

#. Tag: para
#: query_hql.xml:257
#, fuzzy, no-c-format
msgid ""
"Note: this has changed significantly starting in version 3.2.2. In previous "
"versions, <literal>id</literal> <emphasis>always</emphasis> referred to the "
"identifier property no matter what its actual name. A ramification of that "
"decision was that non-identifier properties named <literal>id</literal> "
"could never be referenced in Hibernate queries."
msgstr ""
"Note: this has changed significantly starting in version 3.2.2. In previous "
"versions, <literal>id</literal><emphasis>always</emphasis> referred to the "
"identifier property no matter what its actual name. A ramification of that "
"decision was that non-identifier properties named <literal>id</literal> "
"could never be referenced in Hibernate queries."

#. Tag: title
#: query_hql.xml:266
#, no-c-format
msgid "The select clause"
msgstr "La clause select"

#. Tag: para
#: query_hql.xml:268
#, no-c-format
msgid ""
"The <literal>select</literal> clause picks which objects and properties to "
"return in the query result set. Consider:"
msgstr ""
"La clause <literal>select</literal> sélectionne les objets et propriétés qui "
"doivent être retournés dans le résultat de la requête. Soit :"

#. Tag: programlisting
#: query_hql.xml:273
#, no-c-format
msgid ""
"<![CDATA[select mate\n"
"from Cat as cat\n"
"    inner join cat.mate as mate]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:275
#, no-c-format
msgid ""
"The query will select <literal>mate</literal>s of other <literal>Cat</"
"literal>s. Actually, you may express this query more compactly as:"
msgstr ""
"La requête recherchera les <literal>mate</literal>s liés aux <literal>Cat</"
"literal>s. Vous pouvez explimer la requête d'une manière plus compacte :"

#. Tag: programlisting
#: query_hql.xml:280
#, no-c-format
msgid "<![CDATA[select cat.mate from Cat cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:282
#, no-c-format
msgid ""
"Queries may return properties of any value type including properties of "
"component type:"
msgstr ""
"Les requêtes peuvent retourner des propriétés de n'importe quel type, même "
"celles de type composant (component) :"

#. Tag: programlisting
#: query_hql.xml:286
#, no-c-format
msgid ""
"<![CDATA[select cat.name from DomesticCat cat\n"
"where cat.name like 'fri%']]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:288
#, no-c-format
msgid "<![CDATA[select cust.name.firstName from Customer as cust]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:290
#, no-c-format
msgid ""
"Queries may return multiple objects and/or properties as an array of type "
"<literal>Object[]</literal>,"
msgstr ""
"Les requêtes peuvent retourner plusieurs objets et/ou propriétés sous la "
"forme d'un tableau du type <literal>Object[]</literal>,"

#. Tag: programlisting
#: query_hql.xml:295
#, no-c-format
msgid ""
"<![CDATA[select mother, offspr, mate.name\n"
"from DomesticCat as mother\n"
"    inner join mother.mate as mate\n"
"    left outer join mother.kittens as offspr]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:297
#, no-c-format
msgid "or as a <literal>List</literal>,"
msgstr "ou sous la forme d'une <literal>List</literal>,"

#. Tag: programlisting
#: query_hql.xml:301
#, no-c-format
msgid ""
"<![CDATA[select new list(mother, offspr, mate.name)\n"
"from DomesticCat as mother\n"
"    inner join mother.mate as mate\n"
"    left outer join mother.kittens as offspr]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:303
#, no-c-format
msgid "or as an actual typesafe Java object,"
msgstr "ou sous la forme d'un objet Java typé,"

#. Tag: programlisting
#: query_hql.xml:307
#, no-c-format
msgid ""
"<![CDATA[select new Family(mother, mate, offspr)\n"
"from DomesticCat as mother\n"
"    join mother.mate as mate\n"
"    left join mother.kittens as offspr]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:309
#, no-c-format
msgid ""
"assuming that the class <literal>Family</literal> has an appropriate "
"constructor."
msgstr ""
"à condition que la classe <literal>Family</literal> possède le constructeur "
"approprié."

#. Tag: para
#: query_hql.xml:313
#, no-c-format
msgid ""
"You may assign aliases to selected expressions using <literal>as</literal>:"
msgstr ""
"Vous pouvez assigner des alias aux expressions sélectionnées en utilisant "
"<literal>as</literal> :"

#. Tag: programlisting
#: query_hql.xml:317
#, no-c-format
msgid ""
"<![CDATA[select max(bodyWeight) as max, min(bodyWeight) as min, count(*) as "
"n\n"
"from Cat cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:319
#, no-c-format
msgid ""
"This is most useful when used together with <literal>select new map</"
"literal>:"
msgstr ""
"C'est surtout utile lorsque c'est utilisé avec <literal>select new map</"
"literal> :"

#. Tag: programlisting
#: query_hql.xml:323
#, no-c-format
msgid ""
"<![CDATA[select new map( max(bodyWeight) as max, min(bodyWeight) as min, "
"count(*) as n )\n"
"from Cat cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:325
#, no-c-format
msgid ""
"This query returns a <literal>Map</literal> from aliases to selected values."
msgstr ""
"Cette requête retourne une <literal>Map</literal> à partir des alias vers "
"les valeurs sélectionnées."

#. Tag: title
#: query_hql.xml:332
#, no-c-format
msgid "Aggregate functions"
msgstr "Fonctions d'aggrégation"

#. Tag: para
#: query_hql.xml:334
#, no-c-format
msgid ""
"HQL queries may even return the results of aggregate functions on properties:"
msgstr ""
"Les requêtes HQL peuvent aussi retourner le résultat de fonctions "
"d'aggrégation sur les propriétés :"

#. Tag: programlisting
#: query_hql.xml:338
#, no-c-format
msgid ""
"<![CDATA[select avg(cat.weight), sum(cat.weight), max(cat.weight), count"
"(cat)\n"
"from Cat cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:349
#, no-c-format
msgid "The supported aggregate functions are"
msgstr "Les fonctions supportées sont"

#. Tag: literal
#: query_hql.xml:356
#, no-c-format
msgid "avg(...), sum(...), min(...), max(...)"
msgstr "avg(...), sum(...), min(...), max(...)"

#. Tag: literal
#: query_hql.xml:361
#, no-c-format
msgid "count(*)"
msgstr "count(*)"

#. Tag: literal
#: query_hql.xml:366
#, no-c-format
msgid "count(...), count(distinct ...), count(all...)"
msgstr "count(...), count(distinct ...), count(all...)"

#. Tag: para
#: query_hql.xml:371
#, no-c-format
msgid ""
"You may use arithmetic operators, concatenation, and recognized SQL "
"functions in the select clause:"
msgstr ""
"Vous pouvez utiliser des opérateurs arithmétiques, la concaténation, et des "
"fonctions SQL reconnues dans la clause select :"

#. Tag: programlisting
#: query_hql.xml:376
#, no-c-format
msgid ""
"<![CDATA[select cat.weight + sum(kitten.weight)\n"
"from Cat cat\n"
"    join cat.kittens kitten\n"
"group by cat.id, cat.weight]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:378
#, no-c-format
msgid ""
"<![CDATA[select firstName||' '||initial||' '||upper(lastName) from Person]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:380
#, no-c-format
msgid ""
"The <literal>distinct</literal> and <literal>all</literal> keywords may be "
"used and have the same semantics as in SQL."
msgstr ""
"Les mots clé <literal>distinct</literal> et <literal>all</literal> peuvent "
"être utilisés et ont la même signification qu'en SQL."

#. Tag: programlisting
#: query_hql.xml:385
#, no-c-format
msgid ""
"<![CDATA[select distinct cat.name from Cat cat\n"
"\n"
"select count(distinct cat.name), count(cat) from Cat cat]]>"
msgstr ""

#. Tag: title
#: query_hql.xml:390
#, no-c-format
msgid "Polymorphic queries"
msgstr "Requêtes polymorphiques"

#. Tag: para
#: query_hql.xml:392
#, no-c-format
msgid "A query like:"
msgstr "Une requête comme:"

#. Tag: para
#: query_hql.xml:398
#, no-c-format
msgid ""
"returns instances not only of <literal>Cat</literal>, but also of subclasses "
"like <literal>DomesticCat</literal>. Hibernate queries may name "
"<emphasis>any</emphasis> Java class or interface in the <literal>from</"
"literal> clause. The query will return instances of all persistent classes "
"that extend that class or implement the interface. The following query would "
"return all persistent objects:"
msgstr ""
"retourne non seuleument les instances de <literal>Cat</literal>, mais aussi "
"celles des sous classes comme <literal>DomesticCat</literal>. Les requêtes "
"Hibernate peuvent nommer n'importe quelle classe ou interface Java dans la "
"clause <literal>from</literal>. La requête retournera les instances de "
"toutes les classes persistantes qui étendent cette classe ou implémente "
"cette interface. La requête suivante retournera tous les objets persistants :"

#. Tag: programlisting
#: query_hql.xml:406
#, no-c-format
msgid "<![CDATA[from java.lang.Object o]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:408
#, no-c-format
msgid ""
"The interface <literal>Named</literal> might be implemented by various "
"persistent classes:"
msgstr ""
"L'interface <literal>Named</literal> peut être implémentée par plusieurs "
"classes persistantes :"

#. Tag: programlisting
#: query_hql.xml:413
#, no-c-format
msgid "<![CDATA[from Named n, Named m where n.name = m.name]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:415
#, no-c-format
msgid ""
"Note that these last two queries will require more than one SQL "
"<literal>SELECT</literal>. This means that the <literal>order by</literal> "
"clause does not correctly order the whole result set. (It also means you "
"can't call these queries using <literal>Query.scroll()</literal>.)"
msgstr ""
"Notez que ces deux dernières requêtes nécessitent plus d'un <literal>SELECT</"
"literal> SQL. Ce qui signifie que la clause <literal>order by</literal> ne "
"trie pas correctement la totalité des résultats (cela signifie aussi que "
"vous ne pouvez exécuter ces requêtes en appelant <literal>Query.scroll()</"
"literal>)."

#. Tag: title
#: query_hql.xml:424
#, no-c-format
msgid "The where clause"
msgstr "La clause where"

#. Tag: para
#: query_hql.xml:426
#, no-c-format
msgid ""
"The <literal>where</literal> clause allows you to narrow the list of "
"instances returned. If no alias exists, you may refer to properties by name:"
msgstr ""
"La clause <literal>where</literal> vous permet de réduire la liste des "
"instances retournées. Si aucun alias n'existe, vous pouvez vous référer aux "
"propriétés par leur nom :"

#. Tag: programlisting
#: query_hql.xml:431
#, no-c-format
msgid "<![CDATA[from Cat where name='Fritz']]>"
msgstr ""

#. Tag: para
#: query_hql.xml:433
#, no-c-format
msgid "If there is an alias, use a qualified property name:"
msgstr "S'il y a un alias, utilisez un nom de propriété qualifié :"

#. Tag: programlisting
#: query_hql.xml:437
#, no-c-format
msgid "<![CDATA[from Cat as cat where cat.name='Fritz']]>"
msgstr ""

#. Tag: para
#: query_hql.xml:439
#, no-c-format
msgid "returns instances of <literal>Cat</literal> named 'Fritz'."
msgstr ""
"retourne les instances de <literal>Cat</literal> dont name est égale à "
"'Fritz'."

#. Tag: programlisting
#: query_hql.xml:443
#, no-c-format
msgid ""
"<![CDATA[select foo\n"
"from Foo foo, Bar bar\n"
"where foo.startDate = bar.date]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:445
#, no-c-format
msgid ""
"will return all instances of <literal>Foo</literal> for which there exists "
"an instance of <literal>bar</literal> with a <literal>date</literal> "
"property equal to the <literal>startDate</literal> property of the "
"<literal>Foo</literal>. Compound path expressions make the <literal>where</"
"literal> clause extremely powerful. Consider:"
msgstr ""
"retournera les instances de <literal>Foo</literal> pour lesquelles il existe "
"une instance de <literal>bar</literal> avec la propriété <literal>date</"
"literal> est égale à la propriété <literal>startDate</literal> de "
"<literal>Foo</literal>. Les expressions utilisant la navigation rendent la "
"clause <literal>where</literal> extrêmement puissante. Soit :"

#. Tag: programlisting
#: query_hql.xml:454
#, no-c-format
msgid "<![CDATA[from Cat cat where cat.mate.name is not null]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:456
#, no-c-format
msgid ""
"This query translates to an SQL query with a table (inner) join. If you were "
"to write something like"
msgstr ""
"Cette requête se traduit en SQL par une jointure interne à une table. Si "
"vous souhaitez écrire quelque chose comme :"

#. Tag: programlisting
#: query_hql.xml:461
#, no-c-format
msgid ""
"<![CDATA[from Foo foo\n"
"where foo.bar.baz.customer.address.city is not null]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:463
#, no-c-format
msgid ""
"you would end up with a query that would require four table joins in SQL."
msgstr ""
"vous finiriez avec une requête qui nécessiterait quatre jointures en SQL."

#. Tag: para
#: query_hql.xml:467
#, no-c-format
msgid ""
"The <literal>=</literal> operator may be used to compare not only "
"properties, but also instances:"
msgstr ""
"L'opérateur <literal>=</literal> peut être utilisé pour comparer aussi bien "
"des propriétés que des instances :"

#. Tag: programlisting
#: query_hql.xml:472
#, no-c-format
msgid "<![CDATA[from Cat cat, Cat rival where cat.mate = rival.mate]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:474
#, no-c-format
msgid ""
"<![CDATA[select cat, mate\n"
"from Cat cat, Cat mate\n"
"where cat.mate = mate]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:476
#, no-c-format
msgid ""
"The special property (lowercase) <literal>id</literal> may be used to "
"reference the unique identifier of an object. See <xref linkend=\"queryhql-"
"identifier-property\"/> for more information."
msgstr ""
"La propriété spéciale (en minuscule) <literal>id</literal> peut être "
"utilisée pour faire référence à l'identifiant d'un objet (vous pouvez aussi "
"utiliser le nom de cette propriété)."

#. Tag: programlisting
#: query_hql.xml:482
#, no-c-format
msgid ""
"<![CDATA[from Cat as cat where cat.id = 123\n"
"\n"
"from Cat as cat where cat.mate.id = 69]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:484
#, no-c-format
msgid "The second query is efficient. No table join is required!"
msgstr ""
"La seconde requête est particulièrement efficace. Aucune jointure n'est "
"nécessaire !"

#. Tag: para
#: query_hql.xml:488
#, no-c-format
msgid ""
"Properties of composite identifiers may also be used. Suppose "
"<literal>Person</literal> has a composite identifier consisting of "
"<literal>country</literal> and <literal>medicareNumber</literal>. Again, see "
"<xref linkend=\"queryhql-identifier-property\"/> for more information "
"regarding referencing identifier properties."
msgstr ""
"Les propriétés d'un identifiant composé peuvent aussi être utilisées. "
"Supposez que <literal>Person</literal> ait un identifiant composé de "
"<literal>country</literal> et <literal>medicareNumber</literal>."

#. Tag: programlisting
#: query_hql.xml:495
#, no-c-format
msgid ""
"<![CDATA[from bank.Person person\n"
"where person.id.country = 'AU'\n"
"    and person.id.medicareNumber = 123456]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:497
#, no-c-format
msgid ""
"<![CDATA[from bank.Account account\n"
"where account.owner.id.country = 'AU'\n"
"    and account.owner.id.medicareNumber = 123456]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:499
#, no-c-format
msgid "Once again, the second query requires no table join."
msgstr "Une fois de plus, la seconde requête ne nécessite pas de jointure."

#. Tag: para
#: query_hql.xml:503
#, no-c-format
msgid ""
"Likewise, the special property <literal>class</literal> accesses the "
"discriminator value of an instance in the case of polymorphic persistence. A "
"Java class name embedded in the where clause will be translated to its "
"discriminator value."
msgstr ""
"De même, la propriété spéciale <literal>class</literal> interroge la valeur "
"discriminante d'une instance dans le cas d'une persistance polymorphique. Le "
"nom d'une classe Java incorporée dans la clause where sera traduite par sa "
"valeur discriminante."

#. Tag: programlisting
#: query_hql.xml:509
#, no-c-format
msgid "<![CDATA[from Cat cat where cat.class = DomesticCat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:511
#, no-c-format
msgid ""
"You may also use components or composite user types, or properties of said "
"component types. See <xref linkend=\"queryhql-components\"/> for more "
"details."
msgstr ""
"Vous pouvez aussi spécifier les propriétés des composants ou types "
"utilisateurs composés (components, composite user types etc). N'essayez "
"jamais d'utiliser un expression de navigation qui se terminerait par une "
"propriété de type composant (qui est différent d'une propriété d'un "
"composant). Par exemple, si <literal>store.owner</literal> est une entité "
"avec un composant <literal>address</literal>"

#. Tag: para
#: query_hql.xml:516
#, no-c-format
msgid ""
"An \"any\" type has the special properties <literal>id</literal> and "
"<literal>class</literal>, allowing us to express a join in the following way "
"(where <literal>AuditLog.item</literal> is a property mapped with "
"<literal>&lt;any&gt;</literal>)."
msgstr ""
"Un type \"any\" possède les propriétés spéciales <literal>id</literal> et "
"<literal>class</literal>, qui nous permettent d'exprimer une jointure de la "
"manière suivante (où <literal>AuditLog.item</literal> est une propriété "
"mappée avec <literal>&lt;any&gt;</literal>)."

#. Tag: programlisting
#: query_hql.xml:522
#, no-c-format
msgid ""
"<![CDATA[from AuditLog log, Payment payment\n"
"where log.item.class = 'Payment' and log.item.id = payment.id]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:524
#, no-c-format
msgid ""
"Notice that <literal>log.item.class</literal> and <literal>payment.class</"
"literal> would refer to the values of completely different database columns "
"in the above query."
msgstr ""
"Dans la requête précédente, notez que <literal>log.item.class</literal> et "
"<literal>payment.class</literal> feraient référence à des valeurs de "
"colonnes de la base de données complètement différentes."

#. Tag: title
#: query_hql.xml:532
#, no-c-format
msgid "Expressions"
msgstr "Expressions"

#. Tag: para
#: query_hql.xml:534
#, no-c-format
msgid ""
"Expressions allowed in the <literal>where</literal> clause include most of "
"the kind of things you could write in SQL:"
msgstr ""
"Les expressions permises dans la clause <literal>where</literal> incluent la "
"plupart des choses que vous pouvez utiliser en SQL :"

#. Tag: para
#: query_hql.xml:541
#, no-c-format
msgid "mathematical operators <literal>+, -, *, /</literal>"
msgstr "opérateurs mathématiques <literal>+, -, *, /</literal>"

#. Tag: para
#: query_hql.xml:546
#, no-c-format
msgid ""
"binary comparison operators <literal>=, &gt;=, &lt;=, &lt;&gt;, !=, like</"
"literal>"
msgstr ""
"opérateur de comparaison binaire <literal>=, &gt;=, &lt;=, &lt;&gt;, !=, "
"like</literal>"

#. Tag: para
#: query_hql.xml:551
#, no-c-format
msgid "logical operations <literal>and, or, not</literal>"
msgstr "opérateurs logiques <literal>and, or, not</literal>"

#. Tag: para
#: query_hql.xml:556
#, no-c-format
msgid "Parentheses <literal>( )</literal>, indicating grouping"
msgstr "Parenthèses <literal>( )</literal>, indiquant un regroupement"

#. Tag: para
#: query_hql.xml:561
#, no-c-format
msgid ""
"<literal>in</literal>, <literal>not in</literal>, <literal>between</"
"literal>, <literal>is null</literal>, <literal>is not null</literal>, "
"<literal>is empty</literal>, <literal>is not empty</literal>, "
"<literal>member of</literal> and <literal>not member of</literal>"
msgstr ""
"<literal>in</literal>, <literal>not in</literal>, <literal>between</"
"literal>, <literal>is null</literal>, <literal>is not null</literal>, "
"<literal>is empty</literal>, <literal>is not empty</literal>, "
"<literal>member of</literal> and <literal>not member of</literal>"

#. Tag: para
#: query_hql.xml:574
#, no-c-format
msgid ""
"\"Simple\" case, <literal>case ... when ... then ... else ... end</literal>, "
"and \"searched\" case, <literal>case when ... then ... else ... end</literal>"
msgstr ""
"\"Simple\" case, <literal>case ... when ... then ... else ... end</literal>, "
"and \"searched\" case, <literal>case when ... then ... else ... end</literal>"

#. Tag: para
#: query_hql.xml:580
#, no-c-format
msgid ""
"string concatenation <literal>...||...</literal> or <literal>concat(...,...)"
"</literal>"
msgstr ""
"concatenation de chaîne de caractères <literal>...||...</literal> ou "
"<literal>concat(...,...)</literal>"

#. Tag: para
#: query_hql.xml:585
#, no-c-format
msgid ""
"<literal>current_date()</literal>, <literal>current_time()</literal>, "
"<literal>current_timestamp()</literal>"
msgstr ""
"<literal>current_date()</literal>, <literal>current_time()</literal>, "
"<literal>current_timestamp()</literal>"

#. Tag: para
#: query_hql.xml:591
#, no-c-format
msgid ""
"<literal>second(...)</literal>, <literal>minute(...)</literal>, <literal>hour"
"(...)</literal>, <literal>day(...)</literal>, <literal>month(...)</literal>, "
"<literal>year(...)</literal>,"
msgstr ""
"<literal>second(...)</literal>, <literal>minute(...)</literal>, <literal>hour"
"(...)</literal>, <literal>day(...)</literal>, <literal>month(...)</literal>, "
"<literal>year(...)</literal>,"

#. Tag: para
#: query_hql.xml:598
#, no-c-format
msgid ""
"Any function or operator defined by EJB-QL 3.0: <literal>substring(), trim"
"(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), mod()"
"</literal>"
msgstr ""
"N'importe quel fonction ou opérateur défini par EJB-QL 3.0 : "
"<literal>substring(), trim(), lower(), upper(), length(), locate(), abs(), "
"sqrt(), bit_length(), mod()</literal>"

#. Tag: para
#: query_hql.xml:604
#, no-c-format
msgid "<literal>coalesce()</literal> and <literal>nullif()</literal>"
msgstr "<literal>coalesce()</literal> et <literal>nullif()</literal>"

#. Tag: para
#: query_hql.xml:609
#, no-c-format
msgid ""
"<literal>str()</literal> for converting numeric or temporal values to a "
"readable string"
msgstr ""
"<literal>str()</literal> pour convertir des valeurs numériques ou "
"temporelles vers une chaîne de caractères lisible"

#. Tag: para
#: query_hql.xml:615
#, no-c-format
msgid ""
"<literal>cast(... as ...)</literal>, where the second argument is the name "
"of a Hibernate type, and <literal>extract(... from ...)</literal> if ANSI "
"<literal>cast()</literal> and <literal>extract()</literal> is supported by "
"the underlying database"
msgstr ""
"<literal>cast(... as ...)</literal>, où le second argument est le nom d'un "
"type Hibernate, et <literal>extract(... from ...)</literal> si le "
"<literal>cast()</literal> ANSI et <literal>extract()</literal> sont "
"supportés par la base de données sous-jacente"

#. Tag: para
#: query_hql.xml:623
#, no-c-format
msgid ""
"the HQL <literal>index()</literal> function, that applies to aliases of a "
"joined indexed collection"
msgstr ""
"La fonction HQL <literal>index()</literal>, qui s'applique aux alias d'une "
"collection indexée jointe"

#. Tag: para
#: query_hql.xml:629
#, no-c-format
msgid ""
"HQL functions that take collection-valued path expressions: <literal>size(), "
"minelement(), maxelement(), minindex(), maxindex()</literal>, along with the "
"special <literal>elements()</literal> and <literal>indices</literal> "
"functions which may be quantified using <literal>some, all, exists, any, in</"
"literal>."
msgstr ""
"Les fonctions HQL qui s'appliquent expressions représentant des "
"collections : <literal>size(), minelement(), maxelement(), minindex(), "
"maxindex()</literal>, ainsi que les fonctions spéciales <literal>elements()</"
"literal> et <literal>indices</literal> qui peuvent être quantifiées en "
"utilisant <literal>some, all, exists, any, in</literal>."

#. Tag: para
#: query_hql.xml:637
#, no-c-format
msgid ""
"Any database-supported SQL scalar function like <literal>sign()</literal>, "
"<literal>trunc()</literal>, <literal>rtrim()</literal>, <literal>sin()</"
"literal>"
msgstr ""
"N'importe quelle fonction scalaire supportée par la base de données comme "
"<literal>sign()</literal>, <literal>trunc()</literal>, <literal>rtrim()</"
"literal>, <literal>sin()</literal>"

#. Tag: para
#: query_hql.xml:643
#, no-c-format
msgid "JDBC-style positional parameters <literal>?</literal>"
msgstr "Les paramètres positionnels de JDBC <literal>?</literal>"

#. Tag: para
#: query_hql.xml:648
#, no-c-format
msgid ""
"named parameters <literal>:name</literal>, <literal>:start_date</literal>, "
"<literal>:x1</literal>"
msgstr ""
"paramètres nommés <literal>:name</literal>, <literal>:start_date</literal>, "
"<literal>:x1</literal>"

#. Tag: para
#: query_hql.xml:653
#, no-c-format
msgid ""
"SQL literals <literal>'foo'</literal>, <literal>69</literal>, <literal>6.66E"
"+2</literal>, <literal>'1970-01-01 10:00:01.0'</literal>"
msgstr ""
"littéral SQL <literal>'foo'</literal>, <literal>69</literal>, <literal>'1970-"
"01-01 10:00:01.0'</literal>"

#. Tag: para
#: query_hql.xml:659
#, no-c-format
msgid ""
"Java <literal>public static final</literal> constants <literal>eg.Color."
"TABBY</literal>"
msgstr ""
"Constantes Java <literal>public static final</literal><literal>eg.Color."
"TABBY</literal>"

#. Tag: para
#: query_hql.xml:665
#, no-c-format
msgid ""
"<literal>in</literal> and <literal>between</literal> may be used as follows:"
msgstr ""
"<literal>in</literal> et <literal>between</literal> peuvent être utilisés "
"comme suit :"

#. Tag: programlisting
#: query_hql.xml:669
#, no-c-format
msgid "<![CDATA[from DomesticCat cat where cat.name between 'A' and 'B']]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:671
#, no-c-format
msgid ""
"<![CDATA[from DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:673
#, no-c-format
msgid "and the negated forms may be written"
msgstr "et la forme négative peut être écrite"

#. Tag: programlisting
#: query_hql.xml:677
#, no-c-format
msgid "<![CDATA[from DomesticCat cat where cat.name not between 'A' and 'B']]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:679
#, no-c-format
msgid ""
"<![CDATA[from DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )]]"
">"
msgstr ""

#. Tag: para
#: query_hql.xml:681
#, no-c-format
msgid ""
"Likewise, <literal>is null</literal> and <literal>is not null</literal> may "
"be used to test for null values."
msgstr ""
"De même, <literal>is null</literal> et <literal>is not null</literal> "
"peuvent être utilisés pour tester les valeurs nulle."

#. Tag: para
#: query_hql.xml:686
#, no-c-format
msgid ""
"Booleans may be easily used in expressions by declaring HQL query "
"substitutions in Hibernate configuration:"
msgstr ""
"Les booléens peuvent être facilement utilisés en déclarant les substitutions "
"de requêtes dans la configuration Hibernate :"

#. Tag: programlisting
#: query_hql.xml:691
#, no-c-format
msgid ""
"<![CDATA[<property name=\"hibernate.query.substitutions\">true 1, false 0</"
"property>]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:693
#, no-c-format
msgid ""
"This will replace the keywords <literal>true</literal> and <literal>false</"
"literal> with the literals <literal>1</literal> and <literal>0</literal> in "
"the translated SQL from this HQL:"
msgstr ""
"Ce qui remplacera les mots clés <literal>true</literal> et <literal>false</"
"literal> par <literal>1</literal> et <literal>0</literal> dans la traduction "
"SQL du HQL suivant :"

#. Tag: programlisting
#: query_hql.xml:698
#, no-c-format
msgid "<![CDATA[from Cat cat where cat.alive = true]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:700
#, no-c-format
msgid ""
"You may test the size of a collection with the special property "
"<literal>size</literal>, or the special <literal>size()</literal> function."
msgstr ""
"Vous pouvez tester la taille d'une collection par la propriété spéciale "
"<literal>size</literal>, ou la fonction spéciale <literal>size()</literal>."

#. Tag: programlisting
#: query_hql.xml:705
#, no-c-format
msgid "<![CDATA[from Cat cat where cat.kittens.size > 0]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:707
#, no-c-format
msgid "<![CDATA[from Cat cat where size(cat.kittens) > 0]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:709
#, no-c-format
msgid ""
"For indexed collections, you may refer to the minimum and maximum indices "
"using <literal>minindex</literal> and <literal>maxindex</literal> functions. "
"Similarly, you may refer to the minimum and maximum elements of a collection "
"of basic type using the <literal>minelement</literal> and "
"<literal>maxelement</literal> functions."
msgstr ""
"Pour les collections indexées, vous pouvez faire référence aux indices "
"minimum et maximum en utilisant les fonctions <literal>minindex</literal> "
"and <literal>maxindex</literal>. De manière similaire, vous pouvez faire "
"référence aux éléments minimum et maximum d'une collection de type basiques "
"en utilisant les fonctions <literal>minelement</literal> et "
"<literal>maxelement</literal>."

#. Tag: programlisting
#: query_hql.xml:717
#, no-c-format
msgid ""
"<![CDATA[from Calendar cal where maxelement(cal.holidays) > current_date]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:719
#, no-c-format
msgid "<![CDATA[from Order order where maxindex(order.items) > 100]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:721
#, no-c-format
msgid "<![CDATA[from Order order where minelement(order.items) > 10000]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:723
#, no-c-format
msgid ""
"The SQL functions <literal>any, some, all, exists, in</literal> are "
"supported when passed the element or index set of a collection "
"(<literal>elements</literal> and <literal>indices</literal> functions) or "
"the result of a subquery (see below)."
msgstr ""
"Les fonctions SQL <literal>any, some, all, exists, in</literal> supportent "
"que leur soient passées l'élément, l'index d'une collection (fonctions "
"<literal>elements</literal> et <literal>indices</literal>) ou le résultat "
"d'une sous requête (voir ci dessous)."

#. Tag: programlisting
#: query_hql.xml:729
#, no-c-format
msgid ""
"<![CDATA[select mother from Cat as mother, Cat as kit\n"
"where kit in elements(foo.kittens)]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:731
#, no-c-format
msgid ""
"<![CDATA[select p from NameList list, Person p\n"
"where p.name = some elements(list.names)]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:733
#, no-c-format
msgid "<![CDATA[from Cat cat where exists elements(cat.kittens)]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:735
#, no-c-format
msgid "<![CDATA[from Player p where 3 > all elements(p.scores)]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:737
#, no-c-format
msgid "<![CDATA[from Show show where 'fizard' in indices(show.acts)]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:739
#, no-c-format
msgid ""
"Note that these constructs - <literal>size</literal>, <literal>elements</"
"literal>, <literal>indices</literal>, <literal>minindex</literal>, "
"<literal>maxindex</literal>, <literal>minelement</literal>, "
"<literal>maxelement</literal> - may only be used in the where clause in "
"Hibernate3."
msgstr ""
"Notez que l'écriture de - <literal>size</literal>, <literal>elements</"
"literal>, <literal>indices</literal>, <literal>minindex</literal>, "
"<literal>maxindex</literal>, <literal>minelement</literal>, "
"<literal>maxelement</literal> - peuvent seulement être utilisée dans la "
"clause where dans Hibernate3."

#. Tag: para
#: query_hql.xml:746
#, no-c-format
msgid ""
"Elements of indexed collections (arrays, lists, maps) may be referred to by "
"index (in a where clause only):"
msgstr ""
"Les éléments de collections indexées (arrays, lists, maps) peuvent être "
"référencés via index (dans une clause where seulement) :"

#. Tag: programlisting
#: query_hql.xml:751
#, no-c-format
msgid "<![CDATA[from Order order where order.items[0].id = 1234]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:753
#, no-c-format
msgid ""
"<![CDATA[select person from Person person, Calendar calendar\n"
"where calendar.holidays['national day'] = person.birthDay\n"
"    and person.nationality.calendar = calendar]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:755
#, no-c-format
msgid ""
"<![CDATA[select item from Item item, Order order\n"
"where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11]]"
">"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:757
#, no-c-format
msgid ""
"<![CDATA[select item from Item item, Order order\n"
"where order.items[ maxindex(order.items) ] = item and order.id = 11]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:759
#, no-c-format
msgid ""
"The expression inside <literal>[]</literal> may even be an arithmetic "
"expression."
msgstr ""
"L'expression entre <literal>[]</literal> peut même être une expression "
"arithmétique."

#. Tag: programlisting
#: query_hql.xml:763
#, no-c-format
msgid ""
"<![CDATA[select item from Item item, Order order\n"
"where order.items[ size(order.items) - 1 ] = item]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:765
#, no-c-format
msgid ""
"HQL also provides the built-in <literal>index()</literal> function, for "
"elements of a one-to-many association or collection of values."
msgstr ""
"HQL propose aussi une fonction <literal>index()</literal> interne, pour les "
"éléments d'une association one-to-many ou d'une collections de valeurs."

#. Tag: programlisting
#: query_hql.xml:770
#, no-c-format
msgid ""
"<![CDATA[select item, index(item) from Order order\n"
"    join order.items item\n"
"where index(item) < 5]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:772
#, no-c-format
msgid "Scalar SQL functions supported by the underlying database may be used"
msgstr ""
"Les fonctions SQL scalaires supportées par la base de données utilisée "
"peuvent être utilisées"

#. Tag: programlisting
#: query_hql.xml:776
#, no-c-format
msgid "<![CDATA[from DomesticCat cat where upper(cat.name) like 'FRI%']]>"
msgstr ""

#. Tag: para
#: query_hql.xml:778
#, no-c-format
msgid ""
"If you are not yet convinced by all this, think how much longer and less "
"readable the following query would be in SQL:"
msgstr ""
"Si vous n'êtes pas encore convaincu par tout cela, imaginez la taille et "
"l'illisibilité qui caractériseraient la transformation SQL de la requête HQL "
"suivante :"

#. Tag: programlisting
#: query_hql.xml:783
#, no-c-format
msgid ""
"<![CDATA[select cust\n"
"from Product prod,\n"
"    Store store\n"
"    inner join store.customers cust\n"
"where prod.name = 'widget'\n"
"    and store.location.name in ( 'Melbourne', 'Sydney' )\n"
"    and prod = all elements(cust.currentOrder.lineItems)]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:785
#, no-c-format
msgid "<emphasis>Hint:</emphasis> something like"
msgstr "<emphasis>Un indice :</emphasis> cela donnerait quelque chose comme"

#. Tag: programlisting
#: query_hql.xml:789
#, no-c-format
msgid ""
"<![CDATA[SELECT cust.name, cust.address, cust.phone, cust.id, cust."
"current_order\n"
"FROM customers cust,\n"
"    stores store,\n"
"    locations loc,\n"
"    store_customers sc,\n"
"    product prod\n"
"WHERE prod.name = 'widget'\n"
"    AND store.loc_id = loc.id\n"
"    AND loc.name IN ( 'Melbourne', 'Sydney' )\n"
"    AND sc.store_id = store.id\n"
"    AND sc.cust_id = cust.id\n"
"    AND prod.id = ALL(\n"
"        SELECT item.prod_id\n"
"        FROM line_items item, orders o\n"
"        WHERE item.order_id = o.id\n"
"            AND cust.current_order = o.id\n"
"    )]]>"
msgstr ""

#. Tag: title
#: query_hql.xml:794
#, no-c-format
msgid "The order by clause"
msgstr "La clause order by"

#. Tag: para
#: query_hql.xml:796
#, no-c-format
msgid ""
"The list returned by a query may be ordered by any property of a returned "
"class or components:"
msgstr ""
"La liste retounée par la requête peut être triée par n'importe quelle "
"propriété de la classe ou du composant retourné :"

#. Tag: programlisting
#: query_hql.xml:800
#, no-c-format
msgid ""
"<![CDATA[from DomesticCat cat\n"
"order by cat.name asc, cat.weight desc, cat.birthdate]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:802
#, no-c-format
msgid ""
"The optional <literal>asc</literal> or <literal>desc</literal> indicate "
"ascending or descending order respectively."
msgstr ""
"Le mot optionnel <literal>asc</literal> ou <literal>desc</literal> indique "
"respectivement si le tri doit être croissant ou décroissant."

#. Tag: title
#: query_hql.xml:809
#, no-c-format
msgid "The group by clause"
msgstr "La clause group by"

#. Tag: para
#: query_hql.xml:811
#, no-c-format
msgid ""
"A query that returns aggregate values may be grouped by any property of a "
"returned class or components:"
msgstr ""
"Si la requête retourne des valeurs aggrégées, celles ci peuvent être "
"groupées par propriété ou composant :"

#. Tag: programlisting
#: query_hql.xml:815
#, no-c-format
msgid ""
"<![CDATA[select cat.color, sum(cat.weight), count(cat)\n"
"from Cat cat\n"
"group by cat.color]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:817
#, no-c-format
msgid ""
"<![CDATA[select foo.id, avg(name), max(name)\n"
"from Foo foo join foo.names name\n"
"group by foo.id]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:819
#, no-c-format
msgid "A <literal>having</literal> clause is also allowed."
msgstr "Une clause <literal>having</literal> est aussi permise."

#. Tag: programlisting
#: query_hql.xml:823
#, no-c-format
msgid ""
"<![CDATA[select cat.color, sum(cat.weight), count(cat)\n"
"from Cat cat\n"
"group by cat.color\n"
"having cat.color in (eg.Color.TABBY, eg.Color.BLACK)]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:825
#, no-c-format
msgid ""
"SQL functions and aggregate functions are allowed in the <literal>having</"
"literal> and <literal>order by</literal> clauses, if supported by the "
"underlying database (eg. not in MySQL)."
msgstr ""
"Les fonctions SQL et les fonctions d'aggrégations sont permises dans les "
"clauses <literal>having</literal> et <literal>order by</literal>, si elles "
"sont supportées par la base de données (ce que ne fait pas MySQL par "
"exemple)."

#. Tag: programlisting
#: query_hql.xml:831
#, no-c-format
msgid ""
"<![CDATA[select cat\n"
"from Cat cat\n"
"    join cat.kittens kitten\n"
"group by cat.id, cat.name, cat.other, cat.properties\n"
"having avg(kitten.weight) > 100\n"
"order by count(kitten) asc, sum(kitten.weight) desc]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:833
#, no-c-format
msgid ""
"Note that neither the <literal>group by</literal> clause nor the "
"<literal>order by</literal> clause may contain arithmetic expressions. Also "
"note that Hibernate currently does not expand a grouped entity, so you can't "
"write <literal>group by cat</literal> if all properties of <literal>cat</"
"literal> are non-aggregated. You have to list all non-aggregated properties "
"explicitly."
msgstr ""
"Notez que ni la clause <literal>group by</literal> ni la clause "
"<literal>order by</literal> ne peuvent contenir d'expressions arithmétiques."

#. Tag: title
#: query_hql.xml:845
#, no-c-format
msgid "Subqueries"
msgstr "Sous-requêtes"

#. Tag: para
#: query_hql.xml:847
#, no-c-format
msgid ""
"For databases that support subselects, Hibernate supports subqueries within "
"queries. A subquery must be surrounded by parentheses (often by an SQL "
"aggregate function call). Even correlated subqueries (subqueries that refer "
"to an alias in the outer query) are allowed."
msgstr ""
"Pour les bases de données le supportant, Hibernate supporte les sous "
"requêtes dans les requêtes. Une sous requête doit être entre parenthèses "
"(souvent pour un appel à une fonction d'agrégation SQL) Même les sous "
"requêtes corrélées (celles qui font référence à un alias de la requête "
"principale) sont supportées."

#. Tag: programlisting
#: query_hql.xml:853
#, no-c-format
msgid ""
"<![CDATA[from Cat as fatcat\n"
"where fatcat.weight > (\n"
"    select avg(cat.weight) from DomesticCat cat\n"
")]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:855
#, no-c-format
msgid ""
"<![CDATA[from DomesticCat as cat\n"
"where cat.name = some (\n"
"    select name.nickName from Name as name\n"
")]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:857
#, no-c-format
msgid ""
"<![CDATA[from Cat as cat\n"
"where not exists (\n"
"    from Cat as mate where mate.mate = cat\n"
")]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:859
#, no-c-format
msgid ""
"<![CDATA[from DomesticCat as cat\n"
"where cat.name not in (\n"
"    select name.nickName from Name as name\n"
")]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:861
#, no-c-format
msgid ""
"<![CDATA[select cat.id, (select max(kit.weight) from cat.kitten kit)\n"
"from Cat as cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:863
#, no-c-format
msgid "Note that HQL subqueries may occur only in the select or where clauses."
msgstr ""
"Notez que les sous-requêtes HQL peuvent arriver seulememnt dans les clauses "
"select ou where."

#. Tag: para
#: query_hql.xml:867
#, no-c-format
msgid ""
"Note that subqueries can also utilize <literal>row value constructor</"
"literal> syntax. See <xref linkend=\"queryhql-tuple\"/> for more details."
msgstr ""
"Note that subqueries can also utilize <literal>row value constructor</"
"literal> syntax. See <xref linkend=\"queryhql-tuple\"/> for more details."

#. Tag: title
#: query_hql.xml:875
#, no-c-format
msgid "HQL examples"
msgstr "Exemples HQL"

#. Tag: para
#: query_hql.xml:877
#, no-c-format
msgid ""
"Hibernate queries can be quite powerful and complex. In fact, the power of "
"the query language is one of Hibernate's main selling points. Here are some "
"example queries very similar to queries that I used on a recent project. "
"Note that most queries you will write are much simpler than these!"
msgstr ""
"Les requêtes Hibernate peuvent être relativement puissantes et complexes. En "
"fait, la puissance du langage de requêtage est l'un des avantages principaux "
"d'Hibernate. Voici quelques exemples très similaires aux requêtes que nous "
"avons utilisées lors d'un récent projet. Notez que la plupart des requêtes "
"que vous écrirez seront plus simples que les exemples suivantes !"

#. Tag: para
#: query_hql.xml:883
#, no-c-format
msgid ""
"The following query returns the order id, number of items and total value of "
"the order for all unpaid orders for a particular customer and given minimum "
"total value, ordering the results by total value. In determining the prices, "
"it uses the current catalog. The resulting SQL query, against the "
"<literal>ORDER</literal>, <literal>ORDER_LINE</literal>, <literal>PRODUCT</"
"literal>, <literal>CATALOG</literal> and <literal>PRICE</literal> tables has "
"four inner joins and an (uncorrelated) subselect."
msgstr ""
"La requête suivante retourne l'id de commande (order), le nombre d'articles "
"(items) et la valeur totale de la commande (order) pour toutes les commandes "
"non payées d'un client (customer) particulier pour un total minimum donné, "
"le tout trié par la valeur totale. La requête SQL générée sur les tables "
"<literal>ORDER</literal>, <literal>ORDER_LINE</literal>, <literal>PRODUCT</"
"literal>, <literal>CATALOG</literal> et <literal>PRICE</literal> est "
"composée de quatre jointures interne ainsi que d'une sous-requête (non "
"corrélée)."

#. Tag: programlisting
#: query_hql.xml:892
#, no-c-format
msgid ""
"<![CDATA[select order.id, sum(price.amount), count(item)\n"
"from Order as order\n"
"    join order.lineItems as item\n"
"    join item.product as product,\n"
"    Catalog as catalog\n"
"    join catalog.prices as price\n"
"where order.paid = false\n"
"    and order.customer = :customer\n"
"    and price.product = product\n"
"    and catalog.effectiveDate < sysdate\n"
"    and catalog.effectiveDate >= all (\n"
"        select cat.effectiveDate\n"
"        from Catalog as cat\n"
"        where cat.effectiveDate < sysdate\n"
"    )\n"
"group by order\n"
"having sum(price.amount) > :minAmount\n"
"order by sum(price.amount) desc]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:894
#, no-c-format
msgid ""
"What a monster! Actually, in real life, I'm not very keen on subqueries, so "
"my query was really more like this:"
msgstr ""
"Quel monstre ! En principe, nous ne sommes pas très fan des sous-requêtes, "
"la requête ressemblait donc plutôt à cela :"

#. Tag: programlisting
#: query_hql.xml:899
#, no-c-format
msgid ""
"<![CDATA[select order.id, sum(price.amount), count(item)\n"
"from Order as order\n"
"    join order.lineItems as item\n"
"    join item.product as product,\n"
"    Catalog as catalog\n"
"    join catalog.prices as price\n"
"where order.paid = false\n"
"    and order.customer = :customer\n"
"    and price.product = product\n"
"    and catalog = :currentCatalog\n"
"group by order\n"
"having sum(price.amount) > :minAmount\n"
"order by sum(price.amount) desc]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:901
#, no-c-format
msgid ""
"The next query counts the number of payments in each status, excluding all "
"payments in the <literal>AWAITING_APPROVAL</literal> status where the most "
"recent status change was made by the current user. It translates to an SQL "
"query with two inner joins and a correlated subselect against the "
"<literal>PAYMENT</literal>, <literal>PAYMENT_STATUS</literal> and "
"<literal>PAYMENT_STATUS_CHANGE</literal> tables."
msgstr ""
"La requête suivante compte le nombre de paiements (payments) pour chaque "
"status, en excluant les paiements dans le status <literal>AWAITING_APPROVAL</"
"literal> où le changement de status le plus récent à été fait par "
"l'utilisateur courant. En SQL, cette requête effectue deux jointures "
"internes et des sous requêtes corrélées sur les tables <literal>PAYMENT</"
"literal>, <literal>PAYMENT_STATUS</literal> et "
"<literal>PAYMENT_STATUS_CHANGE</literal>."

#. Tag: programlisting
#: query_hql.xml:909
#, no-c-format
msgid ""
"<![CDATA[select count(payment), status.name\n"
"from Payment as payment\n"
"    join payment.currentStatus as status\n"
"    join payment.statusChanges as statusChange\n"
"where payment.status.name <> PaymentStatus.AWAITING_APPROVAL\n"
"    or (\n"
"        statusChange.timeStamp = (\n"
"            select max(change.timeStamp)\n"
"            from PaymentStatusChange change\n"
"            where change.payment = payment\n"
"        )\n"
"        and statusChange.user <> :currentUser\n"
"    )\n"
"group by status.name, status.sortOrder\n"
"order by status.sortOrder]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:911
#, no-c-format
msgid ""
"If I would have mapped the <literal>statusChanges</literal> collection as a "
"list, instead of a set, the query would have been much simpler to write."
msgstr ""
"Si nous avions mappé la collection <literal>statusChanges</literal> comme "
"une liste, au lieu d'un ensemble, la requête aurait été plus facile à écrire."

#. Tag: programlisting
#: query_hql.xml:916
#, no-c-format
msgid ""
"<![CDATA[select count(payment), status.name\n"
"from Payment as payment\n"
"    join payment.currentStatus as status\n"
"where payment.status.name <> PaymentStatus.AWAITING_APPROVAL\n"
"    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user <> :"
"currentUser\n"
"group by status.name, status.sortOrder\n"
"order by status.sortOrder]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:918
#, no-c-format
msgid ""
"The next query uses the MS SQL Server <literal>isNull()</literal> function "
"to return all the accounts and unpaid payments for the organization to which "
"the current user belongs. It translates to an SQL query with three inner "
"joins, an outer join and a subselect against the <literal>ACCOUNT</literal>, "
"<literal>PAYMENT</literal>, <literal>PAYMENT_STATUS</literal>, "
"<literal>ACCOUNT_TYPE</literal>, <literal>ORGANIZATION</literal> and "
"<literal>ORG_USER</literal> tables."
msgstr ""
"La requête qui suit utilise la fonction de MS SQL <literal>isNull()</"
"literal> pour retourner tous les comptes (accounts) et paiements (payments) "
"impayés pour l'organisation à laquelle l'uilisateur (user) courant "
"appartient. Elle est traduite en SQL par trois jointures internes, une "
"jointure externe ainsi qu'une sous requête sur les tables <literal>ACCOUNT</"
"literal>, <literal>PAYMENT</literal>, <literal>PAYMENT_STATUS</literal>, "
"<literal>ACCOUNT_TYPE</literal>, <literal>ORGANIZATION</literal> et "
"<literal>ORG_USER</literal>."

#. Tag: programlisting
#: query_hql.xml:927
#, no-c-format
msgid ""
"<![CDATA[select account, payment\n"
"from Account as account\n"
"    left outer join account.payments as payment\n"
"where :currentUser in elements(account.holder.users)\n"
"    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, "
"PaymentStatus.UNPAID)\n"
"order by account.type.sortOrder, account.accountNumber, payment.dueDate]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:929
#, no-c-format
msgid ""
"For some databases, we would need to do away with the (correlated) subselect."
msgstr ""
"Pour d'autres base de données, nous aurions dû faire sans la sous-requête "
"(corrélée)."

#. Tag: programlisting
#: query_hql.xml:933
#, no-c-format
msgid ""
"<![CDATA[select account, payment\n"
"from Account as account\n"
"    join account.holder.users as user\n"
"    left outer join account.payments as payment\n"
"where :currentUser = user\n"
"    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, "
"PaymentStatus.UNPAID)\n"
"order by account.type.sortOrder, account.accountNumber, payment.dueDate]]>"
msgstr ""

#. Tag: title
#: query_hql.xml:938
#, no-c-format
msgid "Bulk update and delete"
msgstr "Mise à jour et suppression"

#. Tag: para
#: query_hql.xml:940
#, no-c-format
msgid ""
"HQL now supports <literal>update</literal>, <literal>delete</literal> and "
"<literal>insert ... select ...</literal> statements. See <xref linkend="
"\"batch-direct\"/> for details."
msgstr ""
"HQL supporte maintenant les expressions <literal>update</literal>, "
"<literal>delete</literal> et <literal>insert ... select ...</literal>. Voir "
"<xref linkend=\"batch-direct\"/> pour les détails."

#. Tag: title
#: query_hql.xml:948
#, no-c-format
msgid "Tips &amp; Tricks"
msgstr "Trucs &amp; Astuces"

#. Tag: para
#: query_hql.xml:950
#, no-c-format
msgid ""
"You can count the number of query results without actually returning them:"
msgstr ""
"Vous pouvez compter le nombre de résultats d'une requête sans les retourner :"

#. Tag: programlisting
#: query_hql.xml:954
#, no-c-format
msgid ""
"<![CDATA[( (Integer) session.createQuery(\"select count(*) from ....\")."
"iterate().next() ).intValue()]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:956
#, no-c-format
msgid "To order a result by the size of a collection, use the following query:"
msgstr ""
"Pour trier les résultats par la taille d'une collection, utilisez la requête "
"suivante :"

#. Tag: programlisting
#: query_hql.xml:960
#, no-c-format
msgid ""
"<![CDATA[select usr.id, usr.name\n"
"from User as usr\n"
"    left join usr.messages as msg\n"
"group by usr.id, usr.name\n"
"order by count(msg)]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:962
#, no-c-format
msgid ""
"If your database supports subselects, you can place a condition upon "
"selection size in the where clause of your query:"
msgstr ""
"Si votre base de données supporte les sous-requêtes, vous pouvez placer des "
"conditions sur la taille de la sélection dans la clause where de votre "
"requête:"

#. Tag: programlisting
#: query_hql.xml:967
#, no-c-format
msgid "<![CDATA[from User usr where size(usr.messages) >= 1]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:969
#, no-c-format
msgid "If your database doesn't support subselects, use the following query:"
msgstr ""
"Si votre base de données ne supporte pas les sous-requêtes, utilisez la "
"requête suivante :"

#. Tag: programlisting
#: query_hql.xml:973
#, no-c-format
msgid ""
"<![CDATA[select usr.id, usr.name\n"
"from User usr.name\n"
"    join usr.messages msg\n"
"group by usr.id, usr.name\n"
"having count(msg) >= 1]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:975
#, no-c-format
msgid ""
"As this solution can't return a <literal>User</literal> with zero messages "
"because of the inner join, the following form is also useful:"
msgstr ""
"Cette solution ne peut pas retourner un <literal>User</literal> avec zéro "
"message à cause de la jointure interne, la forme suivante peut donc être "
"utile :"

#. Tag: programlisting
#: query_hql.xml:980
#, no-c-format
msgid ""
"<![CDATA[select usr.id, usr.name\n"
"from User as usr\n"
"    left join usr.messages as msg\n"
"group by usr.id, usr.name\n"
"having count(msg) = 0]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:982
#, no-c-format
msgid "Properties of a JavaBean can be bound to named query parameters:"
msgstr ""
"Les propriétés d'un JavaBean peuvent être injectées dans les paramètres "
"nommés d'un requête :"

#. Tag: programlisting
#: query_hql.xml:986
#, no-c-format
msgid ""
"<![CDATA[Query q = s.createQuery(\"from foo Foo as foo where foo.name=:name "
"and foo.size=:size\");\n"
"q.setProperties(fooBean); // fooBean has getName() and getSize()\n"
"List foos = q.list();]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:988
#, no-c-format
msgid ""
"Collections are pageable by using the <literal>Query</literal> interface "
"with a filter:"
msgstr ""
"Les collections sont paginables via l'utilisation de l'interface "
"<literal>Query</literal> avec un filtre :"

#. Tag: programlisting
#: query_hql.xml:992
#, no-c-format
msgid ""
"<![CDATA[Query q = s.createFilter( collection, \"\" ); // the trivial "
"filter\n"
"q.setMaxResults(PAGE_SIZE);\n"
"q.setFirstResult(PAGE_SIZE * pageNumber);\n"
"List page = q.list();]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:994
#, no-c-format
msgid "Collection elements may be ordered or grouped using a query filter:"
msgstr ""
"Les éléments d'une collection peuvent être triés ou groupés en utilisant un "
"filtre de requête :"

#. Tag: programlisting
#: query_hql.xml:998
#, no-c-format
msgid ""
"<![CDATA[Collection orderedCollection = s.filter( collection, \"order by "
"this.amount\" );\n"
"Collection counts = s.filter( collection, \"select this.type, count(this) "
"group by this.type\" );]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:1000
#, no-c-format
msgid "You can find the size of a collection without initializing it:"
msgstr "Vous pouvez récupérer la taille d'une collection sans l'initialiser :"

#. Tag: programlisting
#: query_hql.xml:1004
#, no-c-format
msgid ""
"<![CDATA[( (Integer) session.createQuery(\"select count(*) from ....\")."
"iterate().next() ).intValue();]]>"
msgstr ""

#. Tag: title
#: query_hql.xml:1009
#, no-c-format
msgid "Components"
msgstr "translator-credits"

#. Tag: para
#: query_hql.xml:1011
#, no-c-format
msgid ""
"Components might be used in just about every way that simple value types can "
"be used in HQL queries. They can appear in the <literal>select</literal> "
"clause:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1016 query_hql.xml:1062
#, no-c-format
msgid "<![CDATA[select p.name from Person p]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1017
#, no-c-format
msgid "<![CDATA[select p.name.first from Person p]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:1019
#, no-c-format
msgid ""
"where the Person's name property is a component. Components can also be used "
"in the <literal>where</literal> clause:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1024
#, no-c-format
msgid "<![CDATA[from Person p where p.name = :name]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1025
#, no-c-format
msgid "<![CDATA[from Person p where p.name.first = :firstName]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:1027
#, no-c-format
msgid "Components can also be used in the <literal>order by</literal> clause:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1031
#, no-c-format
msgid "<![CDATA[from Person p order by p.name]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1032
#, no-c-format
msgid "<![CDATA[from Person p order by p.name.first]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:1034
#, no-c-format
msgid ""
"Another common use of components is in <link linkend=\"queryhql-tuple\">row "
"value constructors</link>."
msgstr ""

#. Tag: title
#: query_hql.xml:1040
#, no-c-format
msgid "Row value constructor syntax"
msgstr ""

#. Tag: para
#: query_hql.xml:1042
#, no-c-format
msgid ""
"HQL supports the use of ANSI SQL <literal>row value constructor</literal> "
"syntax (sometimes called <literal>tuple</literal> syntax), even though the "
"underlying database may not support that notion. Here we are generally "
"referring to multi-valued comparisons, typically associated with components. "
"Consider an entity Person which defines a name component:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1049
#, no-c-format
msgid ""
"<![CDATA[from Person p where p.name.first='John' and p.name."
"last='Jingleheimer-Schmidt']]>"
msgstr ""

#. Tag: para
#: query_hql.xml:1051
#, no-c-format
msgid ""
"That's valid syntax, although a little verbose. It be nice to make this a "
"bit more concise and use <literal>row value constructor</literal> syntax:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1056
#, no-c-format
msgid "<![CDATA[from Person p where p.name=('John', 'Jingleheimer-Schmidt')]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:1058
#, no-c-format
msgid ""
"It can also be useful to specify this in the <literal>select</literal> "
"clause:"
msgstr ""

#. Tag: para
#: query_hql.xml:1064
#, no-c-format
msgid ""
"Another time using <literal>row value constructor</literal> syntax can be "
"beneficial is when using subqueries needing to compare against multiple "
"values:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1069
#, no-c-format
msgid ""
"<![CDATA[from Cat as cat\n"
"where not ( cat.name, cat.color ) in (\n"
"    select cat.name, cat.color from DomesticCat cat\n"
")]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:1071
#, no-c-format
msgid ""
"One thing to consider when deciding if you want to use this syntax is that "
"the query will be dependent upon the ordering of the component sub-"
"properties in the metadata."
msgstr ""
