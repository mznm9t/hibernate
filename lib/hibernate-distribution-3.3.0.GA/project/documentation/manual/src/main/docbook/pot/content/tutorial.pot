# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2008-08-14 15:28+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: application/x-xml2pot; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: tutorial.xml:33
#, no-c-format
msgid "Introduction to Hibernate"
msgstr ""

#. Tag: title
#: tutorial.xml:36
#, no-c-format
msgid "Preface"
msgstr ""

#. Tag: para
#: tutorial.xml:38
#, no-c-format
msgid "This chapter is an introduction to Hibernate by way of a tutorial, intended for new users of Hibernate. We start with a simple application using an in-memory database. We build the application in small, easy to understand steps. The tutorial is based on another, earlier one developed by Michael Gloegl. All code is contained in the <filename>tutorials/web</filename> directory of the project source."
msgstr ""

#. Tag: para
#: tutorial.xml:51
#, no-c-format
msgid "This tutorial expects the user have knowledge of both Java and SQL. If you are new or uncomfortable with either, it is advised that you start with a good introduction to that technology prior to attempting to learn Hibernate. It will save time and effort in the long run."
msgstr ""

#. Tag: para
#: tutorial.xml:61
#, no-c-format
msgid "There is another tutorial/example application in the <filename>/tutorials/eg</filename> directory of the project source. That example is console based and as such would not have the dependency on a servlet container to execute. The basic setup is the same as the instructions below."
msgstr ""

#. Tag: title
#: tutorial.xml:71
#, no-c-format
msgid "Part 1 - The first Hibernate Application"
msgstr ""

#. Tag: para
#: tutorial.xml:73
#, no-c-format
msgid "Let's assume we need a small database application that can store events we want to attend, and information about the host(s) of these events. We will use an in-memory, Java database named HSQLDB to avoid describing installation/setup of any particular database servers. Feel free to tweak this tutorial to use whatever database you feel comfortable using."
msgstr ""

#. Tag: para
#: tutorial.xml:82
#, no-c-format
msgid "The first thing we need to do is set up our development environment, and specifically to setup all the required dependencies to Hibernate as well as other libraries. Hibernate is built using Maven which amongst other features provides <literal>dependecy management</literal>; moreover it provides <emphasis>transitive</emphasis> <literal>dependecy management</literal> which simply means that to use Hibernate we can simply define our dependency on Hibernate, Hibernate itself defines the dependencies it needs which then become transitive dependencies of our project."
msgstr ""

#. Tag: programlisting
#: tutorial.xml:94
#, no-c-format
msgid ""
      "<![CDATA[.\n"
      "<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n"
      "         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
      "         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n"
      "\n"
      "    ...\n"
      "\n"
      "    <dependencies>\n"
      "        <dependency>\n"
      "            <groupId>${groupId}</groupId>\n"
      "            <artifactId>hibernate-core</artifactId>\n"
      "        </dependency>\n"
      "\n"
      "        <!-- Because this is a web app, we also have a dependency on the servlet api. -->\n"
      "        <dependency>\n"
      "            <groupId>javax.servlet</groupId>\n"
      "            <artifactId>servlet-api</artifactId>\n"
      "        </dependency>\n"
      "    </dependencies>\n"
      "\n"
      "</project>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:97
#, no-c-format
msgid "Essentially we are describing here the <filename>/tutorials/web/pom.xml</filename> file. See the <ulink url=\"http://maven.org\">Maven</ulink> site for more information."
msgstr ""

#. Tag: para
#: tutorial.xml:105
#, no-c-format
msgid "While not strictly necessary, most IDEs have integration with Maven to read these POM files and automatically set up a project for you which can save lots of time and effort."
msgstr ""

#. Tag: para
#: tutorial.xml:112
#, no-c-format
msgid "Next we create a class that represents the event we want to store in database."
msgstr ""

#. Tag: title
#: tutorial.xml:117
#, no-c-format
msgid "The first class"
msgstr ""

#. Tag: para
#: tutorial.xml:119
#, no-c-format
msgid "Our first persistent class is a simple JavaBean class with some properties:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:123
#, no-c-format
msgid ""
      "<![CDATA[package org.hibernate.tutorial.domain;\n"
      "\n"
      "import java.util.Date;\n"
      "\n"
      "public class Event {\n"
      "    private Long id;\n"
      "\n"
      "    private String title;\n"
      "    private Date date;\n"
      "\n"
      "    public Event() {}\n"
      "\n"
      "    public Long getId() {\n"
      "        return id;\n"
      "    }\n"
      "\n"
      "    private void setId(Long id) {\n"
      "        this.id = id;\n"
      "    }\n"
      "\n"
      "    public Date getDate() {\n"
      "        return date;\n"
      "    }\n"
      "\n"
      "    public void setDate(Date date) {\n"
      "        this.date = date;\n"
      "    }\n"
      "\n"
      "    public String getTitle() {\n"
      "        return title;\n"
      "    }\n"
      "\n"
      "    public void setTitle(String title) {\n"
      "        this.title = title;\n"
      "    }\n"
      "}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:125
#, no-c-format
msgid "You can see that this class uses standard JavaBean naming conventions for property getter and setter methods, as well as private visibility for the fields. This is a recommended design - but not required. Hibernate can also access fields directly, the benefit of accessor methods is robustness for refactoring. The no-argument constructor is required to instantiate an object of this class through reflection."
msgstr ""

#. Tag: para
#: tutorial.xml:133
#, no-c-format
msgid "The <literal>id</literal> property holds a unique identifier value for a particular event. All persistent entity classes (there are less important dependent classes as well) will need such an identifier property if we want to use the full feature set of Hibernate. In fact, most applications (esp. web applications) need to distinguish objects by identifier, so you should consider this a feature rather than a limitation. However, we usually don't manipulate the identity of an object, hence the setter method should be private. Only Hibernate will assign identifiers when an object is saved. You can see that Hibernate can access public, private, and protected accessor methods, as well as (public, private, protected) fields directly. The choice is up to you and you can match it to fit your application design."
msgstr ""

#. Tag: para
#: tutorial.xml:145
#, no-c-format
msgid "The no-argument constructor is a requirement for all persistent classes; Hibernate has to create objects for you, using Java Reflection. The constructor can be private, however, package visibility is required for runtime proxy generation and efficient data retrieval without bytecode instrumentation."
msgstr ""

#. Tag: para
#: tutorial.xml:152
#, no-c-format
msgid "Place this Java source file in a directory called <literal>src</literal> in the development folder, and in its correct package. The directory should now look like this:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:157
#, no-c-format
msgid ""
      "<![CDATA[.\n"
      "+lib\n"
      "  <Hibernate and third-party libraries>\n"
      "+src\n"
      "  +events\n"
      "    Event.java]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:159
#, no-c-format
msgid "In the next step, we tell Hibernate about this persistent class."
msgstr ""

#. Tag: title
#: tutorial.xml:166
#, no-c-format
msgid "The mapping file"
msgstr ""

#. Tag: para
#: tutorial.xml:168
#, no-c-format
msgid "Hibernate needs to know how to load and store objects of the persistent class. This is where the Hibernate mapping file comes into play. The mapping file tells Hibernate what table in the database it has to access, and what columns in that table it should use."
msgstr ""

#. Tag: para
#: tutorial.xml:175
#, no-c-format
msgid "The basic structure of a mapping file looks like this:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:179
#, no-c-format
msgid ""
      "<![CDATA[<?xml version=\"1.0\"?>\n"
      "<!DOCTYPE hibernate-mapping PUBLIC\n"
      "        \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
      "        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\n"
      "\n"
      "<hibernate-mapping>\n"
      "[...]\n"
      "</hibernate-mapping>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:181
#, no-c-format
msgid "Note that the Hibernate DTD is very sophisticated. You can use it for auto-completion of XML mapping elements and attributes in your editor or IDE. You also should open up the DTD file in your text editor - it's the easiest way to get an overview of all elements and attributes and to see the defaults, as well as some comments. Note that Hibernate will not load the DTD file from the web, but first look it up from the classpath of the application. The DTD file is included in <literal>hibernate3.jar</literal> as well as in the <literal>src/</literal> directory of the Hibernate distribution."
msgstr ""

#. Tag: para
#: tutorial.xml:192
#, no-c-format
msgid "We will omit the DTD declaration in future examples to shorten the code. It is of course not optional."
msgstr ""

#. Tag: para
#: tutorial.xml:197
#, no-c-format
msgid "Between the two <literal>hibernate-mapping</literal> tags, include a <literal>class</literal> element. All persistent entity classes (again, there might be dependent classes later on, which are not first-class entities) need such a mapping, to a table in the SQL database:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:204
#, no-c-format
msgid ""
      "<![CDATA[<hibernate-mapping>\n"
      "\n"
      "    <class name=\"events.Event\" table=\"EVENTS\">\n"
      "\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:206
#, no-c-format
msgid "So far we told Hibernate how to persist and load object of class <literal>Event</literal> to the table <literal>EVENTS</literal>, each instance represented by a row in that table. Now we continue with a mapping of the unique identifier property to the tables primary key. In addition, as we don't want to care about handling this identifier, we configure Hibernate's identifier generation strategy for a surrogate primary key column:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:214
#, no-c-format
msgid ""
      "<![CDATA[<hibernate-mapping>\n"
      "\n"
      "    <class name=\"events.Event\" table=\"EVENTS\">\n"
      "        <id name=\"id\" column=\"EVENT_ID\">\n"
      "            <generator class=\"native\"/>\n"
      "        </id>\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:216
#, no-c-format
msgid "The <literal>id</literal> element is the declaration of the identifier property, <literal>name=\"id\"</literal> declares the name of the Java property - Hibernate will use the getter and setter methods to access the property. The column attribute tells Hibernate which column of the <literal>EVENTS</literal> table we use for this primary key. The nested <literal>generator</literal> element specifies the identifier generation strategy, in this case we used <literal>native</literal>, which picks the best strategy depending on the configured database (dialect). Hibernate supports database generated, globally unique, as well as application assigned identifiers (or any strategy you have written an extension for)."
msgstr ""

#. Tag: para
#: tutorial.xml:229
#, no-c-format
msgid "Finally we include declarations for the persistent properties of the class in the mapping file. By default, no properties of the class are considered persistent:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:235
#, no-c-format
msgid ""
      "<![CDATA[\n"
      "<hibernate-mapping>\n"
      "\n"
      "    <class name=\"events.Event\" table=\"EVENTS\">\n"
      "        <id name=\"id\" column=\"EVENT_ID\">\n"
      "            <generator class=\"native\"/>\n"
      "        </id>\n"
      "        <property name=\"date\" type=\"timestamp\" column=\"EVENT_DATE\"/>\n"
      "        <property name=\"title\"/>\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:237
#, no-c-format
msgid "Just as with the <literal>id</literal> element, the <literal>name</literal> attribute of the <literal>property</literal> element tells Hibernate which getter and setter methods to use. So, in this case, Hibernate will look for <literal>getDate()/setDate()</literal>, as well as <literal>getTitle()/setTitle()</literal>."
msgstr ""

#. Tag: para
#: tutorial.xml:244
#, no-c-format
msgid "Why does the <literal>date</literal> property mapping include the <literal>column</literal> attribute, but the <literal>title</literal> doesn't? Without the <literal>column</literal> attribute Hibernate by default uses the property name as the column name. This works fine for <literal>title</literal>. However, <literal>date</literal> is a reserved keyword in most database, so we better map it to a different name."
msgstr ""

#. Tag: para
#: tutorial.xml:253
#, no-c-format
msgid "The next interesting thing is that the <literal>title</literal> mapping also lacks a <literal>type</literal> attribute. The types we declare and use in the mapping files are not, as you might expect, Java data types. They are also not SQL database types. These types are so called <emphasis>Hibernate mapping types</emphasis>, converters which can translate from Java to SQL data types and vice versa. Again, Hibernate will try to determine the correct conversion and mapping type itself if the <literal>type</literal> attribute is not present in the mapping. In some cases this automatic detection (using Reflection on the Java class) might not have the default you expect or need. This is the case with the <literal>date</literal> property. Hibernate can't know if the property (which is of <literal>java.util.Date</literal>) should map to a SQL <literal>date</literal>, <literal>timestamp</literal>, or <literal>time</literal> column. We preserve full date and time information by mapping the property with a <literal>timestamp</literal> converter."
msgstr ""

#. Tag: para
#: tutorial.xml:269
#, no-c-format
msgid "This mapping file should be saved as <literal>Event.hbm.xml</literal>, right in the directory next to the <literal>Event</literal> Java class source file. The naming of mapping files can be arbitrary, however the <literal>hbm.xml</literal> suffix is a convention in the Hibernate developer community. The directory structure should now look like this:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:277
#, no-c-format
msgid ""
      "<![CDATA[.\n"
      "+lib\n"
      "  <Hibernate and third-party libraries>\n"
      "+src\n"
      "  +events\n"
      "    Event.java\n"
      "    Event.hbm.xml]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:279
#, no-c-format
msgid "We continue with the main configuration of Hibernate."
msgstr ""

#. Tag: title
#: tutorial.xml:286
#, no-c-format
msgid "Hibernate configuration"
msgstr ""

#. Tag: para
#: tutorial.xml:288
#, no-c-format
msgid "We now have a persistent class and its mapping file in place. It is time to configure Hibernate. Before we do this, we will need a database. HSQL DB, a java-based SQL DBMS, can be downloaded from the HSQL DB website(http://hsqldb.org/). Actually, you only need the <literal>hsqldb.jar</literal> from this download. Place this file in the <literal>lib/</literal> directory of the development folder."
msgstr ""

#. Tag: para
#: tutorial.xml:296
#, no-c-format
msgid "Create a directory called <literal>data</literal> in the root of the development directory - this is where HSQL DB will store its data files. Now start the database by running <literal>java -classpath ../lib/hsqldb.jar org.hsqldb.Server</literal> in this data directory. You can see it start up and bind to a TCP/IP socket, this is where our application will connect later. If you want to start with a fresh database during this tutorial, shutdown HSQL DB (press <literal>CTRL + C</literal> in the window), delete all files in the <literal>data/</literal> directory, and start HSQL DB again."
msgstr ""

#. Tag: para
#: tutorial.xml:306
#, no-c-format
msgid "Hibernate is the layer in your application which connects to this database, so it needs connection information. The connections are made through a JDBC connection pool, which we also have to configure. The Hibernate distribution contains several open source JDBC connection pooling tools, but will use the Hibernate built-in connection pool for this tutorial. Note that you have to copy the required library into your classpath and use different connection pooling settings if you want to use a production-quality third party JDBC pooling software."
msgstr ""

#. Tag: para
#: tutorial.xml:316
#, no-c-format
msgid "For Hibernate's configuration, we can use a simple <literal>hibernate.properties</literal> file, a slightly more sophisticated <literal>hibernate.cfg.xml</literal> file, or even complete programmatic setup. Most users prefer the XML configuration file:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:322
#, no-c-format
msgid ""
      "<![CDATA[<?xml version='1.0' encoding='utf-8'?>\n"
      "<!DOCTYPE hibernate-configuration PUBLIC\n"
      "        \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n"
      "        \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\">\n"
      "\n"
      "<hibernate-configuration>\n"
      "\n"
      "    <session-factory>\n"
      "\n"
      "        <!-- Database connection settings -->\n"
      "        <property name=\"connection.driver_class\">org.hsqldb.jdbcDriver</property>\n"
      "        <property name=\"connection.url\">jdbc:hsqldb:hsql://localhost</property>\n"
      "        <property name=\"connection.username\">sa</property>\n"
      "        <property name=\"connection.password\"></property>\n"
      "\n"
      "        <!-- JDBC connection pool (use the built-in) -->\n"
      "        <property name=\"connection.pool_size\">1</property>\n"
      "\n"
      "        <!-- SQL dialect -->\n"
      "        <property name=\"dialect\">org.hibernate.dialect.HSQLDialect</property>\n"
      "\n"
      "        <!-- Enable Hibernate's automatic session context management -->\n"
      "        <property name=\"current_session_context_class\">thread</property>\n"
      "\n"
      "        <!-- Disable the second-level cache  -->\n"
      "        <property name=\"cache.provider_class\">org.hibernate.cache.NoCacheProvider</property>\n"
      "\n"
      "        <!-- Echo all executed SQL to stdout -->\n"
      "        <property name=\"show_sql\">true</property>\n"
      "\n"
      "        <!-- Drop and re-create the database schema on startup -->\n"
      "        <property name=\"hbm2ddl.auto\">create</property>\n"
      "\n"
      "        <mapping resource=\"events/Event.hbm.xml\"/>\n"
      "\n"
      "    </session-factory>\n"
      "\n"
      "</hibernate-configuration>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:324
#, no-c-format
msgid "Note that this XML configuration uses a different DTD. We configure Hibernate's <literal>SessionFactory</literal> - a global factory responsible for a particular database. If you have several databases, use several <literal>&lt;session-factory&gt;</literal> configurations, usually in several configuration files (for easier startup)."
msgstr ""

#. Tag: para
#: tutorial.xml:332
#, no-c-format
msgid "The first four <literal>property</literal> elements contain the necessary configuration for the JDBC connection. The dialect <literal>property</literal> element specifies the particular SQL variant Hibernate generates. Hibernate's automatic session management for persistence contexts will come in handy as you will soon see. The <literal>hbm2ddl.auto</literal> option turns on automatic generation of database schemas - directly into the database. This can of course also be turned off (by removing the config option) or redirected to a file with the help of the <literal>SchemaExport</literal> Ant task. Finally, we add the mapping file(s) for persistent classes to the configuration."
msgstr ""

#. Tag: para
#: tutorial.xml:345
#, no-c-format
msgid "Copy this file into the source directory, so it will end up in the root of the classpath. Hibernate automatically looks for a file called <literal>hibernate.cfg.xml</literal> in the root of the classpath, on startup."
msgstr ""

#. Tag: title
#: tutorial.xml:354
#, no-c-format
msgid "Building with Ant"
msgstr ""

#. Tag: para
#: tutorial.xml:356
#, no-c-format
msgid "We'll now build the tutorial with Ant. You will need to have Ant installed - get it from the <ulink url=\"http://ant.apache.org/bindownload.cgi\">Ant download page</ulink>. How to install Ant will not be covered here. Please refer to the <ulink url=\"http://ant.apache.org/manual/index.html\">Ant manual</ulink>. After you have installed Ant, we can start to create the buildfile. It will be called <literal>build.xml</literal> and placed directly in the development directory."
msgstr ""

#. Tag: para
#: tutorial.xml:365
#, no-c-format
msgid "A basic build file looks like this:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:369
#, no-c-format
msgid ""
      "<![CDATA[<project name=\"hibernate-tutorial\" default=\"compile\">\n"
      "\n"
      "    <property name=\"sourcedir\" value=\"${basedir}/src\"/>\n"
      "    <property name=\"targetdir\" value=\"${basedir}/bin\"/>\n"
      "    <property name=\"librarydir\" value=\"${basedir}/lib\"/>\n"
      "\n"
      "    <path id=\"libraries\">\n"
      "        <fileset dir=\"${librarydir}\">\n"
      "            <include name=\"*.jar\"/>\n"
      "        </fileset>\n"
      "    </path>\n"
      "\n"
      "    <target name=\"clean\">\n"
      "        <delete dir=\"${targetdir}\"/>\n"
      "        <mkdir dir=\"${targetdir}\"/>\n"
      "    </target>\n"
      "\n"
      "    <target name=\"compile\" depends=\"clean, copy-resources\">\n"
      "      <javac srcdir=\"${sourcedir}\"\n"
      "             destdir=\"${targetdir}\"\n"
      "             classpathref=\"libraries\"/>\n"
      "    </target>\n"
      "\n"
      "    <target name=\"copy-resources\">\n"
      "        <copy todir=\"${targetdir}\">\n"
      "            <fileset dir=\"${sourcedir}\">\n"
      "                <exclude name=\"**/*.java\"/>\n"
      "            </fileset>\n"
      "        </copy>\n"
      "    </target>\n"
      "\n"
      "</project>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:371
#, no-c-format
msgid "This will tell Ant to add all files in the lib directory ending with <literal>.jar</literal> to the classpath used for compilation. It will also copy all non-Java source files to the target directory, e.g. configuration and Hibernate mapping files. If you now run Ant, you should get this output:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:378
#, no-c-format
msgid ""
      "<![CDATA[C:\\hibernateTutorial\\>ant\n"
      "Buildfile: build.xml\n"
      "\n"
      "copy-resources:\n"
      "     [copy] Copying 2 files to C:\\hibernateTutorial\\bin\n"
      "\n"
      "compile:\n"
      "    [javac] Compiling 1 source file to C:\\hibernateTutorial\\bin\n"
      "\n"
      "BUILD SUCCESSFUL\n"
      "Total time: 1 second ]]>"
msgstr ""

#. Tag: title
#: tutorial.xml:383
#, no-c-format
msgid "Startup and helpers"
msgstr ""

#. Tag: para
#: tutorial.xml:385
#, no-c-format
msgid "It's time to load and store some <literal>Event</literal> objects, but first we have to complete the setup with some infrastructure code. We have to startup Hibernate. This startup includes building a global <literal>SessionFactory</literal> object and to store it somewhere for easy access in application code. A <literal>SessionFactory</literal> can open up new <literal>Session</literal>'s. A <literal>Session</literal> represents a single-threaded unit of work, the <literal>SessionFactory</literal> is a thread-safe global object, instantiated once."
msgstr ""

#. Tag: para
#: tutorial.xml:395
#, no-c-format
msgid "We'll create a <literal>HibernateUtil</literal> helper class which takes care of startup and makes accessing a <literal>SessionFactory</literal> convenient. Let's have a look at the implementation:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:401
#, no-c-format
msgid ""
      "<![CDATA[package util;\n"
      "\n"
      "import org.hibernate.*;\n"
      "import org.hibernate.cfg.*;\n"
      "\n"
      "public class HibernateUtil {\n"
      "\n"
      "    private static final SessionFactory sessionFactory;\n"
      "\n"
      "    static {\n"
      "        try {\n"
      "            // Create the SessionFactory from hibernate.cfg.xml\n"
      "            sessionFactory = new Configuration().configure().buildSessionFactory();\n"
      "        } catch (Throwable ex) {\n"
      "            // Make sure you log the exception, as it might be swallowed\n"
      "            System.err.println(\"Initial SessionFactory creation failed.\" + ex);\n"
      "            throw new ExceptionInInitializerError(ex);\n"
      "        }\n"
      "    }\n"
      "\n"
      "    public static SessionFactory getSessionFactory() {\n"
      "        return sessionFactory;\n"
      "    }\n"
      "\n"
      "}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:403
#, no-c-format
msgid "This class does not only produce the global <literal>SessionFactory</literal> in its static initializer (called once by the JVM when the class is loaded), but also hides the fact that it uses a static singleton. It might as well lookup the <literal>SessionFactory</literal> from JNDI in an application server."
msgstr ""

#. Tag: para
#: tutorial.xml:410
#, no-c-format
msgid "If you give the <literal>SessionFactory</literal> a name in your configuration file, Hibernate will in fact try to bind it to JNDI after it has been built. To avoid this code completely you could also use JMX deployment and let the JMX-capable container instantiate and bind a <literal>HibernateService</literal> to JNDI. These advanced options are discussed in the Hibernate reference documentation."
msgstr ""

#. Tag: para
#: tutorial.xml:419
#, no-c-format
msgid "Place <literal>HibernateUtil.java</literal> in the development source directory, in a package next to <literal>events</literal>:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:424
#, no-c-format
msgid ""
      "<![CDATA[.\n"
      "+lib\n"
      "  <Hibernate and third-party libraries>\n"
      "+src\n"
      "  +events\n"
      "    Event.java\n"
      "    Event.hbm.xml\n"
      "  +util\n"
      "    HibernateUtil.java\n"
      "  hibernate.cfg.xml\n"
      "+data\n"
      "build.xml]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:426
#, no-c-format
msgid "This should again compile without problems. We finally need to configure a logging system - Hibernate uses commons logging and leaves you the choice between Log4j and JDK 1.4 logging. Most developers prefer Log4j: copy <literal>log4j.properties</literal> from the Hibernate distribution (it's in the <literal>etc/</literal> directory) to your <literal>src</literal> directory, next to <literal>hibernate.cfg.xml</literal>. Have a look at the example configuration and change the settings if you like to have more verbose output. By default, only Hibernate startup message are shown on stdout."
msgstr ""

#. Tag: para
#: tutorial.xml:436
#, no-c-format
msgid "The tutorial infrastructure is complete - and we are ready to do some real work with Hibernate."
msgstr ""

#. Tag: title
#: tutorial.xml:444
#, no-c-format
msgid "Loading and storing objects"
msgstr ""

#. Tag: para
#: tutorial.xml:446
#, no-c-format
msgid "Finally, we can use Hibernate to load and store objects. We write an <literal>EventManager</literal> class with a <literal>main()</literal> method:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:451
#, no-c-format
msgid ""
      "<![CDATA[package events;\n"
      "import org.hibernate.Session;\n"
      "\n"
      "import java.util.Date;\n"
      "\n"
      "import util.HibernateUtil;\n"
      "\n"
      "public class EventManager {\n"
      "\n"
      "    public static void main(String[] args) {\n"
      "        EventManager mgr = new EventManager();\n"
      "\n"
      "        if (args[0].equals(\"store\")) {\n"
      "            mgr.createAndStoreEvent(\"My Event\", new Date());\n"
      "        }\n"
      "\n"
      "        HibernateUtil.getSessionFactory().close();\n"
      "    }\n"
      "\n"
      "    private void createAndStoreEvent(String title, Date theDate) {\n"
      "\n"
      "        Session session = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "\n"
      "        session.beginTransaction();\n"
      "\n"
      "        Event theEvent = new Event();\n"
      "        theEvent.setTitle(title);\n"
      "        theEvent.setDate(theDate);\n"
      "\n"
      "        session.save(theEvent);\n"
      "\n"
      "        session.getTransaction().commit();\n"
      "    }\n"
      "\n"
      "}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:453
#, no-c-format
msgid "We create a new <literal>Event</literal> object, and hand it over to Hibernate. Hibernate now takes care of the SQL and executes <literal>INSERT</literal>s on the database. Let's have a look at the <literal>Session</literal> and <literal>Transaction</literal>-handling code before we run this."
msgstr ""

#. Tag: para
#: tutorial.xml:460
#, no-c-format
msgid "A <literal>Session</literal> is a single unit of work. For now we'll keep things simple and assume a one-to-one granularity between a Hibernate <literal>Session</literal> and a database transaction. To shield our code from the actual underlying transaction system (in this case plain JDBC, but it could also run with JTA) we use the <literal>Transaction</literal> API that is available on the Hibernate <literal>Session</literal>."
msgstr ""

#. Tag: para
#: tutorial.xml:468
#, no-c-format
msgid "What does <literal>sessionFactory.getCurrentSession()</literal> do? First, you can call it as many times and anywhere you like, once you get hold of your <literal>SessionFactory</literal> (easy thanks to <literal>HibernateUtil</literal>). The <literal>getCurrentSession()</literal> method always returns the \"current\" unit of work. Remember that we switched the configuration option for this mechanism to \"thread\" in <literal>hibernate.cfg.xml</literal>? Hence, the current unit of work is bound to the current Java thread that executes our application. However, this is not the full picture, you also have to consider scope, when a unit of work begins and when it ends."
msgstr ""

#. Tag: para
#: tutorial.xml:479
#, no-c-format
msgid "A <literal>Session</literal> begins when it is first needed, when the first call to <literal>getCurrentSession()</literal> is made. It is then bound by Hibernate to the current thread. When the transaction ends, either through commit or rollback, Hibernate automatically unbinds the <literal>Session</literal> from the thread and closes it for you. If you call <literal>getCurrentSession()</literal> again, you get a new <literal>Session</literal> and can start a new unit of work. This <emphasis>thread-bound</emphasis> programming model is the most popular way of using Hibernate, as it allows flexible layering of your code (transaction demarcation code can be separated from data access code, we'll do this later in this tutorial)."
msgstr ""

#. Tag: para
#: tutorial.xml:490
#, no-c-format
msgid "Related to the unit of work scope, should the Hibernate <literal>Session</literal> be used to execute one or several database operations? The above example uses one <literal>Session</literal> for one operation. This is pure coincidence, the example is just not complex enough to show any other approach. The scope of a Hibernate <literal>Session</literal> is flexible but you should never design your application to use a new Hibernate <literal>Session</literal> for <emphasis>every</emphasis> database operation. So even if you see it a few more times in the following (very trivial) examples, consider <emphasis>session-per-operation</emphasis> an anti-pattern. A real (web) application is shown later in this tutorial."
msgstr ""

#. Tag: para
#: tutorial.xml:501
#, no-c-format
msgid "Have a look at <xref linkend=\"transactions\"/> for more information about transaction handling and demarcation. We also skipped any error handling and rollback in the previous example."
msgstr ""

#. Tag: para
#: tutorial.xml:507
#, no-c-format
msgid "To run this first routine we have to add a callable target to the Ant build file:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:511
#, no-c-format
msgid ""
      "<![CDATA[<target name=\"run\" depends=\"compile\">\n"
      "    <java fork=\"true\" classname=\"events.EventManager\" classpathref=\"libraries\">\n"
      "        <classpath path=\"${targetdir}\"/>\n"
      "        <arg value=\"${action}\"/>\n"
      "    </java>\n"
      "</target>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:513
#, no-c-format
msgid "The value of the <literal>action</literal> argument is set on the command line when calling the target:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:518
#, no-c-format
msgid "<![CDATA[C:\\hibernateTutorial\\>ant run -Daction=store]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:520
#, no-c-format
msgid "You should see, after compilation, Hibernate starting up and, depending on your configuration, lots of log output. At the end you will find the following line:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:525
#, no-c-format
msgid "<![CDATA[[java] Hibernate: insert into EVENTS (EVENT_DATE, title, EVENT_ID) values (?, ?, ?)]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:527
#, no-c-format
msgid "This is the <literal>INSERT</literal> executed by Hibernate, the question marks represent JDBC bind parameters. To see the values bound as arguments, or to reduce the verbosity of the log, check your <literal>log4j.properties</literal>."
msgstr ""

#. Tag: para
#: tutorial.xml:533
#, no-c-format
msgid "Now we'd like to list stored events as well, so we add an option to the main method:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:537
#, no-c-format
msgid ""
      "<![CDATA[if (args[0].equals(\"store\")) {\n"
      "    mgr.createAndStoreEvent(\"My Event\", new Date());\n"
      "}\n"
      "else if (args[0].equals(\"list\")) {\n"
      "    List events = mgr.listEvents();\n"
      "    for (int i = 0; i < events.size(); i++) {\n"
      "        Event theEvent = (Event) events.get(i);\n"
      "        System.out.println(\"Event: \" + theEvent.getTitle() +\n"
      "                           \" Time: \" + theEvent.getDate());\n"
      "    }\n"
      "}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:539
#, no-c-format
msgid "We also add a new <literal>listEvents() method</literal>:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:543
#, no-c-format
msgid ""
      "<![CDATA[private List listEvents() {\n"
      "\n"
      "    Session session = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "\n"
      "    session.beginTransaction();\n"
      "\n"
      "    List result = session.createQuery(\"from Event\").list();\n"
      "\n"
      "    session.getTransaction().commit();\n"
      "\n"
      "    return result;\n"
      "}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:545
#, no-c-format
msgid "What we do here is use an HQL (Hibernate Query Language) query to load all existing <literal>Event</literal> objects from the database. Hibernate will generate the appropriate SQL, send it to the database and populate <literal>Event</literal> objects with the data. You can create more complex queries with HQL, of course."
msgstr ""

#. Tag: para
#: tutorial.xml:552
#, no-c-format
msgid "Now, to execute and test all of this, follow these steps:"
msgstr ""

#. Tag: para
#: tutorial.xml:558
#, no-c-format
msgid "Run <literal>ant run -Daction=store</literal> to store something into the database and, of course, to generate the database schema before through hbm2ddl."
msgstr ""

#. Tag: para
#: tutorial.xml:564
#, no-c-format
msgid "Now disable hbm2ddl by commenting out the property in your <literal>hibernate.cfg.xml</literal> file. Usually you only leave it turned on in continuous unit testing, but another run of hbm2ddl would <emphasis>drop</emphasis> everything you have stored - the <literal>create</literal> configuration setting actually translates into \"drop all tables from the schema, then re-create all tables, when the SessionFactory is build\"."
msgstr ""

#. Tag: para
#: tutorial.xml:574
#, no-c-format
msgid "If you now call Ant with <literal>-Daction=list</literal>, you should see the events you have stored so far. You can of course also call the <literal>store</literal> action a few times more."
msgstr ""

#. Tag: para
#: tutorial.xml:580
#, no-c-format
msgid "Note: Most new Hibernate users fail at this point and we see questions about <emphasis>Table not found</emphasis> error messages regularly. However, if you follow the steps outlined above you will not have this problem, as hbm2ddl creates the database schema on the first run, and subsequent application restarts will use this schema. If you change the mapping and/or database schema, you have to re-enable hbm2ddl once again."
msgstr ""

#. Tag: title
#: tutorial.xml:593
#, no-c-format
msgid "Part 2 - Mapping associations"
msgstr ""

#. Tag: para
#: tutorial.xml:595
#, no-c-format
msgid "We mapped a persistent entity class to a table. Let's build on this and add some class associations. First we'll add people to our application, and store a list of events they participate in."
msgstr ""

#. Tag: title
#: tutorial.xml:601
#, no-c-format
msgid "Mapping the Person class"
msgstr ""

#. Tag: para
#: tutorial.xml:603
#, no-c-format
msgid "The first cut of the <literal>Person</literal> class is simple:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:607
#, no-c-format
msgid ""
      "<![CDATA[package events;\n"
      "\n"
      "public class Person {\n"
      "\n"
      "    private Long id;\n"
      "    private int age;\n"
      "    private String firstname;\n"
      "    private String lastname;\n"
      "\n"
      "    public Person() {}\n"
      "\n"
      "    // Accessor methods for all properties, private setter for 'id'\n"
      "\n"
      "}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:609
#, no-c-format
msgid "Create a new mapping file called <literal>Person.hbm.xml</literal> (don't forget the DTD reference at the top):"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:614
#, no-c-format
msgid ""
      "<![CDATA[<hibernate-mapping>\n"
      "\n"
      "    <class name=\"events.Person\" table=\"PERSON\">\n"
      "        <id name=\"id\" column=\"PERSON_ID\">\n"
      "            <generator class=\"native\"/>\n"
      "        </id>\n"
      "        <property name=\"age\"/>\n"
      "        <property name=\"firstname\"/>\n"
      "        <property name=\"lastname\"/>\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:616
#, no-c-format
msgid "Finally, add the new mapping to Hibernate's configuration:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:620
#, no-c-format
msgid ""
      "<![CDATA[<mapping resource=\"events/Event.hbm.xml\"/>\n"
      "<mapping resource=\"events/Person.hbm.xml\"/>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:622
#, no-c-format
msgid "We'll now create an association between these two entities. Obviously, persons can participate in events, and events have participants. The design questions we have to deal with are: directionality, multiplicity, and collection behavior."
msgstr ""

#. Tag: title
#: tutorial.xml:632
#, no-c-format
msgid "A unidirectional Set-based association"
msgstr ""

#. Tag: para
#: tutorial.xml:634
#, no-c-format
msgid "We'll add a collection of events to the <literal>Person</literal> class. That way we can easily navigate to the events for a particular person, without executing an explicit query - by calling <literal>aPerson.getEvents()</literal>. We use a Java collection, a <literal>Set</literal>, because the collection will not contain duplicate elements and the ordering is not relevant for us."
msgstr ""

#. Tag: para
#: tutorial.xml:641
#, no-c-format
msgid "We need a unidirectional, many-valued associations, implemented with a <literal>Set</literal>. Let's write the code for this in the Java classes and then map it:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:646
#, no-c-format
msgid ""
      "<![CDATA[public class Person {\n"
      "\n"
      "    private Set events = new HashSet();\n"
      "\n"
      "    public Set getEvents() {\n"
      "        return events;\n"
      "    }\n"
      "\n"
      "    public void setEvents(Set events) {\n"
      "        this.events = events;\n"
      "    }\n"
      "}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:648
#, no-c-format
msgid "Before we map this association, think about the other side. Clearly, we could just keep this unidirectional. Or, we could create another collection on the <literal>Event</literal>, if we want to be able to navigate it bi-directional, i.e. <literal>anEvent.getParticipants()</literal>. This is not necessary, from a functional perspective. You could always execute an explicit query to retrieve the participants for a particular event. This is a design choice left to you, but what is clear from this discussion is the multiplicity of the association: \"many\" valued on both sides, we call this a <emphasis>many-to-many</emphasis> association. Hence, we use Hibernate's many-to-many mapping:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:659
#, no-c-format
msgid ""
      "<![CDATA[<class name=\"events.Person\" table=\"PERSON\">\n"
      "    <id name=\"id\" column=\"PERSON_ID\">\n"
      "        <generator class=\"native\"/>\n"
      "    </id>\n"
      "    <property name=\"age\"/>\n"
      "    <property name=\"firstname\"/>\n"
      "    <property name=\"lastname\"/>\n"
      "\n"
      "    <set name=\"events\" table=\"PERSON_EVENT\">\n"
      "        <key column=\"PERSON_ID\"/>\n"
      "        <many-to-many column=\"EVENT_ID\" class=\"events.Event\"/>\n"
      "    </set>\n"
      "\n"
      "</class>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:661
#, no-c-format
msgid "Hibernate supports all kinds of collection mappings, a <literal>&lt;set&gt;</literal> being most common. For a many-to-many association (or <emphasis>n:m</emphasis> entity relationship), an association table is needed. Each row in this table represents a link between a person and an event. The table name is configured with the <literal>table</literal> attribute of the <literal>set</literal> element. The identifier column name in the association, for the person's side, is defined with the <literal>&lt;key&gt;</literal> element, the column name for the event's side with the <literal>column</literal> attribute of the <literal>&lt;many-to-many&gt;</literal>. You also have to tell Hibernate the class of the objects in your collection (correct: the class on the other side of the collection of references)."
msgstr ""

#. Tag: para
#: tutorial.xml:673
#, no-c-format
msgid "The database schema for this mapping is therefore:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:677
#, no-c-format
msgid ""
      "<![CDATA[\n"
      "    _____________        __________________\n"
      "   |             |      |                  |       _____________\n"
      "   |   EVENTS    |      |   PERSON_EVENT   |      |             |\n"
      "   |_____________|      |__________________|      |    PERSON   |\n"
      "   |             |      |                  |      |_____________|\n"
      "   | *EVENT_ID   | <--> | *EVENT_ID        |      |             |\n"
      "   |  EVENT_DATE |      | *PERSON_ID       | <--> | *PERSON_ID  |\n"
      "   |  TITLE      |      |__________________|      |  AGE        |\n"
      "   |_____________|                                |  FIRSTNAME  |\n"
      "                                                  |  LASTNAME   |\n"
      "                                                  |_____________|\n"
      " ]]>"
msgstr ""

#. Tag: title
#: tutorial.xml:682
#, no-c-format
msgid "Working the association"
msgstr ""

#. Tag: para
#: tutorial.xml:684
#, no-c-format
msgid "Let's bring some people and events together in a new method in <literal>EventManager</literal>:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:688
#, no-c-format
msgid ""
      "<![CDATA[private void addPersonToEvent(Long personId, Long eventId) {\n"
      "\n"
      "    Session session = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "    session.beginTransaction();\n"
      "\n"
      "    Person aPerson = (Person) session.load(Person.class, personId);\n"
      "    Event anEvent = (Event) session.load(Event.class, eventId);\n"
      "\n"
      "    aPerson.getEvents().add(anEvent);\n"
      "\n"
      "    session.getTransaction().commit();\n"
      "}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:690
#, no-c-format
msgid "After loading a <literal>Person</literal> and an <literal>Event</literal>, simply modify the collection using the normal collection methods. As you can see, there is no explicit call to <literal>update()</literal> or <literal>save()</literal>, Hibernate automatically detects that the collection has been modified and needs to be updated. This is called <emphasis>automatic dirty checking</emphasis>, and you can also try it by modifying the name or the date property of any of your objects. As long as they are in <emphasis>persistent</emphasis> state, that is, bound to a particular Hibernate <literal>Session</literal> (i.e. they have been just loaded or saved in a unit of work), Hibernate monitors any changes and executes SQL in a write-behind fashion. The process of synchronizing the memory state with the database, usually only at the end of a unit of work, is called <emphasis>flushing</emphasis>. In our code, the unit of work ends with a commit (or rollback) of the database transaction - as defined by the <literal>thread</literal> configuration option for the <literal>CurrentSessionContext</literal> class."
msgstr ""

#. Tag: para
#: tutorial.xml:705
#, no-c-format
msgid "You might of course load person and event in different units of work. Or you modify an object outside of a <literal>Session</literal>, when it is not in persistent state (if it was persistent before, we call this state <emphasis>detached</emphasis>). You can even modify a collection when it is detached:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:712
#, no-c-format
msgid ""
      "<![CDATA[private void addPersonToEvent(Long personId, Long eventId) {\n"
      "\n"
      "    Session session = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "    session.beginTransaction();\n"
      "\n"
      "    Person aPerson = (Person) session\n"
      "            .createQuery(\"select p from Person p left join fetch p.events where p.id = :pid\")\n"
      "            .setParameter(\"pid\", personId)\n"
      "            .uniqueResult(); // Eager fetch the collection so we can use it detached\n"
      "\n"
      "    Event anEvent = (Event) session.load(Event.class, eventId);\n"
      "\n"
      "    session.getTransaction().commit();\n"
      "\n"
      "    // End of first unit of work\n"
      "\n"
      "    aPerson.getEvents().add(anEvent); // aPerson (and its collection) is detached\n"
      "\n"
      "    // Begin second unit of work\n"
      "\n"
      "    Session session2 = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "    session2.beginTransaction();\n"
      "\n"
      "    session2.update(aPerson); // Reattachment of aPerson\n"
      "\n"
      "    session2.getTransaction().commit();\n"
      "}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:714
#, no-c-format
msgid "The call to <literal>update</literal> makes a detached object persistent again, you could say it binds it to a new unit of work, so any modifications you made to it while detached can be saved to the database. This includes any modifications (additions/deletions) you made to a collection of that entity object."
msgstr ""

#. Tag: para
#: tutorial.xml:721
#, no-c-format
msgid "Well, this is not much use in our current situation, but it's an important concept you can design into your own application. For now, complete this exercise by adding a new action to the <literal>EventManager</literal>'s main method and call it from the command line. If you need the identifiers of a person and an event - the <literal>save()</literal> method returns it (you might have to modify some of the previous methods to return that identifier):"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:729
#, no-c-format
msgid ""
      "<![CDATA[else if (args[0].equals(\"addpersontoevent\")) {\n"
      "    Long eventId = mgr.createAndStoreEvent(\"My Event\", new Date());\n"
      "    Long personId = mgr.createAndStorePerson(\"Foo\", \"Bar\");\n"
      "    mgr.addPersonToEvent(personId, eventId);\n"
      "    System.out.println(\"Added person \" + personId + \" to event \" + eventId);\n"
      "}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:731
#, no-c-format
msgid "This was an example of an association between two equally important classes, two entities. As mentioned earlier, there are other classes and types in a typical model, usually \"less important\". Some you have already seen, like an <literal>int</literal> or a <literal>String</literal>. We call these classes <emphasis>value types</emphasis>, and their instances <emphasis>depend</emphasis> on a particular entity. Instances of these types don't have their own identity, nor are they shared between entities (two persons don't reference the same <literal>firstname</literal> object, even if they have the same first name). Of course, value types can not only be found in the JDK (in fact, in a Hibernate application all JDK classes are considered value types), but you can also write dependent classes yourself, <literal>Address</literal> or <literal>MonetaryAmount</literal>, for example."
msgstr ""

#. Tag: para
#: tutorial.xml:744
#, no-c-format
msgid "You can also design a collection of value types. This is conceptually very different from a collection of references to other entities, but looks almost the same in Java."
msgstr ""

#. Tag: title
#: tutorial.xml:752
#, no-c-format
msgid "Collection of values"
msgstr ""

#. Tag: para
#: tutorial.xml:754
#, no-c-format
msgid "We add a collection of value typed objects to the <literal>Person</literal> entity. We want to store email addresses, so the type we use is <literal>String</literal>, and the collection is again a <literal>Set</literal>:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:759
#, no-c-format
msgid ""
      "<![CDATA[private Set emailAddresses = new HashSet();\n"
      "\n"
      "public Set getEmailAddresses() {\n"
      "    return emailAddresses;\n"
      "}\n"
      "\n"
      "public void setEmailAddresses(Set emailAddresses) {\n"
      "    this.emailAddresses = emailAddresses;\n"
      "}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:761
#, no-c-format
msgid "The mapping of this <literal>Set</literal>:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:765
#, no-c-format
msgid ""
      "<![CDATA[<set name=\"emailAddresses\" table=\"PERSON_EMAIL_ADDR\">\n"
      "    <key column=\"PERSON_ID\"/>\n"
      "    <element type=\"string\" column=\"EMAIL_ADDR\"/>\n"
      "</set>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:767
#, no-c-format
msgid "The difference compared with the earlier mapping is the <literal>element</literal> part, which tells Hibernate that the collection does not contain references to another entity, but a collection of elements of type <literal>String</literal> (the lowercase name tells you it's a Hibernate mapping type/converter). Once again, the <literal>table</literal> attribute of the <literal>set</literal> element determines the table name for the collection. The <literal>key</literal> element defines the foreign-key column name in the collection table. The <literal>column</literal> attribute in the <literal>element</literal> element defines the column name where the <literal>String</literal> values will actually be stored."
msgstr ""

#. Tag: para
#: tutorial.xml:777
#, no-c-format
msgid "Have a look at the updated schema:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:781
#, no-c-format
msgid ""
      "<![CDATA[\n"
      "  _____________        __________________\n"
      " |             |      |                  |       _____________\n"
      " |   EVENTS    |      |   PERSON_EVENT   |      |             |       ___________________\n"
      " |_____________|      |__________________|      |    PERSON   |      |                   |\n"
      " |             |      |                  |      |_____________|      | PERSON_EMAIL_ADDR |\n"
      " | *EVENT_ID   | <--> | *EVENT_ID        |      |             |      |___________________|\n"
      " |  EVENT_DATE |      | *PERSON_ID       | <--> | *PERSON_ID  | <--> |  *PERSON_ID       |\n"
      " |  TITLE      |      |__________________|      |  AGE        |      |  *EMAIL_ADDR      |\n"
      " |_____________|                                |  FIRSTNAME  |      |___________________|\n"
      "                                                |  LASTNAME   |\n"
      "                                                |_____________|\n"
      " ]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:783
#, no-c-format
msgid "You can see that the primary key of the collection table is in fact a composite key, using both columns. This also implies that there can't be duplicate email addresses per person, which is exactly the semantics we need for a set in Java."
msgstr ""

#. Tag: para
#: tutorial.xml:789
#, no-c-format
msgid "You can now try and add elements to this collection, just like we did before by linking persons and events. It's the same code in Java:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:794
#, no-c-format
msgid ""
      "<![CDATA[private void addEmailToPerson(Long personId, String emailAddress) {\n"
      "\n"
      "    Session session = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "    session.beginTransaction();\n"
      "\n"
      "    Person aPerson = (Person) session.load(Person.class, personId);\n"
      "\n"
      "    // The getEmailAddresses() might trigger a lazy load of the collection\n"
      "    aPerson.getEmailAddresses().add(emailAddress);\n"
      "\n"
      "    session.getTransaction().commit();\n"
      "}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:796
#, no-c-format
msgid "This time we didn't use a <emphasis>fetch</emphasis> query to initialize the collection. Hence, the call to its getter method will trigger an additional select to initialize it, so we can add an element to it. Monitor the SQL log and try to optimize this with an eager fetch."
msgstr ""

#. Tag: title
#: tutorial.xml:806
#, no-c-format
msgid "Bi-directional associations"
msgstr ""

#. Tag: para
#: tutorial.xml:808
#, no-c-format
msgid "Next we are going to map a bi-directional association - making the association between person and event work from both sides in Java. Of course, the database schema doesn't change, we still have many-to-many multiplicity. A relational database is more flexible than a network programming language, so it doesn't need anything like a navigation direction - data can be viewed and retrieved in any possible way."
msgstr ""

#. Tag: para
#: tutorial.xml:816
#, no-c-format
msgid "First, add a collection of participants to the <literal>Event</literal> Event class:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:820
#, no-c-format
msgid ""
      "<![CDATA[private Set participants = new HashSet();\n"
      "\n"
      "public Set getParticipants() {\n"
      "    return participants;\n"
      "}\n"
      "\n"
      "public void setParticipants(Set participants) {\n"
      "    this.participants = participants;\n"
      "}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:822
#, no-c-format
msgid "Now map this side of the association too, in <literal>Event.hbm.xml</literal>."
msgstr ""

#. Tag: programlisting
#: tutorial.xml:826
#, no-c-format
msgid ""
      "<![CDATA[<set name=\"participants\" table=\"PERSON_EVENT\" inverse=\"true\">\n"
      "    <key column=\"EVENT_ID\"/>\n"
      "    <many-to-many column=\"PERSON_ID\" class=\"events.Person\"/>\n"
      "</set>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:828
#, no-c-format
msgid "As you see, these are normal <literal>set</literal> mappings in both mapping documents. Notice that the column names in <literal>key</literal> and <literal>many-to-many</literal> are swapped in both mapping documents. The most important addition here is the <literal>inverse=\"true\"</literal> attribute in the <literal>set</literal> element of the <literal>Event</literal>'s collection mapping."
msgstr ""

#. Tag: para
#: tutorial.xml:836
#, no-c-format
msgid "What this means is that Hibernate should take the other side - the <literal>Person</literal> class - when it needs to find out information about the link between the two. This will be a lot easier to understand once you see how the bi-directional link between our two entities is created ."
msgstr ""

#. Tag: title
#: tutorial.xml:845
#, no-c-format
msgid "Working bi-directional links"
msgstr ""

#. Tag: para
#: tutorial.xml:847
#, no-c-format
msgid "First, keep in mind that Hibernate does not affect normal Java semantics. How did we create a link between a <literal>Person</literal> and an <literal>Event</literal> in the unidirectional example? We added an instance of <literal>Event</literal> to the collection of event references, of an instance of <literal>Person</literal>. So, obviously, if we want to make this link working bi-directional, we have to do the same on the other side - adding a <literal>Person</literal> reference to the collection in an <literal>Event</literal>. This \"setting the link on both sides\" is absolutely necessary and you should never forget doing it."
msgstr ""

#. Tag: para
#: tutorial.xml:857
#, no-c-format
msgid "Many developers program defensively and create link management methods to correctly set both sides, e.g. in <literal>Person</literal>:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:862
#, no-c-format
msgid ""
      "<![CDATA[protected Set getEvents() {\n"
      "    return events;\n"
      "}\n"
      "\n"
      "protected void setEvents(Set events) {\n"
      "    this.events = events;\n"
      "}\n"
      "\n"
      "public void addToEvent(Event event) {\n"
      "    this.getEvents().add(event);\n"
      "    event.getParticipants().add(this);\n"
      "}\n"
      "\n"
      "public void removeFromEvent(Event event) {\n"
      "    this.getEvents().remove(event);\n"
      "    event.getParticipants().remove(this);\n"
      "}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:864
#, no-c-format
msgid "Notice that the get and set methods for the collection are now protected - this allows classes in the same package and subclasses to still access the methods, but prevents everybody else from messing with the collections directly (well, almost). You should probably do the same with the collection on the other side."
msgstr ""

#. Tag: para
#: tutorial.xml:871
#, no-c-format
msgid "What about the <literal>inverse</literal> mapping attribute? For you, and for Java, a bi-directional link is simply a matter of setting the references on both sides correctly. Hibernate however doesn't have enough information to correctly arrange SQL <literal>INSERT</literal> and <literal>UPDATE</literal> statements (to avoid constraint violations), and needs some help to handle bi-directional associations properly. Making one side of the association <literal>inverse</literal> tells Hibernate to basically ignore it, to consider it a <emphasis>mirror</emphasis> of the other side. That's all that is necessary for Hibernate to work out all of the issues when transformation a directional navigation model to a SQL database schema. The rules you have to remember are straightforward: All bi-directional associations need one side as <literal>inverse</literal>. In a one-to-many association it has to be the many-side, in many-to-many association you can pick either side, there is no difference."
msgstr ""

#. Tag: title
#: tutorial.xml:889
#, no-c-format
msgid "Part 3 - The EventManager web application"
msgstr ""

#. Tag: para
#: tutorial.xml:891
#, no-c-format
msgid "Let's turn the following discussion into a small web application..."
msgstr ""

#. Tag: para
#: tutorial.xml:895
#, no-c-format
msgid "A Hibernate web application uses <literal>Session</literal> and <literal>Transaction</literal> almost like a standalone application. However, some common patterns are useful. We now write an <literal>EventManagerServlet</literal>. This servlet can list all events stored in the database, and it provides an HTML form to enter new events."
msgstr ""

#. Tag: title
#: tutorial.xml:903
#, no-c-format
msgid "Writing the basic servlet"
msgstr ""

#. Tag: para
#: tutorial.xml:905
#, no-c-format
msgid "Create a new class in your source directory, in the <literal>events</literal> package:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:910
#, no-c-format
msgid ""
      "<![CDATA[package events;\n"
      "\n"
      "// Imports\n"
      "\n"
      "public class EventManagerServlet extends HttpServlet {\n"
      "\n"
      "    // Servlet code\n"
      "}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:912
#, no-c-format
msgid "The servlet handles HTTP <literal>GET</literal> requests only, hence, the method we implement is <literal>doGet()</literal>:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:917
#, no-c-format
msgid ""
      "<![CDATA[protected void doGet(HttpServletRequest request,\n"
      "                     HttpServletResponse response)\n"
      "        throws ServletException, IOException {\n"
      "\n"
      "    SimpleDateFormat dateFormatter = new SimpleDateFormat(\"dd.MM.yyyy\");\n"
      "\n"
      "    try {\n"
      "        // Begin unit of work\n"
      "        HibernateUtil.getSessionFactory()\n"
      "                .getCurrentSession().beginTransaction();\n"
      "\n"
      "        // Process request and render page...\n"
      "\n"
      "        // End unit of work\n"
      "        HibernateUtil.getSessionFactory()\n"
      "                .getCurrentSession().getTransaction().commit();\n"
      "\n"
      "    } catch (Exception ex) {\n"
      "        HibernateUtil.getSessionFactory()\n"
      "                .getCurrentSession().getTransaction().rollback();\n"
      "        throw new ServletException(ex);\n"
      "    }\n"
      "\n"
      "}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:919
#, no-c-format
msgid "The pattern we are applying here is called <emphasis>session-per-request</emphasis>. When a request hits the servlet, a new Hibernate <literal>Session</literal> is opened through the first call to <literal>getCurrentSession()</literal> on the <literal>SessionFactory</literal>. Then a database transaction is started&mdash;all data access as to occur inside a transaction, no matter if data is read or written (we don't use the auto-commit mode in applications)."
msgstr ""

#. Tag: para
#: tutorial.xml:928
#, no-c-format
msgid "Do <emphasis>not</emphasis> use a new Hibernate <literal>Session</literal> for every database operation. Use one Hibernate <literal>Session</literal> that is scoped to the whole request. Use <literal>getCurrentSession()</literal>, so that it is automatically bound to the current Java thread."
msgstr ""

#. Tag: para
#: tutorial.xml:935
#, no-c-format
msgid "Next, the possible actions of the request are processed and the response HTML is rendered. We'll get to that part soon."
msgstr ""

#. Tag: para
#: tutorial.xml:940
#, no-c-format
msgid "Finally, the unit of work ends when processing and rendering is complete. If any problem occurred during processing or rendering, an exception will be thrown and the database transaction rolled back. This completes the <literal>session-per-request</literal> pattern. Instead of the transaction demarcation code in every servlet you could also write a servlet filter. See the Hibernate website and Wiki for more information about this pattern, called <emphasis>Open Session in View</emphasis>&mdash;you'll need it as soon as you consider rendering your view in JSP, not in a servlet."
msgstr ""

#. Tag: title
#: tutorial.xml:954
#, no-c-format
msgid "Processing and rendering"
msgstr ""

#. Tag: para
#: tutorial.xml:956
#, no-c-format
msgid "Let's implement the processing of the request and rendering of the page."
msgstr ""

#. Tag: programlisting
#: tutorial.xml:960
#, no-c-format
msgid ""
      "<![CDATA[// Write HTML header\n"
      "PrintWriter out = response.getWriter();\n"
      "out.println(\"<html><head><title>Event Manager</title></head><body>\");\n"
      "\n"
      "// Handle actions\n"
      "if ( \"store\".equals(request.getParameter(\"action\")) ) {\n"
      "\n"
      "    String eventTitle = request.getParameter(\"eventTitle\");\n"
      "    String eventDate = request.getParameter(\"eventDate\");\n"
      "\n"
      "    if ( \"\".equals(eventTitle) || \"\".equals(eventDate) ) {\n"
      "        out.println(\"<b><i>Please enter event title and date.</i></b>\");\n"
      "    } else {\n"
      "        createAndStoreEvent(eventTitle, dateFormatter.parse(eventDate));\n"
      "        out.println(\"<b><i>Added event.</i></b>\");\n"
      "    }\n"
      "}\n"
      "\n"
      "// Print page\n"
      "printEventForm(out);\n"
      "listEvents(out, dateFormatter);\n"
      "\n"
      "// Write HTML footer\n"
      "out.println(\"</body></html>\");\n"
      "out.flush();\n"
      "out.close();]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:962
#, no-c-format
msgid "Granted, this coding style with a mix of Java and HTML would not scale in a more complex application&mdash;keep in mind that we are only illustrating basic Hibernate concepts in this tutorial. The code prints an HTML header and a footer. Inside this page, an HTML form for event entry and a list of all events in the database are printed. The first method is trivial and only outputs HTML:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:971
#, no-c-format
msgid ""
      "<![CDATA[private void printEventForm(PrintWriter out) {\n"
      "    out.println(\"<h2>Add new event:</h2>\");\n"
      "    out.println(\"<form>\");\n"
      "    out.println(\"Title: <input name='eventTitle' length='50'/><br/>\");\n"
      "    out.println(\"Date (e.g. 24.12.2009): <input name='eventDate' length='10'/><br/>\");\n"
      "    out.println(\"<input type='submit' name='action' value='store'/>\");\n"
      "    out.println(\"</form>\");\n"
      "}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:973
#, no-c-format
msgid "The <literal>listEvents()</literal> method uses the Hibernate <literal>Session</literal> bound to the current thread to execute a query:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:979
#, no-c-format
msgid ""
      "<![CDATA[private void listEvents(PrintWriter out, SimpleDateFormat dateFormatter) {\n"
      "\n"
      "    List result = HibernateUtil.getSessionFactory()\n"
      "                    .getCurrentSession().createCriteria(Event.class).list();\n"
      "    if (result.size() > 0) {\n"
      "        out.println(\"<h2>Events in database:</h2>\");\n"
      "        out.println(\"<table border='1'>\");\n"
      "        out.println(\"<tr>\");\n"
      "        out.println(\"<th>Event title</th>\");\n"
      "        out.println(\"<th>Event date</th>\");\n"
      "        out.println(\"</tr>\");\n"
      "        for (Iterator it = result.iterator(); it.hasNext();) {\n"
      "            Event event = (Event) it.next();\n"
      "            out.println(\"<tr>\");\n"
      "            out.println(\"<td>\" + event.getTitle() + \"</td>\");\n"
      "            out.println(\"<td>\" + dateFormatter.format(event.getDate()) + \"</td>\");\n"
      "            out.println(\"</tr>\");\n"
      "        }\n"
      "        out.println(\"</table>\");\n"
      "    }\n"
      "}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:981
#, no-c-format
msgid "Finally, the <literal>store</literal> action is dispatched to the <literal>createAndStoreEvent()</literal> method, which also uses the <literal>Session</literal> of the current thread:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:987
#, no-c-format
msgid ""
      "<![CDATA[protected void createAndStoreEvent(String title, Date theDate) {\n"
      "    Event theEvent = new Event();\n"
      "    theEvent.setTitle(title);\n"
      "    theEvent.setDate(theDate);\n"
      "\n"
      "    HibernateUtil.getSessionFactory()\n"
      "                    .getCurrentSession().save(theEvent);\n"
      "}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:989
#, no-c-format
msgid "That's it, the servlet is complete. A request to the servlet will be processed in a single <literal>Session</literal> and <literal>Transaction</literal>. As earlier in the standalone application, Hibernate can automatically bind these objects to the current thread of execution. This gives you the freedom to layer your code and access the <literal>SessionFactory</literal> in any way you like. Usually you'd use a more sophisticated design and move the data access code into data access objects (the DAO pattern). See the Hibernate Wiki for more examples."
msgstr ""

#. Tag: title
#: tutorial.xml:1003
#, no-c-format
msgid "Deploying and testing"
msgstr ""

#. Tag: para
#: tutorial.xml:1005
#, no-c-format
msgid "To deploy this application you have to create a web archive, a WAR. Add the following Ant target to your <literal>build.xml</literal>:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:1010
#, no-c-format
msgid ""
      "<![CDATA[<target name=\"war\" depends=\"compile\">\n"
      "    <war destfile=\"hibernate-tutorial.war\" webxml=\"web.xml\">\n"
      "        <lib dir=\"${librarydir}\">\n"
      "          <exclude name=\"jsdk*.jar\"/>\n"
      "        </lib>\n"
      "\n"
      "        <classes dir=\"${targetdir}\"/>\n"
      "    </war>\n"
      "</target>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:1012
#, no-c-format
msgid "This target creates a file called <literal>hibernate-tutorial.war</literal> in your project directory. It packages all libraries and the <literal>web.xml</literal> descriptor, which is expected in the base directory of your project:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:1018
#, no-c-format
msgid ""
      "<![CDATA[<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
      "<web-app version=\"2.4\"\n"
      "    xmlns=\"http://java.sun.com/xml/ns/j2ee\"\n"
      "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
      "    xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\">\n"
      "\n"
      "    <servlet>\n"
      "        <servlet-name>Event Manager</servlet-name>\n"
      "        <servlet-class>events.EventManagerServlet</servlet-class>\n"
      "    </servlet>\n"
      "\n"
      "    <servlet-mapping>\n"
      "        <servlet-name>Event Manager</servlet-name>\n"
      "        <url-pattern>/eventmanager</url-pattern>\n"
      "    </servlet-mapping>\n"
      "</web-app>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:1020
#, no-c-format
msgid "Before you compile and deploy the web application, note that an additional library is required: <literal>jsdk.jar</literal>. This is the Java servlet development kit, if you don't have this library already, get it from the Sun website and copy it to your library directory. However, it will be only used for compilation and excluded from the WAR package."
msgstr ""

#. Tag: para
#: tutorial.xml:1028
#, no-c-format
msgid "To build and deploy call <literal>ant war</literal> in your project directory and copy the <literal>hibernate-tutorial.war</literal> file into your Tomcat <literal>webapp</literal> directory. If you don't have Tomcat installed, download it and follow the installation instructions. You don't have to change any Tomcat configuration to deploy this application though."
msgstr ""

#. Tag: para
#: tutorial.xml:1036
#, no-c-format
msgid "Once deployed and Tomcat is running, access the application at <literal>http://localhost:8080/hibernate-tutorial/eventmanager</literal>. Make sure you watch the Tomcat log to see Hibernate initialize when the first request hits your servlet (the static initializer in <literal>HibernateUtil</literal> is called) and to get the detailed output if any exceptions occurs."
msgstr ""

#. Tag: title
#: tutorial.xml:1049
#, no-c-format
msgid "Summary"
msgstr ""

#. Tag: para
#: tutorial.xml:1051
#, no-c-format
msgid "This tutorial covered the basics of writing a simple standalone Hibernate application and a small web application."
msgstr ""

#. Tag: para
#: tutorial.xml:1056
#, no-c-format
msgid "If you already feel confident with Hibernate, continue browsing through the reference documentation table of contents for topics you find interesting - most asked are transactional processing (<xref linkend=\"transactions\"/>), fetch performance (<xref linkend=\"performance\"/>), or the usage of the API (<xref linkend=\"objectstate\"/>) and the query features (<xref linkend=\"objectstate-querying\"/>)."
msgstr ""

#. Tag: para
#: tutorial.xml:1064
#, no-c-format
msgid "Don't forget to check the Hibernate website for more (specialized) tutorials."
msgstr ""

