msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2007-10-25 01:01+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: tutorial.xml:7
#, no-c-format
msgid "Introduction to Hibernate"
msgstr "Hibernate入门"

#. Tag: title
#: tutorial.xml:10
#, no-c-format
msgid "Preface"
msgstr "前言"

#. Tag: para
#: tutorial.xml:12
#, no-c-format
msgid ""
"This chapter is an introductory tutorial for new users of Hibernate. We "
"start with a simple command line application using an in-memory database and "
"develop it in easy to understand steps."
msgstr ""
"本章是面向Hibernate初学者的一个入门教程。我们从一个使用驻留内存式(in-memory)"
"数据库的简单命令行应用程序开始, 用易于理解的方式逐步开发。"

#. Tag: para
#: tutorial.xml:18
#, no-c-format
msgid ""
"This tutorial is intended for new users of Hibernate but requires Java and "
"SQL knowledge. It is based on a tutorial by Michael Gloegl, the third-party "
"libraries we name are for JDK 1.4 and 5.0. You might need others for JDK 1.3."
msgstr ""
"本章面向Hibernate初学者，但需要Java和SQL知识。它是在Michael Goegl所写的指南的"
"基础上完成的。在这里，我们称第三方库文件是指JDK 1.4和5.0。若使用JDK1.3，你可"
"能需要其它的库文件。"

#. Tag: para
#: tutorial.xml:24
#, no-c-format
msgid ""
"The source code for the tutorial is included in the distribution in the "
"<literal>doc/reference/tutorial/</literal> directory."
msgstr ""
"本章的源代码已包含在发布包中，位于<literal>doc/reference/tutorial/</literal>"
"目录下。"

#. Tag: title
#: tutorial.xml:32
#, no-c-format
msgid "Part 1 - The first Hibernate Application"
msgstr "第一部分 － 第一个Hibernate应用程序"

#. Tag: para
#: tutorial.xml:34
#, no-c-format
msgid ""
"First, we'll create a simple console-based Hibernate application. We use an "
"Java database (HSQL DB), so we do not have to install any database server."
msgstr ""
"首先我们将创建一个简单的基于控制台的(console-based)Hibernate应用程序。由于我"
"们使用Java数据库(HSQL DB)，所以不必安装任何数据库服务器。"

#. Tag: para
#: tutorial.xml:39
#, no-c-format
msgid ""
"Let's assume we need a small database application that can store events we "
"want to attend, and information about the hosts of these events."
msgstr ""
"假设我们希望有一个小应用程序可以保存我们希望参加的活动（events）和这些活动主"
"办方的相关信息。 （译者注：在本教程的后面部分，我们将直接使用event而不是它的"
"中文翻译“活动”，以免混淆。）"

#. Tag: para
#: tutorial.xml:44
#, no-c-format
msgid ""
"The first thing we do, is set up our development directory and put all the "
"Java libraries we need into it. Download the Hibernate distribution from the "
"Hibernate website. Extract the package and place all required libraries "
"found in <literal>/lib</literal> into into the <literal>/lib</literal> "
"directory of your new development working directory. It should look like "
"this:"
msgstr ""
"我们所做的第一件事就是创建我们的开发目录，并且把所有需要用到的Java库文件放进"
"去。解压缩从Hibernate网站下载的Hibernate发布包，并把<literal>/lib</literal>目"
"录下所有需要的库文件拷到我们新建开发目录下的<literal>/lib</literal>目录下。看"
"起来就像这样："

#. Tag: programlisting
#: tutorial.xml:52
#, no-c-format
msgid ""
"<![CDATA[.\n"
"+lib\n"
"  antlr.jar\n"
"  cglib.jar\n"
"  asm.jar\n"
"  asm-attrs.jars\n"
"  commons-collections.jar\n"
"  commons-logging.jar\n"
"  hibernate3.jar\n"
"  jta.jar\n"
"  dom4j.jar\n"
"  log4j.jar ]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:54
#, no-c-format
msgid ""
"This is the minimum set of required libraries (note that we also copied "
"hibernate3.jar, the main archive) for Hibernate <emphasis>at the time of "
"writing</emphasis>. The Hibernate release you are using might require more "
"or less libraries. See the <literal>README.txt</literal> file in the "
"<literal>lib/</literal> directory of the Hibernate distribution for more "
"information about required and optional third-party libraries. (Actually, "
"Log4j is not required but preferred by many developers.)"
msgstr ""
"<emphasis>到编写本文时为止</emphasis>，这些是Hibernate运行所需要的最小库文件"
"集合（注意我们也拷贝了 Hibernate3.jar，这个是最主要的文件）。你正使用的"
"Hibernate版本可能需要比这更多或少一些的库文件。请参见发布包中的<literal>lib/"
"</literal>目录下的<literal>README.txt</literal>，以获取更多关于所需和可选的第"
"三方库文件信息（事实上，Log4j并不是必须的库文件，但被许多开发者所喜欢）。"

#. Tag: para
#: tutorial.xml:63
#, no-c-format
msgid ""
"Next we create a class that represents the event we want to store in "
"database."
msgstr "接下来我们创建一个类，用来代表那些我们希望储存在数据库里的event。"

#. Tag: title
#: tutorial.xml:68
#, no-c-format
msgid "The first class"
msgstr "第一个class"

#. Tag: para
#: tutorial.xml:70
#, no-c-format
msgid ""
"Our first persistent class is a simple JavaBean class with some properties:"
msgstr "我们的第一个持久化类是一个带有一些属性（property）的简单JavaBean类："

#. Tag: programlisting
#: tutorial.xml:74
#, no-c-format
msgid ""
"<![CDATA[package events;\n"
"\n"
"import java.util.Date;\n"
"\n"
"public class Event {\n"
"    private Long id;\n"
"\n"
"    private String title;\n"
"    private Date date;\n"
"\n"
"    public Event() {}\n"
"\n"
"    public Long getId() {\n"
"        return id;\n"
"    }\n"
"\n"
"    private void setId(Long id) {\n"
"        this.id = id;\n"
"    }\n"
"\n"
"    public Date getDate() {\n"
"        return date;\n"
"    }\n"
"\n"
"    public void setDate(Date date) {\n"
"        this.date = date;\n"
"    }\n"
"\n"
"    public String getTitle() {\n"
"        return title;\n"
"    }\n"
"\n"
"    public void setTitle(String title) {\n"
"        this.title = title;\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:76
#, no-c-format
msgid ""
"You can see that this class uses standard JavaBean naming conventions for "
"property getter and setter methods, as well as private visibility for the "
"fields. This is a recommended design - but not required. Hibernate can also "
"access fields directly, the benefit of accessor methods is robustness for "
"refactoring. The no-argument constructor is required to instantiate an "
"object of this class through reflection."
msgstr ""
"你可以看到这个类对属性的存取方法（getter and setter method）使用了标准"
"JavaBean命名约定，同时把类属性（field）的访问级别设成私有的（private）。这是"
"推荐的设计，但并不是必须的。Hibernate也可以直接访问这些field，而使用访问方法"
"（accessor method）的好处是提供了重构时的健壮性（robustness）。为了通过反射机"
"制（Reflection）来实例化这个类的对象，我们需要提供一个无参的构造器（no-"
"argument constructor)。"

#. Tag: para
#: tutorial.xml:84
#, no-c-format
msgid ""
"The <literal>id</literal> property holds a unique identifier value for a "
"particular event. All persistent entity classes (there are less important "
"dependent classes as well) will need such an identifier property if we want "
"to use the full feature set of Hibernate. In fact, most applications (esp. "
"web applications) need to distinguish objects by identifier, so you should "
"consider this a feature rather than a limitation. However, we usually don't "
"manipulate the identity of an object, hence the setter method should be "
"private. Only Hibernate will assign identifiers when an object is saved. You "
"can see that Hibernate can access public, private, and protected accessor "
"methods, as well as (public, private, protected) fields directly. The choice "
"is up to you and you can match it to fit your application design."
msgstr ""
"对一特定的event, <literal>id</literal> 属性持有唯一的标识符（identifier）的"
"值。如果我们希望使用Hibernate提供的所有特性，那么所有的持久化实体"
"（persistent entity）类（这里也包括一些次要依赖类）都需要一个这样的标识符属"
"性。而事实上，大多数应用程序（特别是web应用程序）都需要通过标识符来区别对象，"
"所以你应该考虑使用标识符属性而不是把它当作一种限制。然而，我们通常不会操作对"
"象的标识（identity），因此它的setter方法的访问级别应该声明private。这样当对象"
"被保存的时候，只有Hibernate可以为它分配标识符值。你可看到Hibernate可以直接访"
"问public，private和protected的访问方法和field。所以选择哪种方式完全取决于你，"
"你可以使你的选择与你的应用程序设计相吻合。"

#. Tag: para
#: tutorial.xml:96
#, no-c-format
msgid ""
"The no-argument constructor is a requirement for all persistent classes; "
"Hibernate has to create objects for you, using Java Reflection. The "
"constructor can be private, however, package visibility is required for "
"runtime proxy generation and efficient data retrieval without bytecode "
"instrumentation."
msgstr ""
"所有的持久化类（persistent classes）都要求有无参的构造器，因为Hibernate必须使"
"用Java反射机制来为你创建对象。构造器（constructor）的访问级别可以是private，"
"然而当生成运行时代理（runtime proxy）的时候则要求使用至少是package 级别的访问"
"控制，这样在没有字节码指令（bytecode instrumentation）的情况下，从持久化类里"
"获取数据会更有效率。"

#. Tag: para
#: tutorial.xml:103
#, no-c-format
msgid ""
"Place this Java source file in a directory called <literal>src</literal> in "
"the development folder, and in its correct package. The directory should now "
"look like this:"
msgstr ""
"把这个Java源代码文件放到开发目录下的<literal>src</literal>目录里，注意包位置"
"要正确。 现在这个目录看起来应该像这样："

#. Tag: programlisting
#: tutorial.xml:108
#, no-c-format
msgid ""
"<![CDATA[.\n"
"+lib\n"
"  <Hibernate and third-party libraries>\n"
"+src\n"
"  +events\n"
"    Event.java]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:110
#, no-c-format
msgid "In the next step, we tell Hibernate about this persistent class."
msgstr "下一步，我们把这个持久化类的信息告诉Hibernate。"

#. Tag: title
#: tutorial.xml:117
#, no-c-format
msgid "The mapping file"
msgstr "映射文件"

#. Tag: para
#: tutorial.xml:119
#, no-c-format
msgid ""
"Hibernate needs to know how to load and store objects of the persistent "
"class. This is where the Hibernate mapping file comes into play. The mapping "
"file tells Hibernate what table in the database it has to access, and what "
"columns in that table it should use."
msgstr ""
"Hibernate需要知道怎样去加载（load）和存储（store）持久化类的对象。这正是"
"Hibernate映射文件发挥作用的地方。映射文件告诉Hibernate它，应该访问数据库"
"(database)里面的哪个表（table）及应该使用表里面的哪些字段（column）。"

#. Tag: para
#: tutorial.xml:126
#, no-c-format
msgid "The basic structure of a mapping file looks like this:"
msgstr "一个映射文件的基本结构看起来像这样："

#. Tag: programlisting
#: tutorial.xml:130
#, no-c-format
msgid ""
"<![CDATA[<?xml version=\"1.0\"?>\n"
"<!DOCTYPE hibernate-mapping PUBLIC\n"
"        \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
"        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\n"
"\n"
"<hibernate-mapping>\n"
"[...]\n"
"</hibernate-mapping>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:132
#, no-c-format
msgid ""
"Note that the Hibernate DTD is very sophisticated. You can use it for auto-"
"completion of XML mapping elements and attributes in your editor or IDE. You "
"also should open up the DTD file in your text editor - it's the easiest way "
"to get an overview of all elements and attributes and to see the defaults, "
"as well as some comments. Note that Hibernate will not load the DTD file "
"from the web, but first look it up from the classpath of the application. "
"The DTD file is included in <literal>hibernate3.jar</literal> as well as in "
"the <literal>src/</literal> directory of the Hibernate distribution."
msgstr ""
"注意Hibernate的DTD是非常复杂的。你的编辑器或者IDE里使用它来自动完成那些用来映"
"射的XML元素（element）和属性（attribute）。你也可以在文本编辑器里打开DTD－这"
"是最简单的方式来概览所有的元素和attribute，并查看它们的缺省值以及注释。注意"
"Hibernate不会从web加载DTD文件，但它会首先在应用程序的classpath中查找。DTD文件"
"已包括在<literal>hibernate3.jar</literal>里，同时也在Hibernate发布包的"
"<literal>src/</literal>目录下。"

#. Tag: para
#: tutorial.xml:143
#, no-c-format
msgid ""
"We will omit the DTD declaration in future examples to shorten the code. It "
"is of course not optional."
msgstr ""
"为缩短代码长度，在以后的例子里我们会省略DTD的声明。当然，在实际的应用程序中，"
"DTD声明是必须的。"

#. Tag: para
#: tutorial.xml:148
#, no-c-format
msgid ""
"Between the two <literal>hibernate-mapping</literal> tags, include a "
"<literal>class</literal> element. All persistent entity classes (again, "
"there might be dependent classes later on, which are not first-class "
"entities) need such a mapping, to a table in the SQL database:"
msgstr ""
"在<literal>hibernate-mapping</literal>标签（tag）之间, 含有一个"
"<literal>class</literal>元素。所有的持久化实体类（再次声明，或许接下来会有依"
"赖类，就是那些次要的实体）都需要一个这样的映射，来把类对象映射到SQL数据库里的"
"表。"

#. Tag: programlisting
#: tutorial.xml:155
#, no-c-format
msgid ""
"<![CDATA[<hibernate-mapping>\n"
"\n"
"    <class name=\"events.Event\" table=\"EVENTS\">\n"
"\n"
"    </class>\n"
"\n"
"</hibernate-mapping>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:157
#, no-c-format
msgid ""
"So far we told Hibernate how to persist and load object of class "
"<literal>Event</literal> to the table <literal>EVENTS</literal>, each "
"instance represented by a row in that table. Now we continue with a mapping "
"of the unique identifier property to the tables primary key. In addition, as "
"we don't want to care about handling this identifier, we configure "
"Hibernate's identifier generation strategy for a surrogate primary key "
"column:"
msgstr ""
"到目前为止，我们告诉了Hibernate怎样把<literal>Events</literal>类的对象持久化"
"到数据库的<literal>EVENTS</literal>表里，以及怎样从<literal>EVENTS</literal>"
"表加载到<literal>Events</literal>类的对象。每个实例对应着数据库表中的一行。现"
"在我们将继续讨论有关唯一标识符属性到数据库表的映射。另外，由于我们不关心怎样"
"处理这个标识符，我们就配置由Hibernate的标识符生成策略来产生代理主键字段。"

#. Tag: programlisting
#: tutorial.xml:165
#, no-c-format
msgid ""
"<![CDATA[<hibernate-mapping>\n"
"\n"
"    <class name=\"events.Event\" table=\"EVENTS\">\n"
"        <id name=\"id\" column=\"EVENT_ID\">\n"
"            <generator class=\"native\"/>\n"
"        </id>\n"
"    </class>\n"
"\n"
"</hibernate-mapping>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:167
#, no-c-format
msgid ""
"The <literal>id</literal> element is the declaration of the identifer "
"property, <literal>name=\"id\"</literal> declares the name of the Java "
"property - Hibernate will use the getter and setter methods to access the "
"property. The column attribute tells Hibernate which column of the "
"<literal>EVENTS</literal> table we use for this primary key. The nested "
"<literal>generator</literal> element specifies the identifier generation "
"strategy, in this case we used <literal>native</literal>, which picks the "
"best strategy depending on the configured database (dialect). Hibernate "
"supports database generated, globally unique, as well as application "
"assigned identifiers (or any strategy you have written an extension for)."
msgstr ""
"<literal>id</literal>元素是标识符属性的声明，<literal>name=\"id\"</literal> "
"声明了Java属性的名字 － Hibernate会使用<literal>getId()</literal>和"
"<literal>setId()</literal>来访问它。 <literal>column</literal>属性则告诉"
"Hibernate, 我们使用<literal>EVENTS</literal>表的哪个字段作为主键。嵌套的"
"<literal>generator</literal>元素指定了标识符生成策略，在这里我们指定"
"<literal>native</literal>，它根据已配置的数据库（方言）自动选择最佳的标识符生"
"成策略。Hibernate支持由数据库生成，全局唯一性（globally unique）和应用程序指"
"定（或者你自己为任何已有策略所写的扩展）这些策略来生成标识符。"

#. Tag: para
#: tutorial.xml:180
#, no-c-format
msgid ""
"Finally we include declarations for the persistent properties of the class "
"in the mapping file. By default, no properties of the class are considered "
"persistent:"
msgstr ""
"最后我们在映射文件里面包含需要持久化属性的声明。默认情况下，类里面的属性都被"
"视为非持久化的："

#. Tag: programlisting
#: tutorial.xml:186
#, no-c-format
msgid ""
"<![CDATA[\n"
"<hibernate-mapping>\n"
"\n"
"    <class name=\"events.Event\" table=\"EVENTS\">\n"
"        <id name=\"id\" column=\"EVENT_ID\">\n"
"            <generator class=\"native\"/>\n"
"        </id>\n"
"        <property name=\"date\" type=\"timestamp\" column=\"EVENT_DATE\"/>\n"
"        <property name=\"title\"/>\n"
"    </class>\n"
"\n"
"</hibernate-mapping>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:188
#, no-c-format
msgid ""
"Just as with the <literal>id</literal> element, the <literal>name</literal> "
"attribute of the <literal>property</literal> element tells Hibernate which "
"getter and setter methods to use. So, in this case, Hibernate will look for "
"<literal>getDate()/setDate()</literal>, as well as <literal>getTitle()/"
"setTitle()</literal>."
msgstr ""
"和<literal>id</literal>元素一样，<literal>property</literal>元素的"
"<literal>name</literal>属性告诉Hibernate使用哪个getter和setter方法。在此例"
"中，Hibernate会寻找<literal>getDate()/setDate()</literal>, 以及"
"<literal>getTitle()/setTitle()</literal>。"

#. Tag: para
#: tutorial.xml:195
#, no-c-format
msgid ""
"Why does the <literal>date</literal> property mapping include the "
"<literal>column</literal> attribute, but the <literal>title</literal> "
"doesn't? Without the <literal>column</literal> attribute Hibernate by "
"default uses the property name as the column name. This works fine for "
"<literal>title</literal>. However, <literal>date</literal> is a reserved "
"keyword in most database, so we better map it to a different name."
msgstr ""
"为什么<literal>date</literal>属性的映射含有<literal>column</literal> "
"attribute，而<literal>title</literal>却没有？当没有设定<literal>column</"
"literal> attribute 的时候，Hibernate缺省地使用JavaBean的属性名作为字段名。对"
"于<literal>title</literal>，这样工作得很好。然而，<literal>date</literal>在多"
"数的数据库里，是一个保留关键字，所以我们最好把它映射成一个不同的名字。"

#. Tag: para
#: tutorial.xml:204
#, no-c-format
msgid ""
"The next interesting thing is that the <literal>title</literal> mapping also "
"lacks a <literal>type</literal> attribute. The types we declare and use in "
"the mapping files are not, as you might expect, Java data types. They are "
"also not SQL database types. These types are so called <emphasis>Hibernate "
"mapping types</emphasis>, converters which can translate from Java to SQL "
"data types and vice versa. Again, Hibernate will try to determine the "
"correct conversion and mapping type itself if the <literal>type</literal> "
"attribute is not present in the mapping. In some cases this automatic "
"detection (using Reflection on the Java class) might not have the default "
"you expect or need. This is the case with the <literal>date</literal> "
"property. Hibernate can't know if the property (which is of <literal>java."
"util.Date</literal>) should map to a SQL <literal>date</literal>, "
"<literal>timestamp</literal>, or <literal>time</literal> column. We preserve "
"full date and time information by mapping the property with a "
"<literal>timestamp</literal> converter."
msgstr ""
"另一有趣的事情是<literal>title</literal>属性缺少一个<literal>type</literal> "
"attribute。我们在映射文件里声明并使用的类型，却不是我们期望的那样，是Java数据"
"类型，同时也不是SQL数据库的数据类型。这些类型就是所谓的Hibernate 映射类型"
"<emphasis>（mapping types）</emphasis>，它们能把Java数据类型转换到SQL数据类"
"型，反之亦然。再次重申，如果在映射文件中没有设置<literal>type</literal>属性的"
"话，Hibernate会自己试着去确定正确的转换类型和它的映射类型。在某些情况下这个自"
"动检测机制（在Java 类上使用反射机制）不会产生你所期待或需要的缺省值。"
"<literal>date</literal>属性就是个很好的例子，Hibernate无法知道这个属性"
"（<literal>java.util.Date</literal>类型的）应该被映射成：SQL <literal>date</"
"literal>，或<literal>timestamp</literal>，还是<literal>time</literal> 字段。"
"在此例中，把这个属性映射成<literal>timestamp</literal> 转换器，这样我们预留了"
"日期和时间的全部信息。"

#. Tag: para
#: tutorial.xml:220
#, no-c-format
msgid ""
"This mapping file should be saved as <literal>Event.hbm.xml</literal>, right "
"in the directory next to the <literal>Event</literal> Java class source "
"file. The naming of mapping files can be arbitrary, however the <literal>hbm."
"xml</literal> suffix is a convention in the Hibernate developer community. "
"The directory structure should now look like this:"
msgstr ""
"应该把这个映射文件保存为<literal>Event.hbm.xml</literal>，且就在"
"<literal>Event</literal>Java类的源文件目录下。映射文件可随意地命名，但"
"<literal>hbm.xml</literal>的后缀已成为Hibernate开发者社区的约定。现在目录结构"
"看起来应该像这样："

#. Tag: programlisting
#: tutorial.xml:228
#, no-c-format
msgid ""
"<![CDATA[.\n"
"+lib\n"
"  <Hibernate and third-party libraries>\n"
"+src\n"
"  +events\n"
"    Event.java\n"
"    Event.hbm.xml]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:230
#, no-c-format
msgid "We continue with the main configuration of Hibernate."
msgstr "我们继续进行Hibernate的主要配置。"

#. Tag: title
#: tutorial.xml:237
#, no-c-format
msgid "Hibernate configuration"
msgstr "Hibernate配置"

#. Tag: para
#: tutorial.xml:239
#, no-c-format
msgid ""
"We now have a persistent class and its mapping file in place. It is time to "
"configure Hibernate. Before we do this, we will need a database. HSQL DB, a "
"java-based SQL DBMS, can be downloaded from the HSQL DB website(http://"
"hsqldb.org/). Actually, you only need the <literal>hsqldb.jar</literal> from "
"this download. Place this file in the <literal>lib/</literal> directory of "
"the development folder."
msgstr ""
"现在我们已经有了一个持久化类和它的映射文件，该是配置Hibernate的时候了。在此之"
"前，我们需要一个数据库。 HSQL DB是种基于Java 的SQL数据库管理系统（DBMS），可"
"以从HSQL DB的网站上下载。实际上，你只需下载的包中的<literal>hsqldb.jar</"
"literal>文件，并把这个文件放在开发文件夹的<literal>lib/</literal>目录下即可。"

#. Tag: para
#: tutorial.xml:247
#, no-c-format
msgid ""
"Create a directory called <literal>data</literal> in the root of the "
"development directory - this is where HSQL DB will store its data files. Now "
"start the database by running <literal>java -classpath ../lib/hsqldb.jar org."
"hsqldb.Server</literal> in this data directory. You can see it start up and "
"bind to a TCP/IP socket, this is where our application will connect later. "
"If you want to start with a fresh database during this tutorial, shutdown "
"HSQL DB (press <literal>CTRL + C</literal> in the window), delete all files "
"in the <literal>data/</literal> directory, and start HSQL DB again."
msgstr ""
"在开发的根目录下创建一个<literal>data</literal>目录 － 这是HSQL DB存储数据文"
"件的地方。此时在data目录中运行<literal>java -classpath ../lib/hsqldb.jar org."
"hsqldb.Server</literal>就可启动数据库。你可以在log中看到它的启动，及绑定到"
"TCP/IP套结字，这正是我们的应用程序稍后会连接的地方。如果你希望在本例中运行一"
"个全新的数据库，就在窗口中按下<literal>CTRL + C</literal>来关闭HSQL数据库，并"
"删除<literal>data/</literal>目录下的所有文件，再重新启动HSQL数据库。"

#. Tag: para
#: tutorial.xml:257
#, no-c-format
msgid ""
"Hibernate is the layer in your application which connects to this database, "
"so it needs connection information. The connections are made through a JDBC "
"connection pool, which we also have to configure. The Hibernate distribution "
"contains several open source JDBC connection pooling tools, but will use the "
"Hibernate built-in connection pool for this tutorial. Note that you have to "
"copy the required library into your classpath and use different connection "
"pooling settings if you want to use a production-quality third party JDBC "
"pooling software."
msgstr ""
"Hibernate是你的应用程序里连接数据库的那层，所以它需要连接用的信息。连接"
"（connection）是通过一个也由我们配置的JDBC连接池（connection pool）来完成的。"
"Hibernate的发布包里包含了许多开源的（open source）连接池，但在我们例子中使用"
"Hibernate内置的连接池。注意，如果你希望使用一个产品级(production-quality)的第"
"三方连接池软件，你必须拷贝所需的库文件到你的classpath下，并使用不同的连接池设"
"置。"

#. Tag: para
#: tutorial.xml:267
#, no-c-format
msgid ""
"For Hibernate's configuration, we can use a simple <literal>hibernate."
"properties</literal> file, a slightly more sophisticated <literal>hibernate."
"cfg.xml</literal> file, or even complete programmatic setup. Most users "
"prefer the XML configuration file:"
msgstr ""
"为了保存Hibernate的配置，我们可以使用一个简单的<literal>hibernate."
"properties</literal>文件，或者一个稍微复杂的<literal>hibernate.cfg.xml</"
"literal>，甚至可以完全使用程序来配置Hibernate。多数用户更喜欢使用XML配置文"
"件："

#. Tag: programlisting
#: tutorial.xml:273
#, no-c-format
msgid ""
"<![CDATA[<?xml version='1.0' encoding='utf-8'?>\n"
"<!DOCTYPE hibernate-configuration PUBLIC\n"
"        \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n"
"        \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"
"\">\n"
"\n"
"<hibernate-configuration>\n"
"\n"
"    <session-factory>\n"
"\n"
"        <!-- Database connection settings -->\n"
"        <property name=\"connection.driver_class\">org.hsqldb.jdbcDriver</"
"property>\n"
"        <property name=\"connection.url\">jdbc:hsqldb:hsql://localhost</"
"property>\n"
"        <property name=\"connection.username\">sa</property>\n"
"        <property name=\"connection.password\"></property>\n"
"\n"
"        <!-- JDBC connection pool (use the built-in) -->\n"
"        <property name=\"connection.pool_size\">1</property>\n"
"\n"
"        <!-- SQL dialect -->\n"
"        <property name=\"dialect\">org.hibernate.dialect.HSQLDialect</"
"property>\n"
"\n"
"        <!-- Enable Hibernate's automatic session context management -->\n"
"        <property name=\"current_session_context_class\">thread</property>\n"
"\n"
"        <!-- Disable the second-level cache  -->\n"
"        <property name=\"cache.provider_class\">org.hibernate.cache."
"NoCacheProvider</property>\n"
"\n"
"        <!-- Echo all executed SQL to stdout -->\n"
"        <property name=\"show_sql\">true</property>\n"
"\n"
"        <!-- Drop and re-create the database schema on startup -->\n"
"        <property name=\"hbm2ddl.auto\">create</property>\n"
"\n"
"        <mapping resource=\"events/Event.hbm.xml\"/>\n"
"\n"
"    </session-factory>\n"
"\n"
"</hibernate-configuration>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:275
#, no-c-format
msgid ""
"Note that this XML configuration uses a different DTD. We configure "
"Hibernate's <literal>SessionFactory</literal> - a global factory responsible "
"for a particular database. If you have several databases, use several "
"<literal>&lt;session-factory&gt;</literal> configurations, usually in "
"several configuration files (for easier startup)."
msgstr ""
"注意这个XML配置使用了一个不同的DTD。在这里，我们配置了Hibernate的"
"<literal>SessionFactory</literal>－一个关联于特定数据库全局的工厂"
"（factory）。如果你要使用多个数据库，就要用多个的<literal>&lt;session-"
"factory&gt;</literal>，通常把它们放在多个配置文件中（为了更容易启动）。"

#. Tag: para
#: tutorial.xml:283
#, no-c-format
msgid ""
"The first four <literal>property</literal> elements contain the necessary "
"configuration for the JDBC connection. The dialect <literal>property</"
"literal> element specifies the particular SQL variant Hibernate generates. "
"Hibernate's automatic session management for persistence contexts will come "
"in handy as you will soon see. The <literal>hbm2ddl.auto</literal> option "
"turns on automatic generation of database schemas - directly into the "
"database. This can of course also be turned off (by removing the config "
"option) or redirected to a file with the help of the <literal>SchemaExport</"
"literal> Ant task. Finally, we add the mapping file(s) for persistent "
"classes to the configuration."
msgstr ""
"最开始的4个<literal>property</literal>元素包含必要的JDBC连接信息。方言"
"（dialect）的<literal>property</literal>元素指明Hibernate 生成的特定SQL变量。"
"你很快会看到，Hibernate对持久化上下文的自动session管理就会派上用场。 打开"
"<literal>hbm2ddl.auto</literal>选项将自动生成数据库模式（schema）－ 直接加入"
"数据库中。当然这个选项也可以被关闭（通过去除这个配置选项）或者通过Ant任务"
"<literal>SchemaExport</literal>的帮助来把数据库schema重定向到文件中。最后，在"
"配置中为持久化类加入映射文件。"

#. Tag: para
#: tutorial.xml:296
#, no-c-format
msgid ""
"Copy this file into the source directory, so it will end up in the root of "
"the classpath. Hibernate automatically looks for a file called "
"<literal>hibernate.cfg.xml</literal> in the root of the classpath, on "
"startup."
msgstr ""
"把这个文件拷贝到源代码目录下面，这样它就位于classpath的根目录的最后。"
"Hibernate在启动时会自动在classpath的根目录查找名为<literal>hibernate.cfg."
"xml</literal>的配置文件。"

#. Tag: title
#: tutorial.xml:305
#, no-c-format
msgid "Building with Ant"
msgstr "用Ant构建"

#. Tag: para
#: tutorial.xml:307
#, no-c-format
msgid ""
"We'll now build the tutorial with Ant. You will need to have Ant installed - "
"get it from the <ulink url=\"http://ant.apache.org/bindownload.cgi\">Ant "
"download page</ulink>. How to install Ant will not be covered here. Please "
"refer to the <ulink url=\"http://ant.apache.org/manual/index.html\">Ant "
"manual</ulink>. After you have installed Ant, we can start to create the "
"buildfile. It will be called <literal>build.xml</literal> and placed "
"directly in the development directory."
msgstr ""
"现在我们用Ant来构建应用程序。你必须先安装Ant－可以从<ulink url=\"http://ant."
"apache.org/bindownload.cgi\">Ant 下载页面</ulink>得到它。怎样安装Ant就不在这"
"里介绍了，请参考<ulink url=\"http://ant.apache.org/manual/index.html\">Ant 用"
"户手册</ulink>。当你安装完了Ant，就可以开始创建<literal>build.xml</literal>文"
"件，把它直接放在开发目录下面。"

#. Tag: para
#: tutorial.xml:316
#, no-c-format
msgid "A basic build file looks like this:"
msgstr "一个简单的build文件看起来像这样："

#. Tag: programlisting
#: tutorial.xml:320
#, no-c-format
msgid ""
"<![CDATA[<project name=\"hibernate-tutorial\" default=\"compile\">\n"
"\n"
"    <property name=\"sourcedir\" value=\"${basedir}/src\"/>\n"
"    <property name=\"targetdir\" value=\"${basedir}/bin\"/>\n"
"    <property name=\"librarydir\" value=\"${basedir}/lib\"/>\n"
"\n"
"    <path id=\"libraries\">\n"
"        <fileset dir=\"${librarydir}\">\n"
"            <include name=\"*.jar\"/>\n"
"        </fileset>\n"
"    </path>\n"
"\n"
"    <target name=\"clean\">\n"
"        <delete dir=\"${targetdir}\"/>\n"
"        <mkdir dir=\"${targetdir}\"/>\n"
"    </target>\n"
"\n"
"    <target name=\"compile\" depends=\"clean, copy-resources\">\n"
"      <javac srcdir=\"${sourcedir}\"\n"
"             destdir=\"${targetdir}\"\n"
"             classpathref=\"libraries\"/>\n"
"    </target>\n"
"\n"
"    <target name=\"copy-resources\">\n"
"        <copy todir=\"${targetdir}\">\n"
"            <fileset dir=\"${sourcedir}\">\n"
"                <exclude name=\"**/*.java\"/>\n"
"            </fileset>\n"
"        </copy>\n"
"    </target>\n"
"\n"
"</project>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:322
#, no-c-format
msgid ""
"This will tell Ant to add all files in the lib directory ending with "
"<literal>.jar</literal> to the classpath used for compilation. It will also "
"copy all non-Java source files to the target directory, e.g. configuration "
"and Hibernate mapping files. If you now run Ant, you should get this output:"
msgstr ""
"这将告诉Ant把所有在lib目录下以<literal>.jar</literal>结尾的文件拷贝到"
"classpath中以供编译之用。它也把所有的非Java源代码文件，例如配置和Hibernate映"
"射文件，拷贝到目标目录。如果你现在运行Ant，会得到以下输出："

#. Tag: programlisting
#: tutorial.xml:329
#, no-c-format
msgid ""
"<![CDATA[C:\\hibernateTutorial\\>ant\n"
"Buildfile: build.xml\n"
"\n"
"copy-resources:\n"
"     [copy] Copying 2 files to C:\\hibernateTutorial\\bin\n"
"\n"
"compile:\n"
"    [javac] Compiling 1 source file to C:\\hibernateTutorial\\bin\n"
"\n"
"BUILD SUCCESSFUL\n"
"Total time: 1 second ]]>"
msgstr ""

#. Tag: title
#: tutorial.xml:334
#, no-c-format
msgid "Startup and helpers"
msgstr "启动和辅助类"

#. Tag: para
#: tutorial.xml:336
#, no-c-format
msgid ""
"It's time to load and store some <literal>Event</literal> objects, but first "
"we have to complete the setup with some infrastructure code. We have to "
"startup Hibernate. This startup includes building a global "
"<literal>SessionFactory</literal> object and to store it somewhere for easy "
"access in application code. A <literal>SessionFactory</literal> can open up "
"new <literal>Session</literal>'s. A <literal>Session</literal> represents a "
"single-threaded unit of work, the <literal>SessionFactory</literal> is a "
"thread-safe global object, instantiated once."
msgstr ""
"是时候来加载和储存一些<literal>Event</literal>对象了，但首先我们得编写一些基"
"础的代码以完成设置。我们必须启动Hibernate，此过程包括创建一个全局的"
"<literal>SessoinFactory</literal>，并把它储存在应用程序代码容易访问的地方。"
"<literal>SessionFactory</literal>可以创建并打开新的<literal>Session</"
"literal>。一个<literal>Session</literal>代表一个单线程的单元操作，"
"<literal>SessionFactory</literal>则是个线程安全的全局对象，只需要被实例化一"
"次。"

#. Tag: para
#: tutorial.xml:346
#, no-c-format
msgid ""
"We'll create a <literal>HibernateUtil</literal> helper class which takes "
"care of startup and makes accessing a <literal>SessionFactory</literal> "
"convenient. Let's have a look at the implementation:"
msgstr ""
"我们将创建一个<literal>HibernateUtil</literal>辅助类（helper class）来负责启"
"动Hibernate和更方便地操作<literal>SessionFactory</literal>。让我们来看一下它"
"的实现："

#. Tag: programlisting
#: tutorial.xml:352
#, no-c-format
msgid ""
"<![CDATA[package util;\n"
"\n"
"import org.hibernate.*;\n"
"import org.hibernate.cfg.*;\n"
"\n"
"public class HibernateUtil {\n"
"\n"
"    private static final SessionFactory sessionFactory;\n"
"\n"
"    static {\n"
"        try {\n"
"            // Create the SessionFactory from hibernate.cfg.xml\n"
"            sessionFactory = new Configuration().configure()."
"buildSessionFactory();\n"
"        } catch (Throwable ex) {\n"
"            // Make sure you log the exception, as it might be swallowed\n"
"            System.err.println(\"Initial SessionFactory creation failed.\" + "
"ex);\n"
"            throw new ExceptionInInitializerError(ex);\n"
"        }\n"
"    }\n"
"\n"
"    public static SessionFactory getSessionFactory() {\n"
"        return sessionFactory;\n"
"    }\n"
"\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:354
#, no-c-format
msgid ""
"This class does not only produce the global <literal>SessionFactory</"
"literal> in its static initializer (called once by the JVM when the class is "
"loaded), but also hides the fact that it uses a static singleton. It might "
"as well lookup the <literal>SessionFactory</literal> from JNDI in an "
"application server."
msgstr ""
"这个类不但在它的静态初始化过程（仅当加载这个类的时候被JVM执行一次）中产生全局"
"的<literal>SessionFactory</literal>，而且隐藏了它使用了静态singleton的事实。"
"它也可能在应用程序服务器中的JNDI查找<literal>SessionFactory</literal>。"

#. Tag: para
#: tutorial.xml:361
#, no-c-format
msgid ""
"If you give the <literal>SessionFactory</literal> a name in your "
"configuration file, Hibernate will in fact try to bind it to JNDI after it "
"has been built. To avoid this code completely you could also use JMX "
"deployment and let the JMX-capable container instantiate and bind a "
"<literal>HibernateService</literal> to JNDI. These advanced options are "
"discussed in the Hibernate reference documentation."
msgstr ""
"如果你在配置文件中给<literal>SessionFactory</literal>一个名字，在"
"<literal>SessionFactory</literal>创建后，Hibernate会试着把它绑定到JNDI。要完"
"全避免这样的代码，你也可以使用JMX部署，让具有JMX能力的容器来实例化"
"<literal>HibernateService</literal>并把它绑定到JNDI。这些高级可选项在后面的章"
"节中会讨论到。"

#. Tag: para
#: tutorial.xml:370
#, no-c-format
msgid ""
"Place <literal>HibernateUtil.java</literal> in the development source "
"directory, in a package next to <literal>events</literal>:"
msgstr ""
"把<literal>HibernateUtil.java</literal>放在开发目录的源代码路径下，与放"
"<literal>events</literal>的包并列："

#. Tag: programlisting
#: tutorial.xml:375
#, no-c-format
msgid ""
"<![CDATA[.\n"
"+lib\n"
"  <Hibernate and third-party libraries>\n"
"+src\n"
"  +events\n"
"    Event.java\n"
"    Event.hbm.xml\n"
"  +util\n"
"    HibernateUtil.java\n"
"  hibernate.cfg.xml\n"
"+data\n"
"build.xml]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:377
#, no-c-format
msgid ""
"This should again compile without problems. We finally need to configure a "
"logging system - Hibernate uses commons logging and leaves you the choice "
"between Log4j and JDK 1.4 logging. Most developers prefer Log4j: copy "
"<literal>log4j.properties</literal> from the Hibernate distribution (it's in "
"the <literal>etc/</literal> directory) to your <literal>src</literal> "
"directory, next to <literal>hibernate.cfg.xml</literal>. Have a look at the "
"example configuration and change the settings if you like to have more "
"verbose output. By default, only Hibernate startup message are shown on "
"stdout."
msgstr ""
"再次编译这个应用程序应该不会有问题。最后我们需要配置一个日志（logging)系统 "
"－ Hibernate使用通用日志接口，允许你在Log4j和JDK 1.4 日志之间进行选择。多数开"
"发者更喜欢Log4j：从Hibernate的发布包中（它在<literal>etc/</literal>目录下）拷"
"贝<literal>log4j.properties</literal>到你的<literal>src</literal>目录，与"
"<literal>hibernate.cfg.xml</literal>.放在一起。看一下配置示例，如果你希望看到"
"更加详细的输出信息，你可以修改配置。默认情况下，只有Hibernate的启动信息才会显"
"示在标准输出上。"

#. Tag: para
#: tutorial.xml:387
#, no-c-format
msgid ""
"The tutorial infrastructure is complete - and we are ready to do some real "
"work with Hibernate."
msgstr "示例的基本框架完成了 － 现在我们可以用Hibernate来做些真正的工作。"

#. Tag: title
#: tutorial.xml:395
#, no-c-format
msgid "Loading and storing objects"
msgstr "加载并存储对象"

#. Tag: para
#: tutorial.xml:397
#, no-c-format
msgid ""
"Finally, we can use Hibernate to load and store objects. We write an "
"<literal>EventManager</literal> class with a <literal>main()</literal> "
"method:"
msgstr ""
"我们终于可以使用Hibernate来加载和存储对象了，编写一个带有<literal>main()</"
"literal>方法的<literal>EventManager</literal>类："

#. Tag: programlisting
#: tutorial.xml:402
#, no-c-format
msgid ""
"<![CDATA[package events;\n"
"import org.hibernate.Session;\n"
"\n"
"import java.util.Date;\n"
"\n"
"import util.HibernateUtil;\n"
"\n"
"public class EventManager {\n"
"\n"
"    public static void main(String[] args) {\n"
"        EventManager mgr = new EventManager();\n"
"\n"
"        if (args[0].equals(\"store\")) {\n"
"            mgr.createAndStoreEvent(\"My Event\", new Date());\n"
"        }\n"
"\n"
"        HibernateUtil.getSessionFactory().close();\n"
"    }\n"
"\n"
"    private void createAndStoreEvent(String title, Date theDate) {\n"
"\n"
"        Session session = HibernateUtil.getSessionFactory().getCurrentSession"
"();\n"
"\n"
"        session.beginTransaction();\n"
"\n"
"        Event theEvent = new Event();\n"
"        theEvent.setTitle(title);\n"
"        theEvent.setDate(theDate);\n"
"\n"
"        session.save(theEvent);\n"
"\n"
"        session.getTransaction().commit();\n"
"    }\n"
"\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:404
#, no-c-format
msgid ""
"We create a new <literal>Event</literal> object, and hand it over to "
"Hibernate. Hibernate now takes care of the SQL and executes <literal>INSERT</"
"literal>s on the database. Let's have a look at the <literal>Session</"
"literal> and <literal>Transaction</literal>-handling code before we run this."
msgstr ""
"我们创建了个新的<literal>Event</literal>对象并把它传递给Hibernate。现在"
"Hibernate负责与SQL打交道，并把<literal>INSERT</literal>命令传给数据库。在运行"
"之前，让我们看一下处理<literal>Session</literal>和<literal>Transaction</"
"literal>的代码。"

#. Tag: para
#: tutorial.xml:411
#, no-c-format
msgid ""
"A <literal>Session</literal> is a single unit of work. For now we'll keep "
"things simple and assume a one-to-one granularity between a Hibernate "
"<literal>Session</literal> and a database transaction. To shield our code "
"from the actual underlying transaction system (in this case plain JDBC, but "
"it could also run with JTA) we use the <literal>Transaction</literal> API "
"that is available on the Hibernate <literal>Session</literal>."
msgstr ""
"一个<literal>Session</literal>就是个单一的工作单元。我们暂时让事情简单一些，"
"并假设Hibernate<literal>Session</literal>和数据库事务是一一对应的。为了让我们"
"的代码从底层的事务系统中脱离出来（此例中是JDBC，但也可能是JTA），我们使用"
"Hibernate <literal>Session</literal>中的<literal>Transaction</literal> API。"

#. Tag: para
#: tutorial.xml:419
#, no-c-format
msgid ""
"What does <literal>sessionFactory.getCurrentSession()</literal> do? First, "
"you can call it as many times and anywhere you like, once you get hold of "
"your <literal>SessionFactory</literal> (easy thanks to "
"<literal>HibernateUtil</literal>). The <literal>getCurrentSession()</"
"literal> method always returns the \"current\" unit of work. Remember that "
"we switched the configuration option for this mechanism to \"thread\" in "
"<literal>hibernate.cfg.xml</literal>? Hence, the current unit of work is "
"bound to the current Java thread that executes our application. However, "
"this is not the full picture, you also have to consider scope, when a unit "
"of work begins and when it ends."
msgstr ""
"<literal>sessionFactory.getCurrentSession()</literal>是干什么的呢？首先，只要"
"你持有<literal>SessionFactory</literal>（幸亏我们有<literal>HibernateUtil</"
"literal>，可以随时获得），大可在任何时候、任何地点调用这个方法。"
"<literal>getCurrentSession()</literal>方法总会返回“当前的”工作单元。记得我们"
"在<literal>hibernate.cfg.xml</literal>中把这一配置选项调整为\"thread\"了吗？"
"因此，因此，当前工作单元被绑定到当前执行我们应用程序的Java线程。但是，这并非"
"是完全准确的,你还得考虑工作单元的生命周期范围 (scope),它何时开始,又何时结束."

#. Tag: para
#: tutorial.xml:430
#, no-c-format
msgid ""
"A <literal>Session</literal> begins when it is first needed, when the first "
"call to <literal>getCurrentSession()</literal> is made. It is then bound by "
"Hibernate to the current thread. When the transaction ends, either through "
"commit or rollback, Hibernate automatically unbinds the <literal>Session</"
"literal> from the thread and closes it for you. If you call "
"<literal>getCurrentSession()</literal> again, you get a new "
"<literal>Session</literal> and can start a new unit of work. This "
"<emphasis>thread-bound</emphasis> programming model is the most popular way "
"of using Hibernate, as it allows flexible layering of your code (transaction "
"demarcation code can be separated from data access code, we'll do this later "
"in this tutorial)."
msgstr ""
"<literal>Session</literal>在第一次被使用的时候,即第一次调用"
"<literal>getCurrentSession()</literal>的时候,其生命周期就开始。然后它被"
"Hibernate绑定到当前线程。当事务结束的时候，不管是提交还是回滚，Hibernate会自"
"动把<literal>Session</literal>从当前线程剥离，并且关闭它。假若你再次调用"
"<literal>getCurrentSession()</literal>，你会得到一个新的<literal>Session</"
"literal>，并且开始一个新的工作单元。这种<emphasis>线程绑定(thread-bound)</"
"emphasis>的编程模型（model）是使用Hibernate的最广泛的方式,因为它支持对你的代"
"码灵活分层(事务划分可以和你的数据访问代码分离开来,在本教程的后面部分就会这么"
"做)。"

#. Tag: para
#: tutorial.xml:441
#, no-c-format
msgid ""
"Related to the unit of work scope, should the Hibernate <literal>Session</"
"literal> be used to execute one or several database operations? The above "
"example uses one <literal>Session</literal> for one operation. This is pure "
"coincidence, the example is just not complex enough to show any other "
"approach. The scope of a Hibernate <literal>Session</literal> is flexible "
"but you should never design your application to use a new Hibernate "
"<literal>Session</literal> for <emphasis>every</emphasis> database "
"operation. So even if you see it a few more times in the following (very "
"trivial) examples, consider <emphasis>session-per-operation</emphasis> an "
"anti-pattern. A real (web) application is shown later in this tutorial."
msgstr ""
"和工作单元的生命周期这个话题相关，Hibernate <literal>Session</literal>是否被"
"应该用来执行多次数据库操作？上面的例子对每一次操作使用了一个"
"<literal>Session</literal>，这完全是巧合，这个例子不是很复杂，无法展示其他方"
"式。Hibernate <literal>Session</literal>的生命周期可以很灵活，但是你绝不要把"
"你的应用程序设计成为<emphasis>每一次</emphasis>数据库操作都用一个新的"
"Hibernate <literal>Session</literal>。因此就算下面的例子（它们都很简单）中你"
"可以看到这种用法，记住<emphasis>每次操作一个session</emphasis>是一个反模式。"
"在本教程的后面会展示一个真正的(web)程序。"

#. Tag: para
#: tutorial.xml:452
#, no-c-format
msgid ""
"Have a look at <xref linkend=\"transactions\"/> for more information about "
"transaction handling and demarcation. We also skipped any error handling and "
"rollback in the previous example."
msgstr ""
"关于事务处理及事务边界界定的详细信息，请参看<xref linkend=\"transactions\"/"
">。在上面的例子中，我们也忽略了所有的错误与回滚的处理。"

#. Tag: para
#: tutorial.xml:458
#, no-c-format
msgid ""
"To run this first routine we have to add a callable target to the Ant build "
"file:"
msgstr ""
"为第一次运行我们的程序，我们得在Ant的build文件中增加一个可以调用得到的"
"target。"

#. Tag: programlisting
#: tutorial.xml:462
#, no-c-format
msgid ""
"<![CDATA[<target name=\"run\" depends=\"compile\">\n"
"    <java fork=\"true\" classname=\"events.EventManager\" classpathref="
"\"libraries\">\n"
"        <classpath path=\"${targetdir}\"/>\n"
"        <arg value=\"${action}\"/>\n"
"    </java>\n"
"</target>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:464
#, no-c-format
msgid ""
"The value of the <literal>action</literal> argument is set on the command "
"line when calling the target:"
msgstr ""
"<literal>action</literal>参数（argument）的值是通过命令行调用这个target的时候"
"设置的："

#. Tag: programlisting
#: tutorial.xml:469
#, no-c-format
msgid "<![CDATA[C:\\hibernateTutorial\\>ant run -Daction=store]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:471
#, no-c-format
msgid ""
"You should see, after compilation, Hibernate starting up and, depending on "
"your configuration, lots of log output. At the end you will find the "
"following line:"
msgstr ""
"你应该会看到，编译以后，Hibernate根据你的配置启动，并产生一大堆的输出日志。在"
"日志最后你会看到下面这行："

#. Tag: programlisting
#: tutorial.xml:476
#, no-c-format
msgid ""
"<![CDATA[[java] Hibernate: insert into EVENTS (EVENT_DATE, title, EVENT_ID) "
"values (?, ?, ?)]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:478
#, no-c-format
msgid ""
"This is the <literal>INSERT</literal> executed by Hibernate, the question "
"marks represent JDBC bind parameters. To see the values bound as arguments, "
"or to reduce the verbosity of the log, check your <literal>log4j.properties</"
"literal>."
msgstr ""
"这是Hibernate执行的<literal>INSERT</literal>命令，问号代表JDBC的绑定参数。如"
"果想要看到绑定参数的值或者减少日志的长度，就要调整你在<literal>log4j."
"properties</literal>文件里的设置。"

#. Tag: para
#: tutorial.xml:484
#, no-c-format
msgid ""
"Now we'd like to list stored events as well, so we add an option to the main "
"method:"
msgstr ""
"我们想要列出所有已经被存储的events，就要增加一个条件分支选项到main方法中去。"

#. Tag: programlisting
#: tutorial.xml:488
#, no-c-format
msgid ""
"<![CDATA[if (args[0].equals(\"store\")) {\n"
"    mgr.createAndStoreEvent(\"My Event\", new Date());\n"
"}\n"
"else if (args[0].equals(\"list\")) {\n"
"    List events = mgr.listEvents();\n"
"    for (int i = 0; i < events.size(); i++) {\n"
"        Event theEvent = (Event) events.get(i);\n"
"        System.out.println(\"Event: \" + theEvent.getTitle() +\n"
"                           \" Time: \" + theEvent.getDate());\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:490
#, no-c-format
msgid "We also add a new <literal>listEvents() method</literal>:"
msgstr "我们也增加一个新的<literal>listEvents()</literal>方法:"

#. Tag: programlisting
#: tutorial.xml:494
#, no-c-format
msgid ""
"<![CDATA[private List listEvents() {\n"
"\n"
"    Session session = HibernateUtil.getSessionFactory().getCurrentSession"
"();\n"
"\n"
"    session.beginTransaction();\n"
"\n"
"    List result = session.createQuery(\"from Event\").list();\n"
"\n"
"    session.getTransaction().commit();\n"
"\n"
"    return result;\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:496
#, no-c-format
msgid ""
"What we do here is use an HQL (Hibernate Query Language) query to load all "
"existing <literal>Event</literal> objects from the database. Hibernate will "
"generate the appropriate SQL, send it to the database and populate "
"<literal>Event</literal> objects with the data. You can create more complex "
"queries with HQL, of course."
msgstr ""
"我们在这里是用一个HQL（Hibernate Query Language－Hibernate查询语言）查询语句"
"来从数据库中加载所有存在的<literal>Event</literal>对象。Hibernate会生成适当的"
"SQL，把它发送到数据库，并操作从查询得到数据的<literal>Event</literal>对象。当"
"然，你可以使用HQL来创建更加复杂的查询。"

#. Tag: para
#: tutorial.xml:503
#, no-c-format
msgid "Now, to execute and test all of this, follow these steps:"
msgstr "现在，根据以下步骤来执行并测试以上各项："

#. Tag: para
#: tutorial.xml:509
#, no-c-format
msgid ""
"Run <literal>ant run -Daction=store</literal> to store something into the "
"database and, of course, to generate the database schema before through "
"hbm2ddl."
msgstr ""
"运行<literal>ant run -Daction=store</literal>来保存一些内容到数据库。当然，先"
"得用hbm2ddl来生成数据库schema。"

#. Tag: para
#: tutorial.xml:515
#, no-c-format
msgid ""
"Now disable hbm2ddl by commenting out the property in your "
"<literal>hibernate.cfg.xml</literal> file. Usually you only leave it turned "
"on in continous unit testing, but another run of hbm2ddl would "
"<emphasis>drop</emphasis> everything you have stored - the <literal>create</"
"literal> configuration setting actually translates into \"drop all tables "
"from the schema, then re-create all tables, when the SessionFactory is build"
"\"."
msgstr ""
"现在把<literal>hibernate.cfg.xml</literal>文件中hbm2ddl属性注释掉，这样我们就"
"取消了在启动时用hbm2ddl来生成数据库schema。通常只有在不断重复进行单元测试的时"
"候才需要打开它，但再次运行hbm2ddl会把你保存的一切都删掉（<emphasis>drop</"
"emphasis>）——<literal>create</literal>配置的真实含义是：“在创建SessionFactory"
"的时候，从schema 中drop 掉所有的表，再重新创建它们”。"

#. Tag: para
#: tutorial.xml:525
#, no-c-format
msgid ""
"If you now call Ant with <literal>-Daction=list</literal>, you should see "
"the events you have stored so far. You can of course also call the "
"<literal>store</literal> action a few times more."
msgstr ""
"如果你现在使用命令行参数<literal>-Daction=list</literal>运行Ant，你会看到那些"
"至今为止我们所储存的events。当然，你也可以多调用几次<literal>store</literal>"
"以保存更多的envents。"

#. Tag: para
#: tutorial.xml:531
#, no-c-format
msgid ""
"Note: Most new Hibernate users fail at this point and we see questions about "
"<emphasis>Table not found</emphasis> error messages regularly. However, if "
"you follow the steps outlined above you will not have this problem, as "
"hbm2ddl creates the database schema on the first run, and subsequent "
"application restarts will use this schema. If you change the mapping and/or "
"database schema, you have to re-enable hbm2ddl once again."
msgstr ""
"注意，很多Hibernate新手在这一步会失败，我们不时看到关于<emphasis>Table not "
"found</emphasis>错误信息的提问。但是，只要你根据上面描述的步骤来执行，就不会"
"有这个问题，因为hbm2ddl会在第一次运行的时候创建数据库schema，后继的应用程序重"
"起后还能继续使用这个schema。假若你修改了映射，或者修改了数据库schema，你必须"
"把hbm2ddl重新打开一次。"

#. Tag: title
#: tutorial.xml:544
#, no-c-format
msgid "Part 2 - Mapping associations"
msgstr "第二部分 － 关联映射"

#. Tag: para
#: tutorial.xml:546
#, no-c-format
msgid ""
"We mapped a persistent entity class to a table. Let's build on this and add "
"some class associations. First we'll add people to our application, and "
"store a list of events they participate in."
msgstr ""
"我们已经映射了一个持久化实体类到表上。让我们在这个基础上增加一些类之间的关"
"联。首先我们往应用程序里增加人（people）的概念，并存储他们所参与的一个Event列"
"表。（译者注：与Event一样，我们在后面将直接使用person来表示“人”而不是它的中文"
"翻译）"

#. Tag: title
#: tutorial.xml:552
#, no-c-format
msgid "Mapping the Person class"
msgstr "映射Person类"

#. Tag: para
#: tutorial.xml:554
#, no-c-format
msgid "The first cut of the <literal>Person</literal> class is simple:"
msgstr "最初简单的<literal>Person</literal>类："

#. Tag: programlisting
#: tutorial.xml:558
#, no-c-format
msgid ""
"<![CDATA[package events;\n"
"\n"
"public class Person {\n"
"\n"
"    private Long id;\n"
"    private int age;\n"
"    private String firstname;\n"
"    private String lastname;\n"
"\n"
"    public Person() {}\n"
"\n"
"    // Accessor methods for all properties, private setter for 'id'\n"
"\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:560
#, no-c-format
msgid ""
"Create a new mapping file called <literal>Person.hbm.xml</literal> (don't "
"forget the DTD reference at the top):"
msgstr ""
"创建一个名为<literal>Person.hbm.xml</literal>的新映射文件（别忘了最上面的DTD"
"引用）："

#. Tag: programlisting
#: tutorial.xml:565
#, no-c-format
msgid ""
"<![CDATA[<hibernate-mapping>\n"
"\n"
"    <class name=\"events.Person\" table=\"PERSON\">\n"
"        <id name=\"id\" column=\"PERSON_ID\">\n"
"            <generator class=\"native\"/>\n"
"        </id>\n"
"        <property name=\"age\"/>\n"
"        <property name=\"firstname\"/>\n"
"        <property name=\"lastname\"/>\n"
"    </class>\n"
"\n"
"</hibernate-mapping>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:567
#, no-c-format
msgid "Finally, add the new mapping to Hibernate's configuration:"
msgstr "最后，把新的映射加入到Hibernate的配置中："

#. Tag: programlisting
#: tutorial.xml:571
#, no-c-format
msgid ""
"<![CDATA[<mapping resource=\"events/Event.hbm.xml\"/>\n"
"<mapping resource=\"events/Person.hbm.xml\"/>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:573
#, no-c-format
msgid ""
"We'll now create an association between these two entities. Obviously, "
"persons can participate in events, and events have participants. The design "
"questions we have to deal with are: directionality, multiplicity, and "
"collection behavior."
msgstr ""
"现在我们在这两个实体之间创建一个关联。显然，persons可以参与一系列events，而"
"events也有不同的参加者（persons）。我们需要处理的设计问题是关联方向"
"（directionality），阶数（multiplicity）和集合（collection）的行为。"

#. Tag: title
#: tutorial.xml:583
#, no-c-format
msgid "A unidirectional Set-based association"
msgstr "单向Set-based的关联"

#. Tag: para
#: tutorial.xml:585
#, no-c-format
msgid ""
"We'll add a collection of events to the <literal>Person</literal> class. "
"That way we can easily navigate to the events for a particular person, "
"without executing an explicit query - by calling <literal>aPerson.getEvents()"
"</literal>. We use a Java collection, a <literal>Set</literal>, because the "
"collection will not contain duplicate elements and the ordering is not "
"relevant for us."
msgstr ""
"我们将向<literal>Person</literal>类增加一连串的events。那样，通过调用"
"<literal>aPerson.getEvents()</literal>，就可以轻松地导航到特定person所参与的"
"events，而不用去执行一个显式的查询。我们使用Java的集合类（collection）："
"<literal>Set</literal>，因为set 不包含重复的元素及与我们无关的排序。"

#. Tag: para
#: tutorial.xml:592
#, no-c-format
msgid ""
"We need a unidirectional, many-valued associations, implemented with a "
"<literal>Set</literal>. Let's write the code for this in the Java classes "
"and then map it:"
msgstr ""
"我们需要用set 实现一个单向多值关联。让我们在Java类里为这个关联编码，接着映射"
"它："

#. Tag: programlisting
#: tutorial.xml:597
#, no-c-format
msgid ""
"<![CDATA[public class Person {\n"
"\n"
"    private Set events = new HashSet();\n"
"\n"
"    public Set getEvents() {\n"
"        return events;\n"
"    }\n"
"\n"
"    public void setEvents(Set events) {\n"
"        this.events = events;\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:599
#, no-c-format
msgid ""
"Before we map this association, think about the other side. Clearly, we "
"could just keep this unidirectional. Or, we could create another collection "
"on the <literal>Event</literal>, if we want to be able to navigate it bi-"
"directional, i.e. <literal>anEvent.getParticipants()</literal>. This is not "
"necessary, from a functional perspective. You could always execute an "
"explicit query to retrieve the participants for a particular event. This is "
"a design choice left to you, but what is clear from this discussion is the "
"multiplicity of the association: \"many\" valued on both sides, we call this "
"a <emphasis>many-to-many</emphasis> association. Hence, we use Hibernate's "
"many-to-many mapping:"
msgstr ""
"在映射这个关联之前，先考虑一下此关联的另外一端。很显然，我们可以保持这个关联"
"是单向的。或者，我们可以在<literal>Event</literal>里创建另外一个集合，如果希"
"望能够双向地导航，如：<literal>anEvent.getParticipants()</literal>。从功能的"
"角度来说，这并不是必须的。因为你总可以显式地执行一个查询，以获得某个特定event"
"的所有参与者。这是个在设计时需要做出的选择，完全由你来决定，但此讨论中关于关"
"联的阶数是清楚的：即两端都是“多”值的，我们把它叫做<emphasis>多对多(many-to-"
"many)</emphasis>关联。因而，我们使用Hibernate的多对多映射："

#. Tag: programlisting
#: tutorial.xml:610
#, no-c-format
msgid ""
"<![CDATA[<class name=\"events.Person\" table=\"PERSON\">\n"
"    <id name=\"id\" column=\"PERSON_ID\">\n"
"        <generator class=\"native\"/>\n"
"    </id>\n"
"    <property name=\"age\"/>\n"
"    <property name=\"firstname\"/>\n"
"    <property name=\"lastname\"/>\n"
"\n"
"    <set name=\"events\" table=\"PERSON_EVENT\">\n"
"        <key column=\"PERSON_ID\"/>\n"
"        <many-to-many column=\"EVENT_ID\" class=\"events.Event\"/>\n"
"    </set>\n"
"\n"
"</class>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:612
#, no-c-format
msgid ""
"Hibernate supports all kinds of collection mappings, a <literal>&lt;set&gt;</"
"literal> being most common. For a many-to-many association (or <emphasis>n:"
"m</emphasis> entity relationship), an association table is needed. Each row "
"in this table represents a link between a person and an event. The table "
"name is configured with the <literal>table</literal> attribute of the "
"<literal>set</literal> element. The identifier column name in the "
"association, for the person's side, is defined with the <literal>&lt;key&gt;"
"</literal> element, the column name for the event's side with the "
"<literal>column</literal> attribute of the <literal>&lt;many-to-many&gt;</"
"literal>. You also have to tell Hibernate the class of the objects in your "
"collection (correct: the class on the other side of the collection of "
"references)."
msgstr ""
"Hibernate支持各种各样的集合映射，<literal>&lt;set&gt;</literal>使用的最为普"
"遍。对于多对多关联（或叫<emphasis>n:m</emphasis>实体关系）, 需要一个关联表"
"（association table）。<literal>表</literal>里面的每一行代表从person到event的"
"一个关联。表名是由<literal>set</literal>元素的<literal>table</literal>属性配"
"置的。关联里面的标识符字段名，对于person的一端，是由<literal>&lt;key&gt;</"
"literal>元素定义，而event一端的字段名是由<literal>&lt;many-to-many&gt;</"
"literal>元素的<literal>column</literal>属性定义。你也必须告诉Hibernate集合中"
"对象的类（也就是位于这个集合所代表的关联另外一端的类）。"

#. Tag: para
#: tutorial.xml:624
#, no-c-format
msgid "The database schema for this mapping is therefore:"
msgstr "因而这个映射的数据库schema是："

#. Tag: programlisting
#: tutorial.xml:628
#, no-c-format
msgid ""
"<![CDATA[\n"
"    _____________        __________________\n"
"   |             |      |                  |       _____________\n"
"   |   EVENTS    |      |   PERSON_EVENT   |      |             |\n"
"   |_____________|      |__________________|      |    PERSON   |\n"
"   |             |      |                  |      |_____________|\n"
"   | *EVENT_ID   | <--> | *EVENT_ID        |      |             |\n"
"   |  EVENT_DATE |      | *PERSON_ID       | <--> | *PERSON_ID  |\n"
"   |  TITLE      |      |__________________|      |  AGE        |\n"
"   |_____________|                                |  FIRSTNAME  |\n"
"                                                  |  LASTNAME   |\n"
"                                                  |_____________|\n"
" ]]>"
msgstr ""

#. Tag: title
#: tutorial.xml:633
#, no-c-format
msgid "Working the association"
msgstr "使关联工作"

#. Tag: para
#: tutorial.xml:635
#, no-c-format
msgid ""
"Let's bring some people and events together in a new method in "
"<literal>EventManager</literal>:"
msgstr ""
"我们把一些people和events 一起放到<literal>EventManager</literal>的新方法中："

#. Tag: programlisting
#: tutorial.xml:639
#, no-c-format
msgid ""
"<![CDATA[private void addPersonToEvent(Long personId, Long eventId) {\n"
"\n"
"    Session session = HibernateUtil.getSessionFactory().getCurrentSession"
"();\n"
"    session.beginTransaction();\n"
"\n"
"    Person aPerson = (Person) session.load(Person.class, personId);\n"
"    Event anEvent = (Event) session.load(Event.class, eventId);\n"
"\n"
"    aPerson.getEvents().add(anEvent);\n"
"\n"
"    session.getTransaction().commit();\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:641
#, no-c-format
msgid ""
"After loading a <literal>Person</literal> and an <literal>Event</literal>, "
"simply modify the collection using the normal collection methods. As you can "
"see, there is no explicit call to <literal>update()</literal> or "
"<literal>save()</literal>, Hibernate automatically detects that the "
"collection has been modified and needs to be updated. This is called "
"<emphasis>automatic dirty checking</emphasis>, and you can also try it by "
"modifying the name or the date property of any of your objects. As long as "
"they are in <emphasis>persistent</emphasis> state, that is, bound to a "
"particular Hibernate <literal>Session</literal> (i.e. they have been just "
"loaded or saved in a unit of work), Hibernate monitors any changes and "
"executes SQL in a write-behind fashion. The process of synchronizing the "
"memory state with the database, usually only at the end of a unit of work, "
"is called <emphasis>flushing</emphasis>. In our code, the unit of work ends "
"with a commit (or rollback) of the database transaction - as defined by the "
"<literal>thread</literal> configuration option for the "
"<literal>CurrentSessionContext</literal> class."
msgstr ""
"在加载一<literal>Person</literal>和<literal>Event</literal>后，使用普通的集合"
"方法就可容易地修改我们定义的集合。如你所见，没有显式的<literal>update()</"
"literal>或<literal>save()</literal>，Hibernate会自动检测到集合已经被修改并需"
"要更新回数据库。这叫做自动脏检查（<emphasis>automatic dirty checking</"
"emphasis>），你也可以尝试修改任何对象的name或者date属性，只要他们处于"
"<emphasis>持久化</emphasis>状态，也就是被绑定到某个Hibernate 的"
"<literal>Session</literal>上（如：他们刚刚在一个单元操作被加载或者保存），"
"Hibernate监视任何改变并在后台隐式写的方式执行SQL。同步内存状态和数据库的过"
"程，通常只在单元操作结束的时候发生，称此过程为清理缓存<emphasis>（flushing）"
"</emphasis>。在我们的代码中，工作单元由数据库事务的提交（或者回滚）来结束——这"
"是由<literal>CurrentSessionContext</literal>类的<literal>thread</literal>配置"
"选项定义的。"

#. Tag: para
#: tutorial.xml:656
#, no-c-format
msgid ""
"You might of course load person and event in different units of work. Or you "
"modify an object outside of a <literal>Session</literal>, when it is not in "
"persistent state (if it was persistent before, we call this state "
"<emphasis>detached</emphasis>). You can even modify a collection when it is "
"detached:"
msgstr ""
"当然，你也可以在不同的单元操作里面加载person和event。或在<literal>Session</"
"literal>以外修改不是处在持久化（persistent）状态下的对象（如果该对象以前曾经"
"被持久化，那么我们称这个状态为<emphasis>脱管（detached）</emphasis>）。你甚至"
"可以在一个集合被脱管时修改它："

#. Tag: programlisting
#: tutorial.xml:663
#, no-c-format
msgid ""
"<![CDATA[private void addPersonToEvent(Long personId, Long eventId) {\n"
"\n"
"    Session session = HibernateUtil.getSessionFactory().getCurrentSession"
"();\n"
"    session.beginTransaction();\n"
"\n"
"    Person aPerson = (Person) session\n"
"            .createQuery(\"select p from Person p left join fetch p.events "
"where p.id = :pid\")\n"
"            .setParameter(\"pid\", personId)\n"
"            .uniqueResult(); // Eager fetch the collection so we can use it "
"detached\n"
"\n"
"    Event anEvent = (Event) session.load(Event.class, eventId);\n"
"\n"
"    session.getTransaction().commit();\n"
"\n"
"    // End of first unit of work\n"
"\n"
"    aPerson.getEvents().add(anEvent); // aPerson (and its collection) is "
"detached\n"
"\n"
"    // Begin second unit of work\n"
"\n"
"    Session session2 = HibernateUtil.getSessionFactory().getCurrentSession"
"();\n"
"    session2.beginTransaction();\n"
"\n"
"    session2.update(aPerson); // Reattachment of aPerson\n"
"\n"
"    session2.getTransaction().commit();\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:665
#, no-c-format
msgid ""
"The call to <literal>update</literal> makes a detached object persistent "
"again, you could say it binds it to a new unit of work, so any modifications "
"you made to it while detached can be saved to the database. This includes "
"any modifications (additions/deletions) you made to a collection of that "
"entity object."
msgstr ""
"对<literal>update</literal>的调用使一个脱管对象重新持久化，你可以说它被绑定到"
"一个新的单元操作上，所以在脱管状态下对它所做的任何修改都会被保存到数据库里。"
"这也包括你对这个实体对象的集合所作的任何改动（增加/删除）。"

#. Tag: para
#: tutorial.xml:672
#, no-c-format
msgid ""
"Well, this is not much use in our current situation, but it's an important "
"concept you can design into your own application. For now, complete this "
"exercise by adding a new action to the <literal>EventManager</literal>'s "
"main method and call it from the command line. If you need the identifiers "
"of a person and an event - the <literal>save()</literal> method returns it "
"(you might have to modify some of the previous methods to return that "
"identifier):"
msgstr ""
"这对我们当前的情形不是很有用，但它是非常重要的概念，你可以把它融入到你自己的"
"应用程序设计中。在<literal>EventManager</literal>的main方法中添加一个新的动"
"作，并从命令行运行它来完成我们所做的练习。如果你需要person及event的标识符 — "
"那就用<literal>save()</literal>方法返回它（你可能需要修改前面的一些方法来返回"
"那个标识符）："

#. Tag: programlisting
#: tutorial.xml:680
#, no-c-format
msgid ""
"<![CDATA[else if (args[0].equals(\"addpersontoevent\")) {\n"
"    Long eventId = mgr.createAndStoreEvent(\"My Event\", new Date());\n"
"    Long personId = mgr.createAndStorePerson(\"Foo\", \"Bar\");\n"
"    mgr.addPersonToEvent(personId, eventId);\n"
"    System.out.println(\"Added person \" + personId + \" to event \" + "
"eventId);\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:682
#, no-c-format
msgid ""
"This was an example of an association between two equally important classes, "
"two entities. As mentioned earlier, there are other classes and types in a "
"typical model, usually \"less important\". Some you have already seen, like "
"an <literal>int</literal> or a <literal>String</literal>. We call these "
"classes <emphasis>value types</emphasis>, and their instances "
"<emphasis>depend</emphasis> on a particular entity. Instances of these types "
"don't have their own identity, nor are they shared between entities (two "
"persons don't reference the same <literal>firstname</literal> object, even "
"if they have the same first name). Of course, value types can not only be "
"found in the JDK (in fact, in a Hibernate application all JDK classes are "
"considered value types), but you can also write dependent classes yourself, "
"<literal>Address</literal> or <literal>MonetaryAmount</literal>, for example."
msgstr ""
"上面是个关于两个同等重要的实体类间关联的例子。像前面所提到的那样，在特定的模"
"型中也存在其它的类和类型，这些类和类型通常是“次要的”。你已看到过其中的一些，"
"像<literal>int</literal>或<literal>String</literal>。我们称这些类为<emphasis>"
"值类型（value type）</emphasis>，它们的实例<emphasis>依赖（depend）</"
"emphasis>在某个特定的实体上。这些类型的实例没有它们自己的标识（identity），也"
"不能在实体间被共享（比如，两个person不能引用同一个<literal>firstname</"
"literal>对象，即使他们有相同的first name）。当然，值类型并不仅仅在JDK中存在"
"（事实上，在一个Hibernate应用程序中，所有的JDK类都被视为值类型），而且你也可"
"以编写你自己的依赖类，例如<literal>Address</literal>，"
"<literal>MonetaryAmount</literal>。"

#. Tag: para
#: tutorial.xml:695
#, no-c-format
msgid ""
"You can also design a collection of value types. This is conceptually very "
"different from a collection of references to other entities, but looks "
"almost the same in Java."
msgstr ""
"你也可以设计一个值类型的集合，这在概念上与引用其它实体的集合有很大的不同，但"
"是在Java里面看起来几乎是一样的。"

#. Tag: title
#: tutorial.xml:703
#, no-c-format
msgid "Collection of values"
msgstr "值类型的集合"

#. Tag: para
#: tutorial.xml:705
#, no-c-format
msgid ""
"We add a collection of value typed objects to the <literal>Person</literal> "
"entity. We want to store email addresses, so the type we use is "
"<literal>String</literal>, and the collection is again a <literal>Set</"
"literal>:"
msgstr ""
"我们把一个值类型对象的集合加入<literal>Person</literal>实体中。我们希望保存"
"email地址，所以使用<literal>String</literal>类型，而且这次的集合类型又是"
"<literal>Set</literal>："

#. Tag: programlisting
#: tutorial.xml:710
#, no-c-format
msgid ""
"<![CDATA[private Set emailAddresses = new HashSet();\n"
"\n"
"public Set getEmailAddresses() {\n"
"    return emailAddresses;\n"
"}\n"
"\n"
"public void setEmailAddresses(Set emailAddresses) {\n"
"    this.emailAddresses = emailAddresses;\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:712
#, no-c-format
msgid "The mapping of this <literal>Set</literal>:"
msgstr "这个<literal>Set</literal>的映射"

#. Tag: programlisting
#: tutorial.xml:716
#, no-c-format
msgid ""
"<![CDATA[<set name=\"emailAddresses\" table=\"PERSON_EMAIL_ADDR\">\n"
"    <key column=\"PERSON_ID\"/>\n"
"    <element type=\"string\" column=\"EMAIL_ADDR\"/>\n"
"</set>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:718
#, no-c-format
msgid ""
"The difference compared with the earlier mapping is the <literal>element</"
"literal> part, which tells Hibernate that the collection does not contain "
"references to another entity, but a collection of elements of type "
"<literal>String</literal> (the lowercase name tells you it's a Hibernate "
"mapping type/converter). Once again, the <literal>table</literal> attribute "
"of the <literal>set</literal> element determines the table name for the "
"collection. The <literal>key</literal> element defines the foreign-key "
"column name in the collection table. The <literal>column</literal> attribute "
"in the <literal>element</literal> element defines the column name where the "
"<literal>String</literal> values will actually be stored."
msgstr ""
"比较这次和此前映射的差别，主要在于<literal>element</literal>部分，这次并没有"
"包含对其它实体引用的集合，而是元素类型为<literal>String</literal>的集合（在映"
"射中使用小写的名字”string“是向你表明它是一个Hibernate的映射类型或者类型转换"
"器）。和之前一样，<literal>set</literal>元素的<literal>table</literal>属性决"
"定了用于集合的表名。<literal>key</literal>元素定义了在集合表中外键的字段名。"
"<literal>element</literal>元素的<literal>column</literal>属性定义用于实际保存"
"<literal>String</literal>值的字段名。"

#. Tag: para
#: tutorial.xml:728
#, no-c-format
msgid "Have a look at the updated schema:"
msgstr "看一下修改后的数据库schema。"

#. Tag: programlisting
#: tutorial.xml:732
#, no-c-format
msgid ""
"<![CDATA[\n"
"  _____________        __________________\n"
" |             |      |                  |       _____________\n"
" |   EVENTS    |      |   PERSON_EVENT   |      |             |       "
"___________________\n"
" |_____________|      |__________________|      |    PERSON   |      "
"|                   |\n"
" |             |      |                  |      |_____________|      | "
"PERSON_EMAIL_ADDR |\n"
" | *EVENT_ID   | <--> | *EVENT_ID        |      |             |      |"
"___________________|\n"
" |  EVENT_DATE |      | *PERSON_ID       | <--> | *PERSON_ID  | <--> |  "
"*PERSON_ID       |\n"
" |  TITLE      |      |__________________|      |  AGE        |      |  "
"*EMAIL_ADDR      |\n"
" |_____________|                                |  FIRSTNAME  |      |"
"___________________|\n"
"                                                |  LASTNAME   |\n"
"                                                |_____________|\n"
" ]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:734
#, no-c-format
msgid ""
"You can see that the primary key of the collection table is in fact a "
"composite key, using both columns. This also implies that there can't be "
"duplicate email addresses per person, which is exactly the semantics we need "
"for a set in Java."
msgstr ""
"你可以看到集合表的主键实际上是个复合主键，同时使用了2个字段。这也暗示了对于同"
"一个person不能有重复的email地址，这正是Java里面使用Set时候所需要的语义（Set里"
"元素不能重复）。"

#. Tag: para
#: tutorial.xml:740
#, no-c-format
msgid ""
"You can now try and add elements to this collection, just like we did before "
"by linking persons and events. It's the same code in Java:"
msgstr ""
"你现在可以试着把元素加入到这个集合，就像我们在之前关联person和event的那样。其"
"实现的Java代码是相同的："

#. Tag: programlisting
#: tutorial.xml:745
#, no-c-format
msgid ""
"<![CDATA[private void addEmailToPerson(Long personId, String emailAddress) "
"{\n"
"\n"
"    Session session = HibernateUtil.getSessionFactory().getCurrentSession"
"();\n"
"    session.beginTransaction();\n"
"\n"
"    Person aPerson = (Person) session.load(Person.class, personId);\n"
"\n"
"    // The getEmailAddresses() might trigger a lazy load of the collection\n"
"    aPerson.getEmailAddresses().add(emailAddress);\n"
"\n"
"    session.getTransaction().commit();\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:747
#, no-c-format
msgid ""
"This time we didnt' use a <emphasis>fetch</emphasis> query to initialize the "
"collection. Hence, the call to its getter method will trigger an additional "
"select to initialize it, so we can add an element to it. Monitor the SQL log "
"and try to optimize this with an eager fetch."
msgstr ""
"这次我们没有使用<emphasis>fetch</emphasis>查询来初始化集合。因此，调用其"
"getter方法会触发另一附加的select来初始化集合，这样我们才能把元素添加进去。检"
"查SQL log，试着通过预先抓取来优化它。"

#. Tag: title
#: tutorial.xml:757
#, no-c-format
msgid "Bi-directional associations"
msgstr "双向关联"

#. Tag: para
#: tutorial.xml:759
#, no-c-format
msgid ""
"Next we are going to map a bi-directional association - making the "
"association between person and event work from both sides in Java. Of "
"course, the database schema doesn't change, we still have many-to-many "
"multiplicity. A relational database is more flexible than a network "
"programming language, so it doesn't need anything like a navigation "
"direction - data can be viewed and retrieved in any possible way."
msgstr ""
"接下来我们将映射双向关联（bi-directional association）－ 在Java里让person和"
"event可以从关联的任何一端访问另一端。当然，数据库schema没有改变，我们仍然需要"
"多对多的阶数。一个关系型数据库要比网络编程语言 更加灵活，所以它并不需要任何像"
"导航方向（navigation direction）的东西 － 数据可以用任何可能的方式进行查看和"
"获取。"

#. Tag: para
#: tutorial.xml:767
#, no-c-format
msgid ""
"First, add a collection of participants to the <literal>Event</literal> "
"Event class:"
msgstr "首先，把一个参与者（person）的集合加入<literal>Event</literal>类中："

#. Tag: programlisting
#: tutorial.xml:771
#, no-c-format
msgid ""
"<![CDATA[private Set participants = new HashSet();\n"
"\n"
"public Set getParticipants() {\n"
"    return participants;\n"
"}\n"
"\n"
"public void setParticipants(Set participants) {\n"
"    this.participants = participants;\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:773
#, no-c-format
msgid ""
"Now map this side of the association too, in <literal>Event.hbm.xml</"
"literal>."
msgstr "在<literal>Event.hbm.xml</literal>里面也映射这个关联。"

#. Tag: programlisting
#: tutorial.xml:777
#, no-c-format
msgid ""
"<![CDATA[<set name=\"participants\" table=\"PERSON_EVENT\" inverse=\"true"
"\">\n"
"    <key column=\"EVENT_ID\"/>\n"
"    <many-to-many column=\"PERSON_ID\" class=\"events.Person\"/>\n"
"</set>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:779
#, no-c-format
msgid ""
"As you see, these are normal <literal>set</literal> mappings in both mapping "
"documents. Notice that the column names in <literal>key</literal> and "
"<literal>many-to-many</literal> are swapped in both mapping documents. The "
"most important addition here is the <literal>inverse=\"true\"</literal> "
"attribute in the <literal>set</literal> element of the <literal>Event</"
"literal>'s collection mapping."
msgstr ""
"如你所见，两个映射文件里都有普通的<literal>set</literal>映射。注意在两个映射"
"文件中，互换了<literal>key</literal>和<literal>many-to-many</literal>的字段"
"名。这里最重要的是<literal>Event</literal>映射文件里增加了<literal>set</"
"literal>元素的<literal>inverse=\"true\"</literal>属性。"

#. Tag: para
#: tutorial.xml:787
#, no-c-format
msgid ""
"What this means is that Hibernate should take the other side - the "
"<literal>Person</literal> class - when it needs to find out information "
"about the link between the two. This will be a lot easier to understand once "
"you see how the bi-directional link between our two entities is created ."
msgstr ""
"这意味着在需要的时候，Hibernate能在关联的另一端 － <literal>Person</literal>"
"类得到两个实体间关联的信息。这将会极大地帮助你理解双向关联是如何在两个实体间"
"被创建的。"

#. Tag: title
#: tutorial.xml:796
#, no-c-format
msgid "Working bi-directional links"
msgstr "使双向连起来"

#. Tag: para
#: tutorial.xml:798
#, no-c-format
msgid ""
"First, keep in mind that Hibernate does not affect normal Java semantics. "
"How did we create a link between a <literal>Person</literal> and an "
"<literal>Event</literal> in the unidirectional example? We added an instance "
"of <literal>Event</literal> to the collection of event references, of an "
"instance of <literal>Person</literal>. So, obviously, if we want to make "
"this link working bi-directional, we have to do the same on the other side - "
"adding a <literal>Person</literal> reference to the collection in an "
"<literal>Event</literal>. This \"setting the link on both sides\" is "
"absolutely necessary and you should never forget doing it."
msgstr ""
"首先请记住，Hibernate并不影响通常的Java语义。 在单向关联的例子中，我们是怎样"
"在<literal>Person</literal>和<literal>Event</literal>之间创建联系的？我们把"
"<literal>Event</literal>实例添加到<literal>Person</literal>实例内的event引用"
"集合里。因此很显然，如果我们要让这个关联可以双向地工作，我们需要在另外一端做"
"同样的事情 － 把<literal>Person</literal>实例加入<literal>Event</literal>类内"
"的Person引用集合。这“在关联的两端设置联系”是完全必要的而且你都得这么做。"

#. Tag: para
#: tutorial.xml:808
#, no-c-format
msgid ""
"Many developers program defensive and create link management methods to "
"correctly set both sides, e.g. in <literal>Person</literal>:"
msgstr ""
"许多开发人员防御式地编程，创建管理关联的方法来保证正确的设置了关联的两端，比"
"如在<literal>Person</literal>里："

#. Tag: programlisting
#: tutorial.xml:813
#, no-c-format
msgid ""
"<![CDATA[protected Set getEvents() {\n"
"    return events;\n"
"}\n"
"\n"
"protected void setEvents(Set events) {\n"
"    this.events = events;\n"
"}\n"
"\n"
"public void addToEvent(Event event) {\n"
"    this.getEvents().add(event);\n"
"    event.getParticipants().add(this);\n"
"}\n"
"\n"
"public void removeFromEvent(Event event) {\n"
"    this.getEvents().remove(event);\n"
"    event.getParticipants().remove(this);\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:815
#, no-c-format
msgid ""
"Notice that the get and set methods for the collection are now protected - "
"this allows classes in the same package and subclasses to still access the "
"methods, but prevents everybody else from messing with the collections "
"directly (well, almost). You should probably do the same with the collection "
"on the other side."
msgstr ""
"注意现在对于集合的get和set方法的访问级别是protected - 这允许在位于同一个包"
"（package）中的类以及继承自这个类的子类可以访问这些方法，但禁止其他任何人的直"
"接访问，避免了集合内容的混乱。你应尽可能地在另一端也把集合的访问级别设成"
"protected。"

#. Tag: para
#: tutorial.xml:822
#, no-c-format
msgid ""
"What about the <literal>inverse</literal> mapping attribute? For you, and "
"for Java, a bi-directional link is simply a matter of setting the references "
"on both sides correctly. Hibernate however doesn't have enough information "
"to correctly arrange SQL <literal>INSERT</literal> and <literal>UPDATE</"
"literal> statements (to avoid constraint violations), and needs some help to "
"handle bi-directional associations properly. Making one side of the "
"association <literal>inverse</literal> tells Hibernate to basically ignore "
"it, to consider it a <emphasis>mirror</emphasis> of the other side. That's "
"all that is necessary for Hibernate to work out all of the issues when "
"transformation a directional navigation model to a SQL database schema. The "
"rules you have to remember are straightforward: All bi-directional "
"associations need one side as <literal>inverse</literal>. In a one-to-many "
"association it has to be the many-side, in many-to-many association you can "
"pick either side, there is no difference."
msgstr ""
"<literal>inverse</literal>映射属性究竟表示什么呢？对于你和Java来说，一个双向"
"关联仅仅是在两端简单地正确设置引用。然而，Hibernate并没有足够的信息去正确地执"
"行<literal>INSERT</literal>和<literal>UPDATE</literal>语句（以避免违反数据库"
"约束），所以它需要一些帮助来正确的处理双向关联。把关联的一端设置为"
"<literal>inverse</literal>将告诉Hibernate忽略关联的这一端，把这端看成是另外一"
"端的一个<emphasis>镜象（mirror）</emphasis>。这就是所需的全部信息，Hibernate"
"利用这些信息来处理把一个有向导航模型转移到数据库schema时的所有问题。你只需要"
"记住这个直观的规则：所有的双向关联需要有一端被设置为<literal>inverse</"
"literal>。在一对多关联中它必须是代表多（many）的那端。而在多对多（many-to-"
"many）关联中，你可以任意选取一端，因为两端之间并没有差别。"

#. Tag: para
#: tutorial.xml:837
#, no-c-format
msgid "Let's turn this into a small web application."
msgstr "让我们把进入一个小型的web应用程序。"

#. Tag: title
#: tutorial.xml:844
#, no-c-format
msgid "Part 3 - The EventManager web application"
msgstr "第三部分 - EventManager web应用程序"

#. Tag: para
#: tutorial.xml:846
#, no-c-format
msgid ""
"A Hibernate web application uses <literal>Session</literal> and "
"<literal>Transaction</literal> almost like a standalone application. "
"However, some common patterns are useful. We now write an "
"<literal>EventManagerServlet</literal>. This servlet can list all events "
"stored in the database, and it provides an HTML form to enter new events."
msgstr ""
"Hibernate web应用程序使用<literal>Session</literal> 和<literal>Transaction</"
"literal>的方式几乎和独立应用程序是一样的。但是，有一些常见的模式（pattern）非"
"常有用。现在我们编写一个<literal>EventManagerServlet</literal>。这个servlet可"
"以列出数据库中保存的所有的events，还提供一个HTML表单来增加新的events。"

#. Tag: title
#: tutorial.xml:854
#, no-c-format
msgid "Writing the basic servlet"
msgstr "编写基本的servlet"

#. Tag: para
#: tutorial.xml:856
#, no-c-format
msgid ""
"Create a new class in your source directory, in the <literal>events</"
"literal> package:"
msgstr "在你的源代码目录的<literal>events</literal>包中创建一个新的类："

#. Tag: programlisting
#: tutorial.xml:861
#, no-c-format
msgid ""
"<![CDATA[package events;\n"
"\n"
"// Imports\n"
"\n"
"public class EventManagerServlet extends HttpServlet {\n"
"\n"
"    // Servlet code\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:863
#, no-c-format
msgid ""
"The servlet handles HTTP <literal>GET</literal> requests only, hence, the "
"method we implement is <literal>doGet()</literal>:"
msgstr ""
"我们后面会用到<literal>dateFormatter</literal> 的工具， 它把<literal>Date</"
"literal>对象转换为字符串。只要一个formatter作为servlet的成员就可以了。"

#. Tag: programlisting
#: tutorial.xml:868
#, no-c-format
msgid ""
"<![CDATA[protected void doGet(HttpServletRequest request,\n"
"                     HttpServletResponse response)\n"
"        throws ServletException, IOException {\n"
"\n"
"    SimpleDateFormat dateFormatter = new SimpleDateFormat(\"dd.MM.yyyy\");\n"
"\n"
"    try {\n"
"        // Begin unit of work\n"
"        HibernateUtil.getSessionFactory()\n"
"                .getCurrentSession().beginTransaction();\n"
"\n"
"        // Process request and render page...\n"
"\n"
"        // End unit of work\n"
"        HibernateUtil.getSessionFactory()\n"
"                .getCurrentSession().getTransaction().commit();\n"
"\n"
"    } catch (Exception ex) {\n"
"        HibernateUtil.getSessionFactory()\n"
"                .getCurrentSession().getTransaction().rollback();\n"
"        throw new ServletException(ex);\n"
"    }\n"
"\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:870
#, fuzzy, no-c-format
msgid ""
"The pattern we are applying here is called <emphasis>session-per-request</"
"emphasis>. When a request hits the servlet, a new Hibernate "
"<literal>Session</literal> is opened through the first call to "
"<literal>getCurrentSession()</literal> on the <literal>SessionFactory</"
"literal>. Then a database transaction is started&mdash;all data access as to "
"occur inside a transaction, no matter if data is read or written (we don't "
"use the auto-commit mode in applications)."
msgstr ""
"这个servlet只处理 HTTP <literal>GET</literal> 请求，因此，我们要实现的是"
"<literal>doGet()</literal>方法："

#. Tag: para
#: tutorial.xml:879
#, no-c-format
msgid ""
"Do <emphasis>not</emphasis> use a new Hibernate <literal>Session</literal> "
"for every database operation. Use one Hibernate <literal>Session</literal> "
"that is scoped to the whole request. Use <literal>getCurrentSession()</"
"literal>, so that it is automatically bound to the current Java thread."
msgstr ""
"我们称这里应用的模式为每次请求一个session<emphasis>(session-per-request)</"
"emphasis>。当有请求到达这个servlet的时候，通过对<literal>SessionFactory</"
"literal>的第一次调用，打开一个新的Hibernate <literal>Session</literal>。然后"
"启动一个数据库事务&mdash;所有的数据访问都是在事务中进行，不管是读还是写（我们"
"在应用程序中不使用auto-commit模式）。"

#. Tag: para
#: tutorial.xml:886
#, no-c-format
msgid ""
"Next, the possible actions of the request are processed and the response "
"HTML is rendered. We'll get to that part soon."
msgstr ""
"<emphasis>不要</emphasis>为每次数据库操作都使用一个新的Hibernate "
"<literal>Session</literal>。将Hibernate <literal>Session</literal>的范围设置"
"为整个请求。要用<literal>getCurrentSession()</literal>，这样它自动会绑定到当"
"前Java线程。"

#. Tag: para
#: tutorial.xml:891
#, fuzzy, no-c-format
msgid ""
"Finally, the unit of work ends when processing and rendering is complete. If "
"any problem occured during processing or rendering, an exception will be "
"thrown and the database transaction rolled back. This completes the "
"<literal>session-per-request</literal> pattern. Instead of the transaction "
"demarcation code in every servlet you could also write a servlet filter. See "
"the Hibernate website and Wiki for more information about this pattern, "
"called <emphasis>Open Session in View</emphasis>&mdash;you'll need it as "
"soon as you consider rendering your view in JSP, not in a servlet."
msgstr ""
"下一步，对请求的可能动作进行处理，渲染出反馈的HTML。我们很快就会涉及到那部"
"分。"

#. Tag: title
#: tutorial.xml:905
#, no-c-format
msgid "Processing and rendering"
msgstr ""
"最后，当处理与渲染都结束的时候，这个工作单元就结束了。假若在处理或渲染的时候"
"有任何错误发生，会抛出一个异常，回滚数据库事务。这样，<literal>session-per-"
"request</literal>模式就完成了。为了避免在每个servlet中都编写事务边界界定的代"
"码，可以考虑写一个servlet 过滤器（filter）来更好地解决。关于这一模式的更多信"
"息，请参阅Hibernate网站和Wiki，这一模式叫做<emphasis>Open Session in View</"
"emphasis>&mdash;只要你考虑用JSP来渲染你的视图（view），而不是在servlet中，你"
"就会很快用到它。"

#. Tag: para
#: tutorial.xml:907
#, no-c-format
msgid ""
"Let's implement the processing of the request and rendering of the page."
msgstr "处理与渲染"

#. Tag: programlisting
#: tutorial.xml:911
#, no-c-format
msgid ""
"<![CDATA[// Write HTML header\n"
"PrintWriter out = response.getWriter();\n"
"out.println(\"<html><head><title>Event Manager</title></head><body>\");\n"
"\n"
"// Handle actions\n"
"if ( \"store\".equals(request.getParameter(\"action\")) ) {\n"
"\n"
"    String eventTitle = request.getParameter(\"eventTitle\");\n"
"    String eventDate = request.getParameter(\"eventDate\");\n"
"\n"
"    if ( \"\".equals(eventTitle) || \"\".equals(eventDate) ) {\n"
"        out.println(\"<b><i>Please enter event title and date.</i></b>\");\n"
"    } else {\n"
"        createAndStoreEvent(eventTitle, dateFormatter.parse(eventDate));\n"
"        out.println(\"<b><i>Added event.</i></b>\");\n"
"    }\n"
"}\n"
"\n"
"// Print page\n"
"printEventForm(out);\n"
"listEvents(out, dateFormatter);\n"
"\n"
"// Write HTML footer\n"
"out.println(\"</body></html>\");\n"
"out.flush();\n"
"out.close();]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:913
#, fuzzy, no-c-format
msgid ""
"Granted, this coding style with a mix of Java and HTML would not scale in a "
"more complex application&mdash;keep in mind that we are only illustrating "
"basic Hibernate concepts in this tutorial. The code prints an HTML header "
"and a footer. Inside this page, an HTML form for event entry and a list of "
"all events in the database are printed. The first method is trivial and only "
"outputs HTML:"
msgstr "我们来实现处理请求以及渲染页面的工作。"

#. Tag: programlisting
#: tutorial.xml:922
#, no-c-format
msgid ""
"<![CDATA[private void printEventForm(PrintWriter out) {\n"
"    out.println(\"<h2>Add new event:</h2>\");\n"
"    out.println(\"<form>\");\n"
"    out.println(\"Title: <input name='eventTitle' length='50'/><br/>\");\n"
"    out.println(\"Date (e.g. 24.12.2009): <input name='eventDate' "
"length='10'/><br/>\");\n"
"    out.println(\"<input type='submit' name='action' value='store'/>\");\n"
"    out.println(\"</form>\");\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:924
#, no-c-format
msgid ""
"The <literal>listEvents()</literal> method uses the Hibernate "
"<literal>Session</literal> bound to the current thread to execute a query:"
msgstr ""
"<literal>listEvents()</literal>方法使用绑定到当前线程的Hibernate "
"<literal>Session</literal>来执行查询："

#. Tag: programlisting
#: tutorial.xml:930
#, no-c-format
msgid ""
"<![CDATA[private void listEvents(PrintWriter out, SimpleDateFormat "
"dateFormatter) {\n"
"\n"
"    List result = HibernateUtil.getSessionFactory()\n"
"                    .getCurrentSession().createCriteria(Event.class).list"
"();\n"
"    if (result.size() > 0) {\n"
"        out.println(\"<h2>Events in database:</h2>\");\n"
"        out.println(\"<table border='1'>\");\n"
"        out.println(\"<tr>\");\n"
"        out.println(\"<th>Event title</th>\");\n"
"        out.println(\"<th>Event date</th>\");\n"
"        out.println(\"</tr>\");\n"
"        for (Iterator it = result.iterator(); it.hasNext();) {\n"
"            Event event = (Event) it.next();\n"
"            out.println(\"<tr>\");\n"
"            out.println(\"<td>\" + event.getTitle() + \"</td>\");\n"
"            out.println(\"<td>\" + dateFormatter.format(event.getDate()) + "
"\"</td>\");\n"
"            out.println(\"</tr>\");\n"
"        }\n"
"        out.println(\"</table>\");\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:932
#, no-c-format
msgid ""
"Finally, the <literal>store</literal> action is dispatched to the "
"<literal>createAndStoreEvent()</literal> method, which also uses the "
"<literal>Session</literal> of the current thread:"
msgstr ""
"最后，<literal>store</literal>动作会被导向到<literal>createAndStoreEvent()</"
"literal>方法，它也使用当前线程的<literal>Session</literal>:"

#. Tag: programlisting
#: tutorial.xml:938
#, no-c-format
msgid ""
"<![CDATA[protected void createAndStoreEvent(String title, Date theDate) {\n"
"    Event theEvent = new Event();\n"
"    theEvent.setTitle(title);\n"
"    theEvent.setDate(theDate);\n"
"\n"
"    HibernateUtil.getSessionFactory()\n"
"                    .getCurrentSession().save(theEvent);\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:940
#, no-c-format
msgid ""
"That's it, the servlet is complete. A request to the servlet will be "
"processed in a single <literal>Session</literal> and <literal>Transaction</"
"literal>. As earlier in the standalone application, Hibernate can "
"automatically bind these ojects to the current thread of execution. This "
"gives you the freedom to layer your code and access the "
"<literal>SessionFactory</literal> in any way you like. Usually you'd use a "
"more sophisticated design and move the data access code into data access "
"objects (the DAO pattern). See the Hibernate Wiki for more examples."
msgstr ""
"大功告成，这个servlet写完了。Hibernate会在单一的<literal>Session</literal> 和"
"<literal>Transaction</literal>中处理到达的servlet请求。如同在前面的独立应用程"
"序中那样，Hibernate可以自动的把这些对象绑定到当前运行的线程中。这给了你用任何"
"你喜欢的方式来对代码分层及访问<literal>SessionFactory</literal>的自由。通常，"
"你会用更加完备的设计，把数据访问代码转移到数据访问对象中(DAO模式）。请参见"
"Hibernate Wiki，那里有更多的例子。"

#. Tag: title
#: tutorial.xml:954
#, no-c-format
msgid "Deploying and testing"
msgstr "部署与测试"

#. Tag: para
#: tutorial.xml:956
#, no-c-format
msgid ""
"To deploy this application you have to create a web archive, a WAR. Add the "
"following Ant target to your <literal>build.xml</literal>:"
msgstr ""
"要发布这个程序，你得把它打成web发布包：WAR文件。把下面的脚本加入到你的"
"<literal>build.xml</literal>中："

#. Tag: programlisting
#: tutorial.xml:961
#, no-c-format
msgid ""
"<![CDATA[<target name=\"war\" depends=\"compile\">\n"
"    <war destfile=\"hibernate-tutorial.war\" webxml=\"web.xml\">\n"
"        <lib dir=\"${librarydir}\">\n"
"          <exclude name=\"jsdk*.jar\"/>\n"
"        </lib>\n"
"\n"
"        <classes dir=\"${targetdir}\"/>\n"
"    </war>\n"
"</target>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:963
#, no-c-format
msgid ""
"This target creates a file called <literal>hibernate-tutorial.war</literal> "
"in your project directory. It packages all libraries and the <literal>web."
"xml</literal> descriptor, which is expected in the base directory of your "
"project:"
msgstr ""
"这段代码在你的开发目录中创建一个<literal>hibernate-tutorial.war</literal>的文"
"件。它把所有的类库和<literal>web.xml</literal>描述文件都打包进去，web.xml 文"
"件应该位于你的开发根目录中："

#. Tag: programlisting
#: tutorial.xml:969
#, no-c-format
msgid ""
"<![CDATA[<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<web-app version=\"2.4\"\n"
"    xmlns=\"http://java.sun.com/xml/ns/j2ee\"\n"
"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"    xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/"
"xml/ns/j2ee/web-app_2_4.xsd\">\n"
"\n"
"    <servlet>\n"
"        <servlet-name>Event Manager</servlet-name>\n"
"        <servlet-class>events.EventManagerServlet</servlet-class>\n"
"    </servlet>\n"
"\n"
"    <servlet-mapping>\n"
"        <servlet-name>Event Manager</servlet-name>\n"
"        <url-pattern>/eventmanager</url-pattern>\n"
"    </servlet-mapping>\n"
"</web-app>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:971
#, no-c-format
msgid ""
"Before you compile and deploy the web application, note that an additional "
"library is required: <literal>jsdk.jar</literal>. This is the Java servlet "
"development kit, if you don't have this library already, get it from the Sun "
"website and copy it to your library directory. However, it will be only used "
"for compliation and excluded from the WAR package."
msgstr ""
"请注意在你编译和部署web应用程之前，需要一个附加的类库：<literal>jsdk.jar</"
"literal>。这是Java Servlet开发包，假若你还没有，可以从Sun网站上下载，把它copy"
"到你的lib目录。但是，它仅仅是在编译时需要，不会被打入WAR包。"

#. Tag: para
#: tutorial.xml:979
#, no-c-format
msgid ""
"To build and deploy call <literal>ant war</literal> in your project "
"directory and copy the <literal>hibernate-tutorial.war</literal> file into "
"your Tomcat <literal>webapp</literal> directory. If you don't have Tomcat "
"installed, download it and follow the installation instructions. You don't "
"have to change any Tomcat configuration to deploy this application though."
msgstr ""
"在你的开发目录中，调用<literal>ant war</literal>来构建、打包，然后把"
"<literal>hibernate-tutorial.war</literal>文件拷贝到你的tomcat的"
"<literal>webapps</literal>目录下。假若你还没安装Tomcat，就去下载一个，按照指"
"南来安装。对此应用的发布，你不需要修改任何Tomcat的配置。"

#. Tag: para
#: tutorial.xml:987
#, no-c-format
msgid ""
"Once deployed and Tomcat is running, access the application at "
"<literal>http://localhost:8080/hibernate-tutorial/eventmanager</literal>. "
"Make sure you watch the Tomcat log to see Hibernate initialize when the "
"first request hits your servlet (the static initializer in "
"<literal>HibernateUtil</literal> is called) and to get the detailed output "
"if any exceptions occurs."
msgstr ""
"在部署完，启动Tomcat之后，通过<literal>http://localhost:8080/hibernate-"
"tutorial/eventmanager</literal>进行访问你的应用，在第一次servlet 请求发生时，"
"请在Tomcat log中确认你看到Hibernate被初始化了（<literal>HibernateUtil</"
"literal>的静态初始化器被调用），假若有任何异常抛出，也可以看到详细的输出。"

#. Tag: title
#: tutorial.xml:1000
#, no-c-format
msgid "Summary"
msgstr "总结"

#. Tag: para
#: tutorial.xml:1002
#, no-c-format
msgid ""
"This tutorial covered the basics of writing a simple standalone Hibernate "
"application and a small web application."
msgstr ""
"本章覆盖了如何编写一个简单独立的Hibernate命令行应用程序及小型的Hibernate web"
"应用程序的基本要素。"

#. Tag: para
#: tutorial.xml:1007
#, no-c-format
msgid ""
"If you already feel confident with Hibernate, continue browsing through the "
"reference documentation table of contents for topics you find interesting - "
"most asked are transactional processing (<xref linkend=\"transactions\"/>), "
"fetch performance (<xref linkend=\"performance\"/>), or the usage of the API "
"(<xref linkend=\"objectstate\"/>) and the query features (<xref linkend="
"\"objectstate-querying\"/>)."
msgstr ""
"如果你已经对Hibernate感到自信，通过开发指南目录，继续浏览你感兴趣的内容－那些"
"会被问到的问题大多是事务处理 (<xref linkend=\"transactions\"/>)，抓取"
"（fetch）的效率 (<xref linkend=\"performance\"/>)，或者API的使用 (<xref "
"linkend=\"objectstate\"/>)和查询的特性(<xref linkend=\"objectstate-querying"
"\"/>)。"

#. Tag: para
#: tutorial.xml:1015
#, no-c-format
msgid ""
"Don't forget to check the Hibernate website for more (specialized) tutorials."
msgstr "别忘了去Hibernate的网站查看更多（有针对性的）示例。"
