<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
      <title>Chapter&nbsp;19.&nbsp;Improving performance</title>
      <link rel="stylesheet" href="css/html.css" type="text/css">
      <meta name="generator" content="DocBook XSL Stylesheets V1.72.0">
      <link rel="start" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java">
      <link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java">
      <link rel="prev" href="xml-manipulation.html" title="18.3.&nbsp;Manipulating XML data">
      <link rel="next" href="performance-cache.html" title="19.2.&nbsp;The Second Level Cache">
   </head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <div class="navheader">
         <table width="100%" summary="Navigation header">
            <tr>
               <th colspan="3" align="center">Chapter&nbsp;19.&nbsp;Improving performance</th>
            </tr>
            <tr>
               <td width="20%" align="left"><a accesskey="p" href="xml-manipulation.html">Prev</a>&nbsp;
               </td>
               <th width="60%" align="center">&nbsp;</th>
               <td width="20%" align="right">&nbsp;<a accesskey="n" href="performance-cache.html">Next</a></td>
            </tr>
         </table>
         <hr>
      </div>
      <div class="chapter" lang="en-US">
         <div class="titlepage">
            <div>
               <div>
                  <h2 class="title"><a name="performance"></a>Chapter&nbsp;19.&nbsp;Improving performance
                  </h2>
               </div>
            </div>
         </div>
         <div class="sect1" lang="en-US">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="performance-fetching"></a>19.1.&nbsp;Fetching strategies
                     </h2>
                  </div>
               </div>
            </div>
            <p>
                           A <span class="emphasis"><em>fetching strategy</em></span> is the strategy Hibernate will use for 
               retrieving associated objects if the application needs to navigate the association. 
                           Fetch strategies may be declared in the O/R mapping metadata, or over-ridden by a 
                           particular HQL or <code class="literal">Criteria</code> query.
                       
            </p>
            <p>
                           Hibernate3 defines the following fetching strategies:
                       
            </p>
            <div class="itemizedlist">
               <ul type="disc">
                  <li>
                     <p>
                                            <span class="emphasis"><em>Join fetching</em></span> - Hibernate retrieves the
                                            associated instance or collection in the same <code class="literal">SELECT</code>,
                                            using an <code class="literal">OUTER JOIN</code>.
                                        
                     </p>
                  </li>
                  <li>
                     <p>
                                            <span class="emphasis"><em>Select fetching</em></span> - a second <code class="literal">SELECT</code>
                                            is used to retrieve the associated entity or collection. Unless
                                            you explicitly disable lazy fetching by specifying <code class="literal">lazy="false"</code>, 
                                            this second select will only be executed when you actually access the
                                            association.
                                        
                     </p>
                  </li>
                  <li>
                     <p>
                                            <span class="emphasis"><em>Subselect fetching</em></span> - a second <code class="literal">SELECT</code>
                                            is used to retrieve the associated collections for all entities retrieved in a
                                            previous query or fetch. Unless you explicitly disable lazy fetching by specifying 
                                            <code class="literal">lazy="false"</code>, this second select will only be executed when you 
                                            actually access the association.
                                        
                     </p>
                  </li>
                  <li>
                     <p>
                                            <span class="emphasis"><em>Batch fetching</em></span> - an optimization strategy
                                            for select fetching - Hibernate retrieves a batch of entity instances 
                                            or collections in a single <code class="literal">SELECT</code>, by specifying 
                                            a list of primary keys or foreign keys.
                                        
                     </p>
                  </li>
               </ul>
            </div>
            <p>
                           Hibernate also distinguishes between:
                       
            </p>
            <div class="itemizedlist">
               <ul type="disc">
                  <li>
                     <p>
                                            <span class="emphasis"><em>Immediate fetching</em></span> - an association, collection or
                                            attribute is fetched immediately, when the owner is loaded.
                                        
                     </p>
                  </li>
                  <li>
                     <p>
                                            <span class="emphasis"><em>Lazy collection fetching</em></span> - a collection is fetched 
                                            when the application invokes an operation upon that collection. (This
                                            is the default for collections.)
                                        
                     </p>
                  </li>
                  <li>
                     <p>
                                            <span class="emphasis"><em>"Extra-lazy" collection fetching</em></span> - individual
                                            elements of the collection are accessed from the database as needed.
                                            Hibernate tries not to fetch the whole collection into memory unless
                                            absolutely needed (suitable for very large collections)
                                        
                     </p>
                  </li>
                  <li>
                     <p>
                                            <span class="emphasis"><em>Proxy fetching</em></span> - a single-valued association is 
                                            fetched when a method other than the identifier getter is invoked
                                            upon the associated object.
                                        
                     </p>
                  </li>
                  <li>
                     <p>
                                            <span class="emphasis"><em>"No-proxy" fetching</em></span> - a single-valued association is 
                                            fetched when the instance variable is accessed. Compared to proxy fetching, 
                                            this approach is less lazy (the association is fetched even when only the 
                                            identifier is accessed) but more transparent, since no proxy is visible to 
                                            the application. This approach requires buildtime bytecode instrumentation 
                                            and is rarely necessary.
                                        
                     </p>
                  </li>
                  <li>
                     <p>
                                            <span class="emphasis"><em>Lazy attribute fetching</em></span> - an attribute or single
                                            valued association is fetched when the instance variable is accessed. 
                                            This approach requires buildtime bytecode instrumentation and is rarely 
                                            necessary.
                                        
                     </p>
                  </li>
               </ul>
            </div>
            <p>
                           We have two orthogonal notions here: <span class="emphasis"><em>when</em></span> is the association
                           fetched, and <span class="emphasis"><em>how</em></span> is it fetched (what SQL is used). Don't
                           confuse them! We use <code class="literal">fetch</code> to tune performance. We may use 
                           <code class="literal">lazy</code> to define a contract for what data is always available 
                           in any detached instance of a particular class.
                       
            </p>
            <div class="sect2" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="performance-fetching-lazy"></a>19.1.1.&nbsp;Working with lazy associations
                        </h3>
                     </div>
                  </div>
               </div>
               <p>
                                  By default, Hibernate3 uses lazy select fetching for collections and lazy proxy
                                  fetching for single-valued associations. These defaults make sense for almost
                                  all associations in almost all applications. 
                              
               </p>
               <p>
                                  <span class="emphasis"><em>Note:</em></span> if you set 
                                  <code class="literal">hibernate.default_batch_fetch_size</code>, Hibernate will use the 
                                  batch fetch optimization for lazy fetching (this optimization may also be enabled 
                                  at a more granular level).
                              
               </p>
               <p>
                                  However, lazy fetching poses one problem that you must be aware of. Access to a 
                                  lazy association outside of the context of an open Hibernate session will result 
                                  in an exception. For example:
                              
               </p><pre class="programlisting">s = sessions.openSession();
Transaction tx = s.beginTransaction();
            
User u = (User) s.createQuery("from User u where u.name=:userName")
    .setString("userName", userName).uniqueResult();
Map permissions = u.getPermissions();

tx.commit();
s.close();

Integer accessLevel = (Integer) permissions.get("accounts");  // Error!</pre><p>
                                  Since the permissions collection was not initialized when the 
                                  <code class="literal">Session</code> was closed, the collection will not be able to 
                                  load its state. <span class="emphasis"><em>Hibernate does not support lazy initialization 
                                        for detached objects</em></span>. The fix is to move the code that reads 
                                  from the collection to just before the transaction is committed.
                              
               </p>
               <p>
                                  Alternatively, we could use a non-lazy collection or association, 
                                  by specifying <code class="literal">lazy="false"</code> for the association mapping.
                                  However, it is intended that lazy initialization be used for almost all 
                                  collections and associations. If you define too many non-lazy associations 
                                  in your object model, Hibernate will end up needing to fetch the entire 
                                  database into memory in every transaction!
                              
               </p>
               <p>
                                  On the other hand, we often want to choose join fetching (which is non-lazy by 
                                  nature) instead of select fetching in a particular transaction. We'll now see
                                  how to customize the fetching strategy. In Hibernate3, the mechanisms for
                                  choosing a fetch strategy are identical for single-valued associations and
                                  collections.
                              
               </p>
            </div>
            <div class="sect2" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="performance-fetching-custom"></a>19.1.2.&nbsp;Tuning fetch strategies
                        </h3>
                     </div>
                  </div>
               </div>
               <p>
                                  Select fetching (the default) is extremely vulnerable to N+1 selects problems, 
                                  so we might want to enable join fetching in the mapping document:
                              
               </p><pre class="programlisting">&lt;set name="permissions" 
            fetch="join"&gt;
    &lt;key column="userId"/&gt;
    &lt;one-to-many class="Permission"/&gt;
&lt;/set</pre><pre class="programlisting">&lt;many-to-one name="mother" class="Cat" fetch="join"/&gt;</pre><p>
                                  The <code class="literal">fetch</code> strategy defined in the mapping document affects:
                              
               </p>
               <div class="itemizedlist">
                  <ul type="disc">
                     <li>
                        <p>
                                               retrieval via <code class="literal">get()</code> or <code class="literal">load()</code>
                                           
                        </p>
                     </li>
                     <li>
                        <p>
                                               retrieval that happens implicitly when an association is navigated
                                           
                        </p>
                     </li>
                     <li>
                        <p>
                                               <code class="literal">Criteria</code> queries
                                           
                        </p>
                     </li>
                     <li>
                        <p>
                                               HQL queries if <code class="literal">subselect</code> fetching is used
                                           
                        </p>
                     </li>
                  </ul>
               </div>
               <p>
                                  No matter what fetching strategy you use, the defined non-lazy graph is guaranteed
                                  to be loaded into memory. Note that this might result in several immediate selects
                                  being used to execute a particular HQL query.
                              
               </p>
               <p>
                                  Usually, we don't use the mapping document to customize fetching. Instead, we
                                  keep the default behavior, and override it for a particular transaction, using 
                                  <code class="literal">left join fetch</code> in HQL. This tells Hibernate to fetch 
                                  the association eagerly in the first select, using an outer join. In the
                                  <code class="literal">Criteria</code> query API, you would use
                                  <code class="literal">setFetchMode(FetchMode.JOIN)</code>.
                              
               </p>
               <p>
                                  If you ever feel like you wish you could change the fetching strategy used by
                                  <code class="literal">get()</code> or <code class="literal">load()</code>, simply use a 
                                  <code class="literal">Criteria</code> query, for example:
                              
               </p><pre class="programlisting">User user = (User) session.createCriteria(User.class)
                .setFetchMode("permissions", FetchMode.JOIN)
                .add( Restrictions.idEq(userId) )
                .uniqueResult();</pre><p>
                                  (This is Hibernate's equivalent of what some ORM solutions call a "fetch plan".)
                              
               </p>
               <p>
                                  A completely different way to avoid problems with N+1 selects is to use the 
                                  second-level cache.
                              
               </p>
            </div>
            <div class="sect2" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="performance-fetching-proxies"></a>19.1.3.&nbsp;Single-ended association proxies
                        </h3>
                     </div>
                  </div>
               </div>
               <p>
                                  Lazy fetching for collections is implemented using Hibernate's own implementation
                                  of persistent collections. However, a different mechanism is needed for lazy
                                  behavior in single-ended associations. The target entity of the association must
                                  be proxied. Hibernate implements lazy initializing proxies for persistent objects
                                  using runtime bytecode enhancement (via the excellent CGLIB library).
                              
               </p>
               <p>
                                  By default, Hibernate3 generates proxies (at startup) for all persistent classes
                                  and uses them to enable lazy fetching of <code class="literal">many-to-one</code> and
                                  <code class="literal">one-to-one</code> associations.
                              
               </p>
               <p>
                                  The mapping file may declare an interface to use as the proxy interface for that
                                  class, with the <code class="literal">proxy</code> attribute. By default, Hibernate uses a subclass
                                  of the class. <span class="emphasis"><em>Note that the proxied class must implement a default constructor
                                        with at least package visibility. We recommend this constructor for all persistent classes!</em></span>
                              
               </p>
               <p>
                                  There are some gotchas to be aware of when extending this approach to polymorphic
                                  classes, eg.
                              
               </p><pre class="programlisting">&lt;class name="Cat" proxy="Cat"&gt;
    ......
    &lt;subclass name="DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
                                  Firstly, instances of <code class="literal">Cat</code> will never be castable to
                                  <code class="literal">DomesticCat</code>, even if the underlying instance is an
                                  instance of <code class="literal">DomesticCat</code>:
                              
               </p><pre class="programlisting">Cat cat = (Cat) session.load(Cat.class, id);  // instantiate a proxy (does not hit the db)
if ( cat.isDomesticCat() ) {                  // hit the db to initialize the proxy
    DomesticCat dc = (DomesticCat) cat;       // Error!
    ....
}</pre><p>
                                  Secondly, it is possible to break proxy <code class="literal">==</code>.
                              
               </p><pre class="programlisting">Cat cat = (Cat) session.load(Cat.class, id);            // instantiate a Cat proxy
DomesticCat dc = 
        (DomesticCat) session.load(DomesticCat.class, id);  // acquire new DomesticCat proxy!
System.out.println(cat==dc);                            // false</pre><p>
                                  However, the situation is not quite as bad as it looks. Even though we now have two references
                                  to different proxy objects, the underlying instance will still be the same object:
                              
               </p><pre class="programlisting">cat.setWeight(11.0);  // hit the db to initialize the proxy
System.out.println( dc.getWeight() );  // 11.0</pre><p>
                                  Third, you may not use a CGLIB proxy for a <code class="literal">final</code> class or a class
                                  with any <code class="literal">final</code> methods.
                              
               </p>
               <p>
                                  Finally, if your persistent object acquires any resources upon instantiation (eg. in
                                  initializers or default constructor), then those resources will also be acquired by
                                  the proxy. The proxy class is an actual subclass of the persistent class.
                              
               </p>
               <p>
                                  These problems are all due to fundamental limitations in Java's single inheritance model.
                                  If you wish to avoid these problems your persistent classes must each implement an interface
                                  that declares its business methods. You should specify these interfaces in the mapping file. eg.
                              
               </p><pre class="programlisting">&lt;class name="CatImpl" proxy="Cat"&gt;
    ......
    &lt;subclass name="DomesticCatImpl" proxy="DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>
                                  where <code class="literal">CatImpl</code> implements the interface <code class="literal">Cat</code> and
                                  <code class="literal">DomesticCatImpl</code> implements the interface <code class="literal">DomesticCat</code>. Then
                                  proxies for instances of <code class="literal">Cat</code> and <code class="literal">DomesticCat</code> may be returned
                                  by <code class="literal">load()</code> or <code class="literal">iterate()</code>. (Note that <code class="literal">list()</code>
                                  does not usually return proxies.)
                              
               </p><pre class="programlisting">Cat cat = (Cat) session.load(CatImpl.class, catid);
Iterator iter = session.createQuery("from CatImpl as cat where cat.name='fritz'").iterate();
Cat fritz = (Cat) iter.next();</pre><p>
                                  Relationships are also lazily initialized. This means you must declare any properties to be of
                                  type <code class="literal">Cat</code>, not <code class="literal">CatImpl</code>.
                              
               </p>
               <p>
                                  Certain operations do <span class="emphasis"><em>not</em></span> require proxy initialization
                              
               </p>
               <div class="itemizedlist">
                  <ul type="disc" compact>
                     <li>
                        <p>
                                                   <code class="literal">equals()</code>, if the persistent class does not override
                                                   <code class="literal">equals()</code>
                                               
                        </p>
                     </li>
                     <li>
                        <p>
                                                   <code class="literal">hashCode()</code>, if the persistent class does not override
                                                   <code class="literal">hashCode()</code>
                                               
                        </p>
                     </li>
                     <li>
                        <p>
                                                   The identifier getter method
                                               
                        </p>
                     </li>
                  </ul>
               </div>
               <p>
                                  Hibernate will detect persistent classes that override <code class="literal">equals()</code> or
                                  <code class="literal">hashCode()</code>.
                              
               </p>
               <p>
                                  By choosing <code class="literal">lazy="no-proxy"</code> instead of the default 
                                  <code class="literal">lazy="proxy"</code>, we can avoid the problems associated with typecasting.
                                  However, we will require buildtime bytecode instrumentation, and all operations
                                  will result in immediate proxy initialization.
                              
               </p>
            </div>
            <div class="sect2" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="performance-fetching-initialization"></a>19.1.4.&nbsp;Initializing collections and proxies
                        </h3>
                     </div>
                  </div>
               </div>
               <p>
                                  A <code class="literal">LazyInitializationException</code> will be thrown by Hibernate if an uninitialized 
                                  collection or proxy is accessed outside of the scope of the <code class="literal">Session</code>, ie. when 
                                  the entity owning the collection or having the reference to the proxy is in the detached state.
                              
               </p>
               <p>
                                  Sometimes we need to ensure that a proxy or collection is initialized before closing the
                                  <code class="literal">Session</code>. Of course, we can alway force initialization by calling
                                  <code class="literal">cat.getSex()</code> or <code class="literal">cat.getKittens().size()</code>, for example.
                                  But that is confusing to readers of the code and is not convenient for generic code.
                              
               </p>
               <p>
                                  The static methods <code class="literal">Hibernate.initialize()</code> and <code class="literal">Hibernate.isInitialized()</code>
                                  provide the application with a convenient way of working with lazily initialized collections or
                                  proxies. <code class="literal">Hibernate.initialize(cat)</code> will force the initialization of a proxy,
                                  <code class="literal">cat</code>, as long as its <code class="literal">Session</code> is still open.
                                  <code class="literal">Hibernate.initialize( cat.getKittens() )</code> has a similar effect for the collection
                                  of kittens.
                              
               </p>
               <p>
                                  Another option is to keep the <code class="literal">Session</code> open until all needed
                                  collections and proxies have been loaded. In some application architectures,
                                  particularly where the code that accesses data using Hibernate, and the code that
                                  uses it are in different application layers or different physical processes, it 
                                  can be a problem to ensure that the <code class="literal">Session</code> is open when a 
                                  collection is initialized. There are two basic ways to deal with this issue:
                              
               </p>
               <div class="itemizedlist">
                  <ul type="disc">
                     <li>
                        <p>
                                                   In a web-based application, a servlet filter can be used to close the
                                                   <code class="literal">Session</code> only at the very end of a user request, once
                                                   the rendering of the view is complete (the <span class="emphasis"><em>Open Session in
                                                         View</em></span> pattern).  Of course, this places heavy demands on the 
                                                   correctness of the exception handling of your application infrastructure. 
                                                   It is vitally important that the <code class="literal">Session</code> is closed and the 
                                                   transaction ended before returning to the user, even when an exception occurs 
                                                   during rendering of the view. See the Hibernate Wiki for examples of this
                                                   "Open Session in View" pattern.
                                               
                        </p>
                     </li>
                     <li>
                        <p>
                                                   In an application with a separate business tier, the business logic must
                                                   "prepare" all collections that will be needed by the web tier before
                                                   returning. This means that the business tier should load all the data and
                                                   return all the data already initialized to the presentation/web tier that
                                                   is required for a particular use case. Usually, the application calls
                                                   <code class="literal">Hibernate.initialize()</code> for each collection that will
                                                   be needed in the web tier (this call must occur before the session is closed)
                                                   or retrieves the collection eagerly using a Hibernate query with a
                                                   <code class="literal">FETCH</code> clause or a <code class="literal">FetchMode.JOIN</code> in
                                                   <code class="literal">Criteria</code>. This is usually easier if you adopt the
                                                   <span class="emphasis"><em>Command</em></span> pattern instead of a <span class="emphasis"><em>Session Facade</em></span>.
                                               
                        </p>
                     </li>
                     <li>
                        <p>
                                                   You may also attach a previously loaded object to a new <code class="literal">Session</code>
                                                   with <code class="literal">merge()</code> or <code class="literal">lock()</code> before
                                                   accessing uninitialized collections (or other proxies). No, Hibernate does not,
                                                   and certainly <span class="emphasis"><em>should</em></span> not do this automatically, since it 
                                                   would introduce ad hoc transaction semantics!
                                               
                        </p>
                     </li>
                  </ul>
               </div>
               <p>
                                  Sometimes you don't want to initialize a large collection, but still need some
                                  information about it (like its size) or a subset of the data.
                              
               </p>
               <p>
                                  You can use a collection filter to get the size of a collection without initializing it:
                              
               </p><pre class="programlisting">( (Integer) s.createFilter( collection, "select count(*)" ).list().get(0) ).intValue()</pre><p>
                                  The <code class="literal">createFilter()</code> method is also used to efficiently retrieve subsets
                                  of a collection without needing to initialize the whole collection:
                              
               </p><pre class="programlisting">s.createFilter( lazyCollection, "").setFirstResult(0).setMaxResults(10).list();</pre></div>
            <div class="sect2" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="performance-fetching-batch"></a>19.1.5.&nbsp;Using batch fetching
                        </h3>
                     </div>
                  </div>
               </div>
               <p>
                                  Hibernate can make efficient use of batch fetching, that is, Hibernate can load several uninitialized
                                  proxies if one proxy is accessed (or collections. Batch fetching is an optimization of the lazy select
                                  fetching strategy. There are two ways you can tune batch fetching: on the class and the collection level.
                              
               </p>
               <p>
                                  Batch fetching for classes/entities is easier to understand. Imagine you have the following situation
                                  at runtime: You have 25 <code class="literal">Cat</code> instances loaded in a <code class="literal">Session</code>, each
                                  <code class="literal">Cat</code> has a reference to its <code class="literal">owner</code>, a <code class="literal">Person</code>.
                                  The <code class="literal">Person</code> class is mapped with a proxy, <code class="literal">lazy="true"</code>. If you now
                                  iterate through all cats and call <code class="literal">getOwner()</code> on each, Hibernate will by default
                                  execute 25 <code class="literal">SELECT</code> statements, to retrieve the proxied owners. You can tune this
                                  behavior by specifying a <code class="literal">batch-size</code> in the mapping of <code class="literal">Person</code>:
                              
               </p><pre class="programlisting">&lt;class name="Person" batch-size="10"&gt;...&lt;/class&gt;</pre><p>
                                  Hibernate will now execute only three queries, the pattern is 10, 10, 5.
                              
               </p>
               <p>
                                  You may also enable batch fetching of collections. For example, if each <code class="literal">Person</code> has
                                  a lazy collection of <code class="literal">Cat</code>s, and 10 persons are currently loaded in the
                                  <code class="literal">Session</code>, iterating through all persons will generate 10 <code class="literal">SELECT</code>s,
                                  one for every call to <code class="literal">getCats()</code>. If you enable batch fetching for the
                                  <code class="literal">cats</code> collection in the mapping of <code class="literal">Person</code>, Hibernate can pre-fetch
                                  collections:
                              
               </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;set name="cats" batch-size="3"&gt;
        ...
    &lt;/set&gt;
&lt;/class&gt;</pre><p>
                                  With a <code class="literal">batch-size</code> of 3, Hibernate will load 3, 3, 3, 1 collections in four
                                  <code class="literal">SELECT</code>s. Again, the value of the attribute depends on the expected number of
                                  uninitialized collections in a particular <code class="literal">Session</code>.
                              
               </p>
               <p>
                                  Batch fetching of collections is particularly useful if you have a nested tree of items, ie.
                                  the typical bill-of-materials pattern. (Although a <span class="emphasis"><em>nested set</em></span> or a
                                  <span class="emphasis"><em>materialized path</em></span> might be a better option for read-mostly trees.)
                              
               </p>
            </div>
            <div class="sect2" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="performance-fetching-subselect"></a>19.1.6.&nbsp;Using subselect fetching
                        </h3>
                     </div>
                  </div>
               </div>
               <p>
                                  If one lazy collection or single-valued proxy has to be fetched, Hibernate loads all of
                                  them, re-running the original query in a subselect. This works in the same way as
                                  batch-fetching, without the piecemeal loading.
                              
               </p>
            </div>
            <div class="sect2" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="performance-fetching-lazyproperties"></a>19.1.7.&nbsp;Using lazy property fetching
                        </h3>
                     </div>
                  </div>
               </div>
               <p>
                                  Hibernate3 supports the lazy fetching of individual properties. This optimization technique
                                  is also known as <span class="emphasis"><em>fetch groups</em></span>. Please note that this is mostly a
                                  marketing feature, as in practice, optimizing row reads is much more important than
                                  optimization of column reads. However, only loading some properties of a class might
                                  be useful in extreme cases, when legacy tables have hundreds of columns and the data model
                                  can not be improved.
                              
               </p>
               <p>
                                  To enable lazy property loading, set the <code class="literal">lazy</code> attribute on your
                                  particular property mappings:
                              
               </p><pre class="programlisting">&lt;class name="Document"&gt;
       &lt;id name="id"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true" length="50"/&gt;
    &lt;property name="summary" not-null="true" length="200" lazy="true"/&gt;
    &lt;property name="text" not-null="true" length="2000" lazy="true"/&gt;
&lt;/class&gt;</pre><p>
                                  Lazy property loading requires buildtime bytecode instrumentation! If your persistent
                                  classes are not enhanced, Hibernate will silently ignore lazy property settings and
                                  fall back to immediate fetching.
                              
               </p>
               <p>
                                  For bytecode instrumentation, use the following Ant task:
                              
               </p><pre class="programlisting">&lt;target name="instrument" depends="compile"&gt;
    &lt;taskdef name="instrument" classname="org.hibernate.tool.instrument.InstrumentTask"&gt;
        &lt;classpath path="${jar.path}"/&gt;
        &lt;classpath path="${classes.dir}"/&gt;
        &lt;classpath refid="lib.class.path"/&gt;
    &lt;/taskdef&gt;

    &lt;instrument verbose="true"&gt;
        &lt;fileset dir="${testclasses.dir}/org/hibernate/auction/model"&gt;
            &lt;include name="*.class"/&gt;
        &lt;/fileset&gt;
    &lt;/instrument&gt;
&lt;/target&gt;</pre><p>
                                  A different (better?) way to avoid unnecessary column reads, at least for
                                  read-only transactions is to use the projection features of HQL or Criteria
                                  queries. This avoids the need for buildtime bytecode processing and is
                                  certainly a preferred solution.
                              
               </p>
               <p>
                                  You may force the usual eager fetching of properties using <code class="literal">fetch all
                                     properties</code> in HQL.
                              
               </p>
            </div>
         </div>
      </div>
      <div class="navfooter">
         <hr>
         <table width="100%" summary="Navigation footer">
            <tr>
               <td width="40%" align="left"><a accesskey="p" href="xml-manipulation.html">Prev</a>&nbsp;
               </td>
               <td width="20%" align="center">&nbsp;</td>
               <td width="40%" align="right">&nbsp;<a accesskey="n" href="performance-cache.html">Next</a></td>
            </tr>
            <tr>
               <td width="40%" align="left" valign="top">18.3.&nbsp;Manipulating XML data&nbsp;</td>
               <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
               <td width="40%" align="right" valign="top">&nbsp;19.2.&nbsp;The Second Level Cache</td>
            </tr>
         </table>
      </div>
   </body>
</html>